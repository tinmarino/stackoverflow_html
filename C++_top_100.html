<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>C++_top_100.md – C++ &lt;- StackOverflow top 100</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        background-color: #232629;
        color: #7a7c7d;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #7a7c7d;  padding-left: 4px; }
    div.sourceCode
      { color: #cfcfc2; background-color: #232629; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span { color: #cfcfc2; } /* Normal */
    code span.al { color: #95da4c; background-color: #4d1f24; font-weight: bold; } /* Alert */
    code span.an { color: #3f8058; } /* Annotation */
    code span.at { color: #2980b9; } /* Attribute */
    code span.bn { color: #f67400; } /* BaseN */
    code span.bu { color: #7f8c8d; } /* BuiltIn */
    code span.cf { color: #fdbc4b; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #3daee9; } /* Char */
    code span.cn { color: #27aeae; font-weight: bold; } /* Constant */
    code span.co { color: #7a7c7d; } /* Comment */
    code span.cv { color: #7f8c8d; } /* CommentVar */
    code span.do { color: #a43340; } /* Documentation */
    code span.dt { color: #2980b9; } /* DataType */
    code span.dv { color: #f67400; } /* DecVal */
    code span.er { color: #da4453; text-decoration: underline; } /* Error */
    code span.ex { color: #0099ff; font-weight: bold; } /* Extension */
    code span.fl { color: #f67400; } /* Float */
    code span.fu { color: #8e44ad; } /* Function */
    code span.im { color: #27ae60; } /* Import */
    code span.in { color: #c45b00; } /* Information */
    code span.kw { color: #cfcfc2; font-weight: bold; } /* Keyword */
    code span.op { color: #cfcfc2; } /* Operator */
    code span.ot { color: #27ae60; } /* Other */
    code span.pp { color: #27ae60; } /* Preprocessor */
    code span.re { color: #2980b9; background-color: #153042; } /* RegionMarker */
    code span.sc { color: #3daee9; } /* SpecialChar */
    code span.ss { color: #da4453; } /* SpecialString */
    code span.st { color: #f44f4f; } /* String */
    code span.va { color: #27aeae; } /* Variable */
    code span.vs { color: #da4453; } /* VerbatimString */
    code span.wa { color: #da4453; } /* Warning */
  </style>
  <link rel="stylesheet" href="../wiki_html/Css/include.css" />
  <script type="text/javascript" src="https://raw.githubusercontent.com/tinmarino/wiki_html/master/Css/js_masonry_desandro.js"></script>
  <p><link rel="stylesheet" href="https://raw.githubusercontent.com/tinmarino/wiki_html/master/Css/color_dark_solarized.css"> <link rel="stylesheet" href="https://raw.githubusercontent.com/tinmarino/wiki_html/master/Css/layout_toc.css"></p>
</head>
<body>
<header id="title-block-header">
<h1 class="title">C++ &lt;- StackOverflow top 100</h1>
</header>
<section class="level2">
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
<section id="easiest-way-to-convert-int-to-string-in-c-score-2671193-in-2018" class="level3">
<h3>1: Easiest way to convert int to string in C++ (score <a href="https://stackoverflow.com/q/5590381.html">2671193</a> in 2018)</h3>
<section id="question" class="level4">
<h4>Question</h4>
<p>What is the easiest way to convert from <code>int</code> to equivalent <code>string</code> in C++. I am aware of two methods. Is there any easier way?</p>
<ol type="1">
<li></li>
</ol>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="dt">int</span> a = <span class="dv">10</span>;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="dt">char</span> *intStr = itoa(a);</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>string str = string(intStr);</span></code></pre></div>
<ol start="2" type="1">
<li></li>
</ol>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="dt">int</span> a = <span class="dv">10</span>;</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>stringstream ss;</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>ss &lt;&lt; a;</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>string str = ss.str();</span></code></pre></div>
</section>
<section id="answer-accepted-score-1940" class="level4">
<h4>Answer accepted (score 1940)</h4>
<p>C++11 introduces <a href="http://en.cppreference.com/w/cpp/string/basic_string/stol" rel="noreferrer"><code>std::stoi</code></a> (and variants for each numeric type) and <a href="http://en.cppreference.com/w/cpp/string/basic_string/to_string" rel="noreferrer"><code>std::to_string</code></a>, the counterparts of the C <code>atoi</code> and <code>itoa</code> but expressed in term of <code>std::string</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span><span class="pp"> </span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="bu">std::</span>string s = <span class="bu">std::</span>to_string(<span class="dv">42</span>);</span></code></pre></div>
<p>is therefore the shortest way I can think of. You can even omit naming the type, using the <code>auto</code> keyword:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">auto</span> s = <span class="bu">std::</span>to_string(<span class="dv">42</span>);</span></code></pre></div>
<p><em>Note: see <strong>[string.conversions]</strong> (<strong>21.5</strong> in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf" rel="noreferrer">n3242</a>)</em></p>
</section>
<section id="answer-2-score-179" class="level4">
<h4>Answer 2 (score 179)</h4>
<p>Picking up a discussion with <span class="citation" data-cites="v.oddou">@v.oddou</span> a couple of years later, C++17 has finally delivered a way to do the originally macro-based type-agnostic solution (preserved below) <em>without</em> going through macro uglyness.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co">// variadic template</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="kw">template</span> &lt; <span class="kw">typename</span>... Args &gt;</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="bu">std::</span>string sstr( Args &amp;&amp;... args )</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>{</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>    <span class="bu">std::</span>ostringstream sstr;</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>    <span class="co">// fold expression</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>    ( sstr &lt;&lt; <span class="bu">std::</span>dec &lt;&lt; ... &lt;&lt; args );</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>    <span class="cf">return</span> sstr.str();</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>}</span></code></pre></div>
<p>Usage:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="dt">int</span> i = <span class="dv">42</span>;</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="bu">std::</span>string s = sstr( <span class="st">&quot;i is: &quot;</span>, i );</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>puts( sstr( i ).c_str() );</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>Foo x( <span class="dv">42</span> );</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a><span class="cf">throw</span> <span class="bu">std::</span>runtime_error( sstr( <span class="st">&quot;Foo is &#39;&quot;</span>, x, <span class="st">&quot;&#39;, i is &quot;</span>, i ) );</span></code></pre></div>
<hr>
<p><strong>Original answer:</strong></p>
<p>Since “converting … to string” is a recurring problem, I always define the <a href="http://rootdirectory.ddns.net/dokuwiki/doku.php?id=software:sstr" rel="noreferrer">SSTR()</a> macro in a central header of my C++ sources:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sstream&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="pp">#define SSTR</span>(<span class="pp"> </span>x<span class="pp"> </span>)<span class="pp"> </span><span class="kw">static_cast</span>&lt;<span class="pp"> </span><span class="bu">std::</span>ostringstream &amp;<span class="pp"> </span>&gt;(<span class="pp"> </span>\</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span class="pp">        </span>(<span class="pp"> </span><span class="bu">std::</span>ostringstream()<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="bu">std::</span>dec &lt;&lt;<span class="pp"> </span>x<span class="pp"> </span>)<span class="pp"> </span>).str()</span></code></pre></div>
<p>Usage is as easy as could be:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="dt">int</span> i = <span class="dv">42</span>;</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="bu">std::</span>string s = SSTR( <span class="st">&quot;i is: &quot;</span> &lt;&lt; i );</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>puts( SSTR( i ).c_str() );</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>Foo x( <span class="dv">42</span> );</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a><span class="cf">throw</span> <span class="bu">std::</span>runtime_error( SSTR( <span class="st">&quot;Foo is &#39;&quot;</span> &lt;&lt; x &lt;&lt; <span class="st">&quot;&#39;, i is &quot;</span> &lt;&lt; i ) );</span></code></pre></div>
<p>The above is C++98 compatible (if you cannot use C++11 <code>std::to_string</code>), and does not need any third-party includes (if you cannot use Boost <code>lexical_cast&amp;lt;&amp;gt;</code>); both these other solutions have a better performance though.</p>
</section>
<section id="answer-3-score-103" class="level4">
<h4>Answer 3 (score 103)</h4>
<p>I usually use the following method:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sstream&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>  <span class="bu">std::</span>string NumberToString ( T Number )</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>  {</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>     <span class="bu">std::</span>ostringstream ss;</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>     ss &lt;&lt; Number;</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>     <span class="cf">return</span> ss.str();</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>  }</span></code></pre></div>
<p>It is described in details <a href="http://www.cplusplus.com/articles/D9j2Nwbp/" rel="nofollow noreferrer">here</a>.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="the-definitive-c-book-guide-and-list-score-2220799-in-2018" class="level3">
<h3>2: The Definitive C++ Book Guide and List (score <a href="https://stackoverflow.com/q/388242.html">2220799</a> in 2018)</h3>
<section id="question-1" class="level4">
<h4>Question</h4>
<p>This question attempts to collect the few pearls among the dozens of bad C++ books that are published every year.</p>
<p>Unlike many other programming languages, which are often picked up on the go from tutorials found on the Internet, few are able to quickly pick up C++ without studying a well-written C++ book. It is way too big and complex for doing this. In fact, it is so big and complex, that <strong><em>there are very many very bad C++ books</em></strong> out there. And we are not talking about bad style, but things like sporting <em>glaringly obvious factual errors</em> and <em>promoting abysmally bad programming styles</em>.</p>
<p>Please edit the accepted answer to provide <strong>quality books</strong> and an approximate skill level — <em>preferably</em> <strong>after</strong> <em>discussing your addition in <a href="http://chat.stackoverflow.com/rooms/10/loungec">the C++ chat room</a></em>. (The regulars might mercilessly undo your work if they disagree with a recommendation.) Add a short blurb/description about each book that you have personally read/benefited from. Feel free to debate quality, headings, etc. Books that meet the criteria will be added to the list. Books that have reviews by the Association of C and C++ Users (ACCU) have links to the review.</p>
<p><sub>*Note: FAQs and other resources can be found in the <a href="https://stackoverflow.com/tags/c%2b%2b/info">C++ tag info</a> and under <a href="/questions/tagged/c%2b%2b-faq" class="post-tag" title="show questions tagged &
#39;c++-faq&#39;" rel="tag">c++-faq</a>. </sub></p>
</section>
<section id="answer-2-score-4599" class="level4">
<h4>Answer 2 (score 4599)</h4>
<h5>
Beginner
</h2>
<h5>
Introductory, no previous programming experience
</h3>
<ul>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/0321714113" rel="noreferrer" rel="nofollow noreferrer"><em>C++ Primer</em></a> * (Stanley Lippman, Josée Lajoie, and Barbara E. Moo) (<strong>updated for C++11</strong>) Coming at 1k pages, this is a very thorough introduction into C++ that covers just about everything in the language in a very accessible format and in great detail. The fifth edition (released August 16, 2012) covers C++11. <a href="http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=1848" rel="noreferrer">[Review]</a>
</p>
</li>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/0321992784" rel="noreferrer" rel="nofollow noreferrer"><em>Programming: Principles and Practice Using C++</em></a> (Bjarne Stroustrup, 2nd Edition - May 25, 2014) (<strong>updated for C++11/C++14</strong>) An introduction to programming using C++ by the creator of the language. A good read, that assumes no previous programming experience, but is not only for beginners.
</p>
</li>
</ul>
<p>
<sub> * Not to be confused with <a href="https://rads.stackoverflow.com/amzn/click/com/0672326973" rel="noreferrer" rel="nofollow noreferrer"><em>C++ Primer Plus</em></a> (Stephen Prata), with a significantly less favorable <a href="http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=1744" rel="noreferrer">review</a>. </sub>
</p>
<h5>
Introductory, with previous programming experience
</h3>
<ul>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/B00F8CWGOS" rel="noreferrer" rel="nofollow noreferrer"><em>A Tour of C++</em></a> (Bjarne Stroustrup) (<strong><a href="http://a.co/f7WPDeD" rel="noreferrer">2nd edition for C++17</a></strong>) The “tour” is a quick (about 180 pages and 14 chapters) tutorial overview of all of standard C++ (language and standard library, <strong>and using C++11</strong>) at a moderately high level for people who already know C++ or at least are experienced programmers. This book is an extended version of the material that constitutes Chapters 2-5 of The C++ Programming Language, 4th edition.
</p>
</li>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/020170353X" rel="noreferrer" rel="nofollow noreferrer"><em>Accelerated C++</em></a> (Andrew Koenig and Barbara Moo, 1st Edition - August 24, 2000) This basically covers the same ground as the <em>C++ Primer</em>, but does so on a fourth of its space. This is largely because it does not attempt to be an introduction to <em>programming</em>, but an introduction to <em>C++</em> for people who’ve previously programmed in some other language. It has a steeper learning curve, but, for those who can cope with this, it is a very compact introduction to the language. (Historically, it broke new ground by being the first beginner’s book to use a modern approach to teaching the language.) Despite this, the C++ it teaches is purely C++98. <a href="http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=1185" rel="noreferrer">[Review]</a>
</p>
</li>
</ul>
<h5>
Best practices
</h3>
<ul>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/0321334876" rel="noreferrer" rel="nofollow noreferrer"><em>Effective C++</em></a> (Scott Meyers, 3rd Edition - May 22, 2005) This was written with the aim of being the best second book C++ programmers should read, and it succeeded. Earlier editions were aimed at programmers coming from C, the third edition changes this and targets programmers coming from languages like Java. It presents ~50 easy-to-remember rules of thumb along with their rationale in a very accessible (and enjoyable) style. For C++11 and C++14 the examples and a few issues are outdated and Effective Modern C++ should be preferred. <a href="http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=700" rel="noreferrer">[Review]</a>
</p>
</li>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/1491903996" rel="noreferrer" rel="nofollow noreferrer"><em>Effective Modern C++</em></a> (Scott Meyers) This is basically the new version of <em>Effective C++</em>, aimed at C++ programmers making the transition from C++03 to C++11 and C++14.
</p>
</li>
<li>
<a href="https://rads.stackoverflow.com/amzn/click/com/0201749629" rel="noreferrer" rel="nofollow noreferrer"><em>Effective STL</em></a> (Scott Meyers) This aims to do the same to the part of the standard library coming from the STL what <em>Effective C++</em> did to the language as a whole: It presents rules of thumb along with their rationale. <a href="http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=67" rel="noreferrer">[Review]</a>
</li>
</ul>
<hr>
<h5>
Intermediate
</h2>
<ul>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/020163371X" rel="noreferrer" rel="nofollow noreferrer"><em>More Effective C++</em></a> (Scott Meyers) Even more rules of thumb than <em>Effective C++</em>. Not as important as the ones in the first book, but still good to know.
</p>
</li>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/0201615622" rel="noreferrer" rel="nofollow noreferrer"><em>Exceptional C++</em></a> (Herb Sutter) Presented as a set of puzzles, this has one of the best and thorough discussions of the proper resource management and exception safety in C++ through Resource Acquisition is Initialization (RAII) in addition to in-depth coverage of a variety of other topics including the pimpl idiom, name lookup, good class design, and the C++ memory model. <a href="http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=209" rel="noreferrer">[Review]</a>
</p>
</li>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/020170434X" rel="noreferrer" rel="nofollow noreferrer"><em>More Exceptional C++</em></a> (Herb Sutter) Covers additional exception safety topics not covered in <em>Exceptional C++</em>, in addition to discussion of effective object-oriented programming in C++ and correct use of the STL. <a href="http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=784" rel="noreferrer">[Review]</a>
</p>
</li>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/0201760428" rel="noreferrer" rel="nofollow noreferrer"><em>Exceptional C++ Style</em></a> (Herb Sutter) Discusses generic programming, optimization, and resource management; this book also has an excellent exposition of how to write modular code in C++ by using non-member functions and the single responsibility principle. <a href="http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=107" rel="noreferrer">[Review]</a>
</p>
</li>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/0321113586" rel="noreferrer" rel="nofollow noreferrer"><em>C++ Coding Standards</em></a> (Herb Sutter and Andrei Alexandrescu) “Coding standards” here doesn’t mean “how many spaces should I indent my code?” This book contains 101 best practices, idioms, and common pitfalls that can help you to write correct, understandable, and efficient C++ code. <a href="http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=1439" rel="noreferrer">[Review]</a>
</p>
</li>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/0201734842" rel="noreferrer" rel="nofollow noreferrer"><em>C++ Templates: The Complete Guide</em></a> (David Vandevoorde and Nicolai M. Josuttis) This is <em>the</em> book about templates as they existed before C++11. It covers everything from the very basics to some of the most advanced template metaprogramming and explains every detail of how templates work (both conceptually and at how they are implemented) and discusses many common pitfalls. Has excellent summaries of the One Definition Rule (ODR) and overload resolution in the appendices. A <a href="https://rads.stackoverflow.com/amzn/click/com/0321714121" rel="noreferrer" rel="nofollow noreferrer">second edition</a> covering C++11, C++14 and C++17 has been already published. <a href="http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=506" rel="noreferrer">[Review]</a>
</p>
</li>
<li>
<p>
<a href="https://leanpub.com/cpp17/" rel="noreferrer"><em>C++ 17 - The Complete Guide</em></a> (Nicolai M. Josuttis) This book describes all the new features introduced in the C++17 Standard covering everything from the simple ones like ‘Inline Variables’, ‘constexpr if’ all the way up to ‘Polymorphic Memory Resources’ and ‘New and Delete with overaligned Data’.
</p>
</li>
</ul>
<hr>
<h5>
Advanced
</h2>
<ul>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/0201704315" rel="noreferrer" rel="nofollow noreferrer"><em>Modern C++ Design</em></a> (Andrei Alexandrescu) A groundbreaking book on advanced generic programming techniques. Introduces policy-based design, type lists, and fundamental generic programming idioms then explains how many useful design patterns (including small object allocators, functors, factories, visitors, and multi-methods) can be implemented efficiently, modularly, and cleanly using generic programming. <a href="http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=979" rel="noreferrer">[Review]</a>
</p>
</li>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/0321227255" rel="noreferrer" rel="nofollow noreferrer"><em>C++ Template Metaprogramming</em></a> (David Abrahams and Aleksey Gurtovoy)
</p>
</li>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/1933988770" rel="noreferrer" rel="nofollow noreferrer"><em>C++ Concurrency In Action</em></a> (Anthony Williams) A book covering C++11 concurrency support including the thread library, the atomics library, the C++ memory model, locks and mutexes, as well as issues of designing and debugging multithreaded applications. A <a href="https://rads.stackoverflow.com/amzn/click/com/1617294691" rel="noreferrer" rel="nofollow noreferrer">second edition</a> covering C++14 and C++17 has been already published.
</p>
</li>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/1460966163" rel="noreferrer" rel="nofollow noreferrer"><em>Advanced C++ Metaprogramming</em></a> (Davide Di Gennaro) A pre-C++11 manual of TMP techniques, focused more on practice than theory. There are a ton of snippets in this book, some of which are made obsolete by type traits, but the techniques, are nonetheless useful to know. If you can put up with the quirky formatting/editing, it is easier to read than Alexandrescu, and arguably, more rewarding. For more experienced developers, there is a good chance that you may pick up something about a dark corner of C++ (a quirk) that usually only comes about through extensive experience.
</p>
</li>
</ul>
<hr>
<h5>
Reference Style - All Levels
</h2>
<ul>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/0321958322" rel="noreferrer" rel="nofollow noreferrer"><em>The C++ Programming Language</em></a> (Bjarne Stroustrup) (<strong>updated for C++11</strong>) The classic introduction to C++ by its creator. Written to parallel the classic K&amp;R, this indeed reads very much like it and covers just about everything from the core language to the standard library, to programming paradigms to the language’s philosophy. <a href="http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=1853" rel="noreferrer">[Review]</a> Note: All releases of the C++ standard are tracked in this question: <a href="https://stackoverflow.com/a/4653479/14065">Where do I find the current C++ standard</a>.
</p>
</li>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/0321623215" rel="noreferrer" rel="nofollow noreferrer"><em>C++ Standard Library Tutorial and Reference</em></a> (Nicolai Josuttis) (<strong>updated for C++11</strong>) <em>The</em> introduction and reference for the C++ Standard Library. The second edition (released on April 9, 2012) covers C++11. <a href="http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=1849" rel="noreferrer">[Review]</a>
</p>
</li>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/0201183951" rel="noreferrer" rel="nofollow noreferrer"><em>The C++ IO Streams and Locales</em></a> (Angelika Langer and Klaus Kreft) There’s very little to say about this book except that, if you want to know anything about streams and locales, then this is the one place to find definitive answers. <a href="http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=200" rel="noreferrer">[Review]</a>
</p>
</li>
</ul>
<p><strong>C++11/14/17/… References:</strong></p>
<ul>
<li>
<p>
<em>The C++<a href="https://www.iso.org/standard/50372.html" rel="noreferrer">11</a>/<a href="https://www.iso.org/standard/64029.html" rel="noreferrer">14</a>/<a href="https://www.iso.org/standard/68564.html" rel="noreferrer">17</a> Standard (INCITS/ISO/IEC 14882:2011/2014/2017)</em> This, of course, is the final arbiter of all that is or isn’t C++. Be aware, however, that it is intended purely as a reference for <em>experienced</em> users willing to devote considerable time and effort to its understanding. The C++17 standard is released in electronic form for 198 Swiss Francs.
</p>
</li>
<li>
<p>
The C++17 standard is available, but seemingly not in an economical form – <a href="https://www.iso.org/standard/68564.html" rel="noreferrer">directly from the ISO</a> it costs 198 Swiss Francs (about $200 US). For most people, the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf" rel="noreferrer">final draft before standardization</a> is more than adequate (and free). Many will prefer an <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4778.pdf" rel="noreferrer">even newer draft</a>, documenting new features that are likely to be included in C++20.
</p>
</li>
<li>
<p>
<a href="http://www.artima.com/shop/overview_of_the_new_cpp" rel="noreferrer"><em>Overview of the New C++ (C++11/14) (PDF only)</em></a> (Scott Meyers) (<strong>updated for C++14</strong>) These are the presentation materials (slides and some lecture notes) of a three-day training course offered by Scott Meyers, who’s a highly respected author on C++. Even though the list of items is short, the quality is high.
</p>
</li>
<li>
<p>
The <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md" rel="noreferrer"><em>C++ Core Guidelines (C++11/14/17/…)</em></a> (edited by Bjarne Stroustrup and Herb Sutter) is an evolving online document consisting of a set of guidelines for using modern C++ well. The guidelines are focused on relatively higher-level issues, such as interfaces, resource management, memory management and concurrency affecting application architecture and library design. The project was <a href="https://isocpp.org/blog/2015/09/bjarne-stroustrup-announces-cpp-core-guidelines" rel="noreferrer">announced at CppCon’15 by Bjarne Stroustrup and others</a> and welcomes contributions from the community. Most guidelines are supplemented with a rationale and examples as well as discussions of possible tool support. Many rules are designed specifically to be automatically checkable by static analysis tools.
</p>
</li>
<li>
<p>
The <a href="https://isocpp.org/faq" rel="noreferrer"><em>C++ Super-FAQ</em></a> (Marshall Cline, Bjarne Stroustrup and others) is an effort by the Standard C++ Foundation to unify the C++ FAQs previously maintained individually by Marshall Cline and Bjarne Stroustrup and also incorporating new contributions. The items mostly address issues at an intermediate level and are often written with a humorous tone. Not all items might be fully up to date with the latest edition of the C++ standard yet.
</p>
</li>
<li>
<p>
<a href="http://en.cppreference.com/" rel="noreferrer"><em>cppreference.com (C++03/11/14/17/…)</em></a> (initiated by Nate Kohl) is a wiki that summarizes the basic core-language features and has extensive documentation of the C++ standard library. The documentation is very precise but is easier to read than the official standard document and provides better navigation due to its wiki nature. The project documents all versions of the C++ standard and the site allows filtering the display for a specific version. The project was <a href="https://isocpp.org/blog/2015/07/cppcon-2014-cppreference.com-documenting-cpp-one-edit-at-a-time-nate-kohl" rel="noreferrer">presented by Nate Kohl at CppCon’14</a>.
</p>
</li>
</ul>
<hr>
<h5>
Classics / Older
</h2>
<p><strong>Note:</strong> Some information contained within these books may not be up-to-date or no longer considered best practice.</p>
<ul>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/0201543303" rel="noreferrer" rel="nofollow noreferrer"><em>The Design and Evolution of C++</em></a> (Bjarne Stroustrup) If you want to know <em>why</em> the language is the way it is, this book is where you find answers. This covers everything <em>before the standardization</em> of C++.
</p>
</li>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/0201423391" rel="noreferrer" rel="nofollow noreferrer"><em>Ruminations on C++</em></a> - (Andrew Koenig and Barbara Moo) <a href="http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=776" rel="noreferrer">[Review]</a>
</p>
</li>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/0201548550" rel="noreferrer" rel="nofollow noreferrer"><em>Advanced C++ Programming Styles and Idioms</em></a> (James Coplien) A predecessor of the pattern movement, it describes many C++-specific “idioms”. It’s certainly a very good book and might still be worth a read if you can spare the time, but quite old and not up-to-date with current C++.
</p>
</li>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/0201633620" rel="noreferrer" rel="nofollow noreferrer"><em>Large Scale C++ Software Design</em></a> (John Lakos) Lakos explains techniques to manage very big C++ software projects. Certainly, a good read, if it only was up to date. It was written long before C++ 98 and misses on many features (e.g. namespaces) important for large-scale projects. If you need to work in a big C++ software project, you might want to read it, although you need to take more than a grain of salt with it. The first volume of a new edition is <a href="https://rads.stackoverflow.com/amzn/click/com/0201717069" rel="noreferrer" rel="nofollow noreferrer">expected in 2019</a>.
</p>
</li>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/0201834545" rel="noreferrer" rel="nofollow noreferrer"><em>Inside the C++ Object Model</em></a> (Stanley Lippman) If you want to know how virtual member functions are commonly implemented and how base objects are commonly laid out in memory in a multi-inheritance scenario, and how all this affects performance, this is where you will find thorough discussions of such topics.
</p>
</li>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/0201514591" rel="noreferrer" rel="nofollow noreferrer"><em>The Annotated C++ Reference Manual</em></a> (Bjarne Stroustrup, Margaret A. Ellis) This book is quite outdated in the fact that it explores the 1989 C++ 2.0 version - Templates, exceptions, namespaces and new casts were not yet introduced. Saying that however, this book goes through the entire C++ standard of the time explaining the rationale, the possible implementations, and features of the language. This is not a book to learn programming principles and patterns on C++, but to understand every aspect of the C++ language.
</p>
</li>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/0139798099" rel="noreferrer" rel="nofollow noreferrer"><em>Thinking in C++</em></a> (Bruce Eckel, 2nd Edition, 2000). Two volumes; is a tutorial style <em>free</em> set of intro level books. Downloads: <a href="https://ia800100.us.archive.org/10/items/TICPP2ndEdVolOne/TICPP-2nd-ed-Vol-one.zip" rel="noreferrer">vol 1</a>, <a href="https://ia800108.us.archive.org/24/items/TICPP2ndEdVolTwo/TICPP-2nd-ed-Vol-two.zip" rel="noreferrer">vol 2</a>. Unfortunately they’re marred by a number of trivial errors (e.g. maintaining that temporaries are automatically <code>const</code>), with no official errata list. A partial 3<sup>rd</sup> party errata list is available at (<a href="http://www.computersciencelab.com/Eckel.htm" rel="noreferrer">http://www.computersciencelab.com/Eckel.htm</a>), but it’s apparently not maintained.
</p>
</li>
<li>
<p>
<a href="https://rads.stackoverflow.com/amzn/click/com/0201533936" rel="noreferrer" rel="nofollow noreferrer"><em>Scientific and Engineering C++: An Introduction to Advanced Techniques and Examples</em></a> (John Barton and Lee Nackman) It is a comprehensive and very detailed book that tried to explain and make use of all the features available in C++, in the context of numerical methods. It introduced at the time several new techniques, such as the Curiously Recurring Template Pattern (CRTP, also called Barton-Nackman trick). It pioneered several techniques such as dimensional analysis and automatic differentiation. It came with a lot of compilable and useful code, ranging from an expression parser to a Lapack wrapper. The code is still available here: <a href="http://www.informit.com/store/scientific-and-engineering-c-plus-plus-an-introduction-9780201533934" rel="noreferrer">http://www.informit.com/store/scientific-and-engineering-c-plus-plus-an-introduction-9780201533934</a>. Unfortunately, the books have become somewhat outdated in the style and C++ features, however, it was an incredible tour-de-force at the time (1994, pre-STL). The chapters on dynamics inheritance are a bit complicated to understand and not very useful. An updated version of this classic book that includes move semantics and the lessons learned from the STL would be very nice.
</p>
</li>
</ul>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-do-i-iterate-over-the-words-of-a-string-score-2132194-in-2018" class="level3">
<h3>3: How do I iterate over the words of a string? (score <a href="https://stackoverflow.com/q/236129.html">2132194</a> in 2018)</h3>
<section id="question-2" class="level4">
<h4>Question</h4>
<p>I’m trying to iterate over the words of a string.</p>
<p>The string can be assumed to be composed of words separated by whitespace.</p>
<p>Note that I’m not interested in C string functions or that kind of character manipulation/access. Also, please give precedence to elegance over efficiency in your answer.</p>
<p>The best solution I have right now is:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sstream&gt;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>{</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>    string s = <span class="st">&quot;Somewhere down the road&quot;</span>;</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a>    istringstream iss(s);</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true"></a>    <span class="cf">do</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true"></a>    {</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true"></a>        string subs;</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true"></a>        iss &gt;&gt; subs;</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true"></a>        cout &lt;&lt; <span class="st">&quot;Substring: &quot;</span> &lt;&lt; subs &lt;&lt; endl;</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true"></a>    } <span class="cf">while</span> (iss);</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true"></a>}</span></code></pre></div>
<p>Is there a more elegant way to do this?</p>
</section>
<section id="answer-accepted-score-1311" class="level4">
<h4>Answer accepted (score 1311)</h4>
<p>For what it’s worth, here’s another way to extract tokens from an input string, relying only on standard library facilities. It’s an example of the power and elegance behind the design of the STL.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sstream&gt;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iterator&gt;</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a>    <span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a>    string sentence = <span class="st">&quot;And I feel fine...&quot;</span>;</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a>    istringstream iss(sentence);</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true"></a>    copy(istream_iterator&lt;string&gt;(iss),</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true"></a>         istream_iterator&lt;string&gt;(),</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true"></a>         ostream_iterator&lt;string&gt;(cout, <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>));</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true"></a>}</span></code></pre></div>
<p>Instead of copying the extracted tokens to an output stream, one could insert them into a container, using the same generic <a href="https://en.cppreference.com/w/cpp/algorithm/copy" rel="noreferrer"><code>copy</code></a> algorithm.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>vector&lt;string&gt; tokens;</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>copy(istream_iterator&lt;string&gt;(iss),</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>     istream_iterator&lt;string&gt;(),</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>     back_inserter(tokens));</span></code></pre></div>
<p>… or create the <code>vector</code> directly:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>vector&lt;string&gt; tokens{istream_iterator&lt;string&gt;{iss},</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>                      istream_iterator&lt;string&gt;{}};</span></code></pre></div>
</section>
<section id="answer-2-score-2391" class="level4">
<h4>Answer 2 (score 2391)</h4>
<p>I use this to split string by a delimiter. The first puts the results in a pre-constructed vector, the second returns a new vector.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sstream&gt;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iterator&gt;</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> Out&gt;</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a><span class="dt">void</span> split(<span class="at">const</span> <span class="bu">std::</span>string &amp;s, <span class="dt">char</span> delim, Out result) {</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>    <span class="bu">std::</span>istringstream iss(s);</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a>    <span class="bu">std::</span>string item;</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a>    <span class="cf">while</span> (<span class="bu">std::</span>getline(iss, item, delim)) {</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a>        *result++ = item;</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true"></a>    }</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true"></a>}</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true"></a></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="bu">std::</span>string&gt; split(<span class="at">const</span> <span class="bu">std::</span>string &amp;s, <span class="dt">char</span> delim) {</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true"></a>    <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>string&gt; elems;</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true"></a>    split(s, delim, <span class="bu">std::</span>back_inserter(elems));</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true"></a>    <span class="cf">return</span> elems;</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true"></a>}</span></code></pre></div>
<hr>
<p>Note that this solution does not skip empty tokens, so the following will find 4 items, one of which is empty:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="bu">std::</span>string&gt; x = split(<span class="st">&quot;one:two::three&quot;</span>, <span class="ch">&#39;:&#39;</span>);</span></code></pre></div>
</section>
<section id="answer-3-score-825" class="level4">
<h4>Answer 3 (score 825)</h4>
<p>A possible solution using Boost might be:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;boost/algorithm/string.hpp&gt;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="bu">std::</span>string&gt; strs;</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a><span class="ex">boost::</span>split(strs, <span class="st">&quot;string to split&quot;</span>, <span class="ex">boost::</span>is_any_of(<span class="st">&quot;</span><span class="sc">\t</span><span class="st"> &quot;</span>));</span></code></pre></div>
<p>This approach might be even faster than the <code>stringstream</code> approach. And since this is a generic template function it can be used to split other types of strings (wchar, etc. or UTF-8) using all kinds of delimiters.</p>
<p>See the <a href="http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html" rel="noreferrer">documentation</a> for details.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="convert-char-to-int-in-c-and-c-score-1516373-in-2011" class="level3">
<h3>4: Convert char to int in C and C++ (score <a href="https://stackoverflow.com/q/5029840.html">1516373</a> in 2011)</h3>
<section id="question-3" class="level4">
<h4>Question</h4>
<p>How do I convert a <code>char</code> to an <code>int</code> in C and C++?</p>
</section>
<section id="answer-2-score-466" class="level4">
<h4>Answer 2 (score 466)</h4>
<p>Depends on what you want to do:</p>
<p>to read the value as an ascii code, you can write</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="dt">char</span> a = <span class="ch">&#39;a&#39;</span>;</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span class="dt">int</span> ia = (<span class="dt">int</span>)a; </span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a><span class="co">/* note that the int cast is not necessary -- int ia = a would suffice */</span></span></code></pre></div>
<p>to convert the character <code>'0' -&amp;gt; 0</code>, <code>'1' -&amp;gt; 1</code>, etc, you can write</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="dt">char</span> a = <span class="ch">&#39;4&#39;</span>;</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a><span class="dt">int</span> ia = a - <span class="ch">&#39;0&#39;</span>;</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a><span class="co">/* check here if ia is bounded by 0 and 9 */</span></span></code></pre></div>
<p>
<strong>Explanation</strong>:<br> <code>a - '0'</code> is equivalent to <code>((int)a) - ((int)'0')</code>, which means the ascii values of the characters are subtracted from each other. Since <code>0</code> comes directly before <code>1</code> in the ascii table (and so on until <code>9</code>), the difference between the two gives the number that the character <code>a</code> represents.
</p>
</section>
<section id="answer-3-score-78" class="level4">
<h4>Answer 3 (score 78)</h4>
<p>Well, in ASCII code, the numbers (digits) start from <strong>48</strong>. All you need to do is:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="dt">int</span> x = (<span class="dt">int</span>)character - <span class="dv">48</span>;</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="why-is-processing-a-sorted-array-faster-than-processing-an-unsorted-array-score-1410048-in-2019" class="level3">
<h3>5: Why is processing a sorted array faster than processing an unsorted array? (score <a href="https://stackoverflow.com/q/11227809.html">1410048</a> in 2019)</h3>
<section id="question-4" class="level4">
<h4>Question</h4>
<p>Here is a piece of C++ code that shows some very peculiar behavior. For some strange reason, sorting the data miraculously makes the code almost six times faster:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;ctime&gt;</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a>{</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true"></a>    <span class="co">// Generate data</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true"></a>    <span class="at">const</span> <span class="dt">unsigned</span> arraySize = <span class="dv">32768</span>;</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true"></a>    <span class="dt">int</span> data[arraySize];</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true"></a></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">unsigned</span> c = <span class="dv">0</span>; c &lt; arraySize; ++c)</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true"></a>        data[c] = <span class="bu">std::</span>rand() % <span class="dv">256</span>;</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true"></a></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true"></a>    <span class="co">// !!! With this, the next loop runs faster.</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true"></a>    <span class="bu">std::</span>sort(data, data + arraySize);</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true"></a></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true"></a>    <span class="co">// Test</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true"></a>    <span class="dt">clock_t</span> start = clock();</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true"></a>    <span class="dt">long</span> <span class="dt">long</span> sum = <span class="dv">0</span>;</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true"></a></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">unsigned</span> i = <span class="dv">0</span>; i &lt; <span class="dv">100000</span>; ++i)</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true"></a>    {</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true"></a>        <span class="co">// Primary loop</span></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true"></a>        <span class="cf">for</span> (<span class="dt">unsigned</span> c = <span class="dv">0</span>; c &lt; arraySize; ++c)</span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true"></a>        {</span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true"></a>            <span class="cf">if</span> (data[c] &gt;= <span class="dv">128</span>)</span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true"></a>                sum += data[c];</span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true"></a>        }</span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true"></a>    }</span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true"></a></span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true"></a>    <span class="dt">double</span> elapsedTime = <span class="kw">static_cast</span>&lt;<span class="dt">double</span>&gt;(clock() - start) / CLOCKS_PER_SEC;</span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true"></a></span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; elapsedTime &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true"></a>}</span></code></pre></div>
<ul>
<li>
Without <code>std::sort(data, data + arraySize);</code>, the code runs in 11.54 seconds.
</li>
<li>
With the sorted data, the code runs in 1.93 seconds.
</li>
</ul>
<hr>
<p>Initially, I thought this might be just a language or compiler anomaly, so I tried Java:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="kw">import</span> java.util.Arrays;</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span class="kw">import</span> java.util.Random;</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a><span class="kw">public</span> <span class="kw">class</span> Main</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>{</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a>    <span class="kw">public</span> <span class="at">static</span> <span class="dt">void</span> main(String[] args)</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a>    {</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a>        <span class="co">// Generate data</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a>        <span class="dt">int</span> arraySize = <span class="dv">32768</span>;</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true"></a>        <span class="dt">int</span> data[] = <span class="kw">new</span> <span class="dt">int</span>[arraySize];</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true"></a></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true"></a>        Random rnd = <span class="kw">new</span> Random(<span class="dv">0</span>);</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true"></a>        <span class="cf">for</span> (<span class="dt">int</span> c = <span class="dv">0</span>; c &lt; arraySize; ++c)</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true"></a>            data[c] = rnd.nextInt() % <span class="dv">256</span>;</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true"></a></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true"></a>        <span class="co">// !!! With this, the next loop runs faster</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true"></a>        Arrays.sort(data);</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true"></a></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true"></a>        <span class="co">// Test</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true"></a>        <span class="dt">long</span> start = System.nanoTime();</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true"></a>        <span class="dt">long</span> sum = <span class="dv">0</span>;</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true"></a></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true"></a>        <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">100000</span>; ++i)</span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true"></a>        {</span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true"></a>            <span class="co">// Primary loop</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true"></a>            <span class="cf">for</span> (<span class="dt">int</span> c = <span class="dv">0</span>; c &lt; arraySize; ++c)</span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true"></a>            {</span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true"></a>                <span class="cf">if</span> (data[c] &gt;= <span class="dv">128</span>)</span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true"></a>                    sum += data[c];</span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true"></a>            }</span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true"></a>        }</span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true"></a></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true"></a>        System.out.println((System.nanoTime() - start) / <span class="fl">1000000000.0</span>);</span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true"></a>        System.out.println(<span class="st">&quot;sum = &quot;</span> + sum);</span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true"></a>    }</span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true"></a>}</span></code></pre></div>
<p>With a similar but less extreme result.</p>
<hr>
<p>My first thought was that sorting brings the data into the cache, but then I thought how silly that was because the array was just generated.</p>
<ul>
<li>
What is going on?
</li>
<li>
Why is processing a sorted array faster than processing an unsorted array?
</li>
</ul>
<p>The code is summing up some independent terms, so the order should not matter.</p>
</section>
<section id="answer-accepted-score-30765" class="level4">
<h4>Answer accepted (score 30765)</h4>
<p><strong>You are a victim of <a href="//en.wikipedia.org/wiki/Branch_predictor" rel="noreferrer">branch prediction</a> fail.</strong></p>
<hr>
<h5>
What is Branch Prediction?
</h2>
<p>Consider a railroad junction:</p>
<p>
<a href="//commons.wikimedia.org/wiki/File:Entroncamento_do_Transpraia.JPG" rel="noreferrer"><img src="https://i.stack.imgur.com/muxnt.jpg" alt="Image showing a railroad junction"></a> <sub><a href="//commons.wikimedia.org/wiki/File:Entroncamento_do_Transpraia.JPG" rel="noreferrer">Image</a> by Mecanismo, via Wikimedia Commons. Used under the <a href="//creativecommons.org/licenses/by-sa/3.0/deed.en" rel="noreferrer">CC-By-SA 3.0</a> license.</sub>
</p>
<p>Now for the sake of argument, suppose this is back in the 1800s - before long distance or radio communication.</p>
<p>You are the operator of a junction and you hear a train coming. You have no idea which way it is supposed to go. You stop the train to ask the driver which direction they want. And then you set the switch appropriately.</p>
<p><em>Trains are heavy and have a lot of inertia. So they take forever to start up and slow down.</em></p>
<p>Is there a better way? You guess which direction the train will go!</p>
<ul>
<li>
If you guessed right, it continues on.
</li>
<li>
If you guessed wrong, the captain will stop, back up, and yell at you to flip the switch. Then it can restart down the other path.
</li>
</ul>
<p>
<strong>If you guess right every time</strong>, the train will never have to stop. <br/> <strong>If you guess wrong too often</strong>, the train will spend a lot of time stopping, backing up, and restarting.
</p>
<hr>
<p><strong>Consider an if-statement:</strong> At the processor level, it is a branch instruction:</p>
<p><img src="https://i.stack.imgur.com/pyfwC.png" alt="Screenshot of compiled code containing an if statement"></p>
<p>You are a processor and you see a branch. You have no idea which way it will go. What do you do? You halt execution and wait until the previous instructions are complete. Then you continue down the correct path.</p>
<p><em>Modern processors are complicated and have long pipelines. So they take forever to “warm up” and “slow down”.</em></p>
<p>Is there a better way? You guess which direction the branch will go!</p>
<ul>
<li>
If you guessed right, you continue executing.
</li>
<li>
If you guessed wrong, you need to flush the pipeline and roll back to the branch. Then you can restart down the other path.
</li>
</ul>
<p>
<strong>If you guess right every time</strong>, the execution will never have to stop. <br/> <strong>If you guess wrong too often</strong>, you spend a lot of time stalling, rolling back, and restarting.
</p>
<hr>
<p>This is branch prediction. I admit it’s not the best analogy since the train could just signal the direction with a flag. But in computers, the processor doesn’t know which direction a branch will go until the last moment.</p>
<p>So how would you strategically guess to minimize the number of times that the train must back up and go down the other path? You look at the past history! If the train goes left 99% of the time, then you guess left. If it alternates, then you alternate your guesses. If it goes one way every three times, you guess the same…</p>
<p><strong><em>In other words, you try to identify a pattern and follow it.</em></strong> This is more or less how branch predictors work.</p>
<p>Most applications have well-behaved branches. So modern branch predictors will typically achieve &gt;90% hit rates. But when faced with unpredictable branches with no recognizable patterns, branch predictors are virtually useless.</p>
<p>Further reading: <a href="//en.wikipedia.org/wiki/Branch_predictor" rel="noreferrer">“Branch predictor” article on Wikipedia</a>.</p>
<hr>
<h5>
As hinted from above, the culprit is this if-statement:
</h2>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="cf">if</span> (data[c] &gt;= <span class="dv">128</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>    sum += data[c];</span></code></pre></div>
<p>Notice that the data is evenly distributed between 0 and 255. When the data is sorted, roughly the first half of the iterations will not enter the if-statement. After that, they will all enter the if-statement.</p>
<p>This is very friendly to the branch predictor since the branch consecutively goes the same direction many times. Even a simple saturating counter will correctly predict the branch except for the few iterations after it switches direction.</p>
<p><strong>Quick visualization:</strong></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a>T = branch taken</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>N = branch <span class="kw">not</span> taken</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a>data[] = <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, ... <span class="dv">126</span>, <span class="dv">127</span>, <span class="dv">128</span>, <span class="dv">129</span>, <span class="dv">130</span>, ... <span class="dv">250</span>, <span class="dv">251</span>, <span class="dv">252</span>, ...</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>branch = N  N  N  N  N  ...   N    N    T    T    T  ...   T    T    T  ...</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a>       = NNNNNNNNNNNN ... NNNNNNNTTTTTTTTT ... TTTTTTTTTT  (easy to predict)</span></code></pre></div>
<p>However, when the data is completely random, the branch predictor is rendered useless, because it can’t predict random data. Thus there will probably be around 50% misprediction (no better than random guessing).</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a>data[] = <span class="dv">226</span>, <span class="dv">185</span>, <span class="dv">125</span>, <span class="dv">158</span>, <span class="dv">198</span>, <span class="dv">144</span>, <span class="dv">217</span>, <span class="dv">79</span>, <span class="dv">202</span>, <span class="dv">118</span>,  <span class="dv">14</span>, <span class="dv">150</span>, <span class="dv">177</span>, <span class="dv">182</span>, <span class="dv">133</span>, ...</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>branch =   T,   T,   N,   T,   T,   T,   T,  N,   T,   N,   N,   T,   T,   T,   N  ...</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>       = TTNTTTTNTNNTTTN ...   (completely random - hard to predict)</span></code></pre></div>
<hr>
<p><strong>So what can be done?</strong></p>
<p>If the compiler isn’t able to optimize the branch into a conditional move, you can try some hacks if you are willing to sacrifice readability for performance.</p>
<p>Replace:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="cf">if</span> (data[c] &gt;= <span class="dv">128</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>    sum += data[c];</span></code></pre></div>
<p>with:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="dt">int</span> t = (data[c] - <span class="dv">128</span>) &gt;&gt; <span class="dv">31</span>;</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a>sum += ~t &amp; data[c];</span></code></pre></div>
<p>This eliminates the branch and replaces it with some bitwise operations.</p>
<p><sub>(Note that this hack is not strictly equivalent to the original if-statement. But in this case, it’s valid for all the input values of <code>data[]</code>.)</sub></p>
<p><strong>Benchmarks: Core i7 920 @ 3.5 GHz</strong></p>
<p>C++ - Visual Studio 2010 - x64 Release</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="co">//  Branch - Random</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a>seconds = <span class="fl">11.777</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true"></a><span class="co">//  Branch - Sorted</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true"></a>seconds = <span class="fl">2.352</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true"></a></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true"></a><span class="co">//  Branchless - Random</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true"></a>seconds = <span class="fl">2.564</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true"></a></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true"></a><span class="co">//  Branchless - Sorted</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true"></a>seconds = <span class="fl">2.587</span></span></code></pre></div>
<p>Java - NetBeans 7.1.1 JDK 7 - x64</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="co">//  Branch - Random</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a>seconds = <span class="fl">10.93293813</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a><span class="co">//  Branch - Sorted</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a>seconds = <span class="fl">5.643797077</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true"></a></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true"></a><span class="co">//  Branchless - Random</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true"></a>seconds = <span class="fl">3.113581453</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true"></a></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true"></a><span class="co">//  Branchless - Sorted</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true"></a>seconds = <span class="fl">3.186068823</span></span></code></pre></div>
<p>Observations:</p>
<ul>
<li>
<strong>With the Branch:</strong> There is a huge difference between the sorted and unsorted data.
</li>
<li>
<strong>With the Hack:</strong> There is no difference between sorted and unsorted data.
</li>
<li>
In the C++ case, the hack is actually a tad slower than with the branch when the data is sorted.
</li>
</ul>
<p>A general rule of thumb is to avoid data-dependent branching in critical loops (such as in this example).</p>
<hr>
<p><strong>Update:</strong></p>
<ul>
<li>
<p>
GCC 4.6.1 with <code>-O3</code> or <code>-ftree-vectorize</code> on x64 is able to generate a conditional move. So there is no difference between the sorted and unsorted data - both are fast.
</p>
</li>
<li>
<p>
VC++ 2010 is unable to generate conditional moves for this branch even under <code>/Ox</code>.
</p>
</li>
<li>
<p>
<a href="https://en.wikipedia.org/wiki/Intel_C%2B%2B_Compiler" rel="noreferrer">Intel C++ Compiler</a> (ICC) 11 does something miraculous. It <a href="https://en.wikipedia.org/wiki/Loop_interchange" rel="noreferrer">interchanges the two loops</a>, thereby hoisting the unpredictable branch to the outer loop. So not only is it immune the mispredictions, it is also twice as fast as whatever VC++ and GCC can generate! In other words, ICC took advantage of the test-loop to defeat the benchmark…
</p>
</li>
<li>
<p>
If you give the Intel compiler the branchless code, it just out-right vectorizes it… and is just as fast as with the branch (with the loop interchange).
</p>
</li>
</ul>
<p>This goes to show that even mature modern compilers can vary wildly in their ability to optimize code…</p>
</section>
<section id="answer-2-score-3958" class="level4">
<h4>Answer 2 (score 3958)</h4>
<p><strong>Branch prediction.</strong></p>
<p>With a sorted array, the condition <code>data[c] &amp;gt;= 128</code> is first <code>false</code> for a streak of values, then becomes <code>true</code> for all later values. That’s easy to predict. With an unsorted array, you pay for the branching cost.</p>
</section>
<section id="answer-3-score-3198" class="level4">
<h4>Answer 3 (score 3198)</h4>
<p>The reason why performance improves drastically when the data is sorted is that the branch prediction penalty is removed, as explained beautifully in <a href="https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array/11227902
#11227902">Mysticial’s answer</a>.</p>
<p>Now, if we look at the code</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a><span class="cf">if</span> (data[c] &gt;= <span class="dv">128</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>    sum += data[c];</span></code></pre></div>
<p>we can find that the meaning of this particular <code>if... else...</code> branch is to add something when a condition is satisfied. This type of branch can be easily transformed into a <strong>conditional move</strong> statement, which would be compiled into a conditional move instruction: <code>cmovl</code>, in an <code>x86</code> system. The branch and thus the potential branch prediction penalty is removed.</p>
<p>In <code>C</code>, thus <code>C++</code>, the statement, which would compile directly (without any optimization) into the conditional move instruction in <code>x86</code>, is the ternary operator <code>... ? ... : ...</code>. So we rewrite the above statement into an equivalent one:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a>sum += data[c] &gt;=<span class="dv">128</span> ? data[c] : <span class="dv">0</span>;</span></code></pre></div>
<p>While maintaining readability, we can check the speedup factor.</p>
<p>On an Intel <a href="http://en.wikipedia.org/wiki/Intel_Core
#Core_i7" rel="noreferrer">Core i7</a>-2600K @ 3.4 GHz and Visual Studio 2010 Release Mode, the benchmark is (format copied from Mysticial):</p>
<p><strong>x86</strong></p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a><span class="co">//  Branch - Random</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a>seconds = <span class="fl">8.885</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true"></a><span class="co">//  Branch - Sorted</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true"></a>seconds = <span class="fl">1.528</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true"></a><span class="co">//  Branchless - Random</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true"></a>seconds = <span class="fl">3.716</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true"></a></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true"></a><span class="co">//  Branchless - Sorted</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true"></a>seconds = <span class="fl">3.71</span></span></code></pre></div>
<p><strong>x64</strong></p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a><span class="co">//  Branch - Random</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a>seconds = <span class="fl">11.302</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true"></a><span class="co">//  Branch - Sorted</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true"></a> seconds = <span class="fl">1.830</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true"></a><span class="co">//  Branchless - Random</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true"></a>seconds = <span class="fl">2.736</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true"></a></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true"></a><span class="co">//  Branchless - Sorted</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true"></a>seconds = <span class="fl">2.737</span></span></code></pre></div>
<p>The result is robust in multiple tests. We get a great speedup when the branch result is unpredictable, but we suffer a little bit when it is predictable. In fact, when using a conditional move, the performance is the same regardless of the data pattern.</p>
<p>Now let’s look more closely by investigating the <code>x86</code> assembly they generate. For simplicity, we use two functions <code>max1</code> and <code>max2</code>.</p>
<p><code>max1</code> uses the conditional branch <code>if... else ...</code>:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a><span class="dt">int</span> max1(<span class="dt">int</span> a, <span class="dt">int</span> b) {</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a>    <span class="cf">if</span> (a &gt; b)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a>        <span class="cf">return</span> a;</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true"></a>    <span class="cf">else</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true"></a>        <span class="cf">return</span> b;</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>max2</code> uses the ternary operator <code>... ? ... : ...</code>:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="dt">int</span> max2(<span class="dt">int</span> a, <span class="dt">int</span> b) {</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a>    <span class="cf">return</span> a &gt; b ? a : b;</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>On a x86-64 machine, <code>GCC -S</code> generates the assembly below.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a>:max1</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a>    movl    %edi, -<span class="dv">4</span>(%rbp)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a>    movl    %esi, -<span class="dv">8</span>(%rbp)</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true"></a>    movl    -<span class="dv">4</span>(%rbp), %eax</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true"></a>    cmpl    -<span class="dv">8</span>(%rbp), %eax</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true"></a>    jle     .L2</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true"></a>    movl    -<span class="dv">4</span>(%rbp), %eax</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true"></a>    movl    %eax, -<span class="dv">12</span>(%rbp)</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true"></a>    jmp     .L4</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true"></a>.L2:</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true"></a>    movl    -<span class="dv">8</span>(%rbp), %eax</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true"></a>    movl    %eax, -<span class="dv">12</span>(%rbp)</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true"></a>.L4:</span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true"></a>    movl    -<span class="dv">12</span>(%rbp), %eax</span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true"></a>    leave</span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true"></a>    ret</span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true"></a></span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true"></a>:max2</span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true"></a>    movl    %edi, -<span class="dv">4</span>(%rbp)</span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true"></a>    movl    %esi, -<span class="dv">8</span>(%rbp)</span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true"></a>    movl    -<span class="dv">4</span>(%rbp), %eax</span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true"></a>    cmpl    %eax, -<span class="dv">8</span>(%rbp)</span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true"></a>    cmovge  -<span class="dv">8</span>(%rbp), %eax</span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true"></a>    leave</span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true"></a>    ret</span></code></pre></div>
<p><code>max2</code> uses much less code due to the usage of instruction <code>cmovge</code>. But the real gain is that <code>max2</code> does not involve branch jumps, <code>jmp</code>, which would have a significant performance penalty if the predicted result is not right.</p>
<p>So why does a conditional move perform better?</p>
<p>In a typical <code>x86</code> processor, the execution of an instruction is divided into several stages. Roughly, we have different hardware to deal with different stages. So we do not have to wait for one instruction to finish to start a new one. This is called <strong><a href="http://en.wikipedia.org/wiki/Pipeline_%28computing%29" rel="noreferrer">pipelining</a></strong>.</p>
<p>In a branch case, the following instruction is determined by the preceding one, so we cannot do pipelining. We have to either wait or predict.</p>
<p>In a conditional move case, the execution conditional move instruction is divided into several stages, but the earlier stages like <code>Fetch</code> and <code>Decode</code> does not depend on the result of the previous instruction; only latter stages need the result. Thus, we wait a fraction of one instruction’s execution time. This is why the conditional move version is slower than the branch when prediction is easy.</p>
<p>The book <em><a href="https://rads.stackoverflow.com/amzn/click/com/0136108040" rel="noreferrer" rel="nofollow noreferrer">Computer Systems: A Programmer’s Perspective, second edition</a></em> explains this in detail. You can check Section 3.6.6 for <em>Conditional Move Instructions</em>, entire Chapter 4 for <em>Processor Architecture</em>, and Section 5.11.2 for a special treatment for <em>Branch Prediction and Misprediction Penalties</em>.</p>
<p>Sometimes, some modern compilers can optimize our code to assembly with better performance, sometimes some compilers can’t (the code in question is using Visual Studio’s native compiler). Knowing the performance difference between branch and conditional move when unpredictable can help us write code with better performance when the scenario gets so complex that the compiler can not optimize them automatically.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-do-i-find-the-length-of-an-array-score-1265750-in-2011" class="level3">
<h3>6: How do I find the length of an array? (score <a href="https://stackoverflow.com/q/4108313.html">1265750</a> in 2011)</h3>
<section id="question-5" class="level4">
<h4>Question</h4>
<p>Is there a way to find how many values an array has? Detecting whether or not I’ve reached the end of an array would also work.</p>
</section>
<section id="answer-accepted-score-467" class="level4">
<h4>Answer accepted (score 467)</h4>
<p>If you mean a C-style array, then you can do something like:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a><span class="dt">int</span> a[<span class="dv">7</span>];</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a><span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Length of array = &quot;</span> &lt;&lt; (<span class="kw">sizeof</span>(a)/<span class="kw">sizeof</span>(*a)) &lt;&lt; <span class="bu">std::</span>endl;</span></code></pre></div>
<p>This doesn’t work on pointers, though, i.e. it <strong>won’t</strong> work for either of the following:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a><span class="dt">int</span> *p = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">7</span>];</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a><span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Length of array = &quot;</span> &lt;&lt; (<span class="kw">sizeof</span>(p)/<span class="kw">sizeof</span>(*p)) &lt;&lt; <span class="bu">std::</span>endl;</span></code></pre></div>
<p>or:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a><span class="dt">void</span> func(<span class="dt">int</span> *p)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true"></a>{</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Length of array = &quot;</span> &lt;&lt; (<span class="kw">sizeof</span>(p)/<span class="kw">sizeof</span>(*p)) &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true"></a>}</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true"></a></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true"></a><span class="dt">int</span> a[<span class="dv">7</span>];</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true"></a>func(a);</span></code></pre></div>
<p>In C++, if you want this kind of behaviour, then you should be using a container class; probably <a href="http://en.cppreference.com/w/cpp/container/vector"><code>std::vector</code></a>.</p>
</section>
<section id="answer-2-score-129" class="level4">
<h4>Answer 2 (score 129)</h4>
<p>As other’s said you can use the <code>sizeof(arr)/sizeof(*arr)</code> but this will give you the wrong answer for pointer types that aren’t arrays.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true"></a><span class="kw">template</span>&lt;<span class="kw">class</span> T, <span class="dt">size_t</span> N&gt;</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true"></a><span class="kw">constexpr</span> <span class="dt">size_t</span> size(T (&amp;)[N]) { <span class="cf">return</span> N; }</span></code></pre></div>
<p>This has the nice property of failing to compile for non array types (visual studio has <a href="http://msdn.microsoft.com/en-us/library/ms175773.aspx" rel="noreferrer"><code>_countof</code></a> which does this). The <a href="http://en.cppreference.com/w/cpp/language/constexpr" rel="noreferrer"><code>constexpr</code></a> makes this a compile time expression so it doesn’t have any drawbacks over the macro (at least none I know of).</p>
<p>You can also consider using <code>std::array</code> from C++11 which exposes its length with no overhead over a native C array.</p>
<p><strong>C++17</strong> has <a href="https://en.cppreference.com/w/cpp/iterator/size" rel="noreferrer"><code>std::size()</code></a> in the <code>&amp;lt;iterator&amp;gt;</code> header which does the same and works for STL containers too (thanks to <a href="https://stackoverflow.com/a/48543672/3848"><span class="citation" data-cites="Jon">@Jon</span> C</a>).</p>
</section>
<section id="answer-3-score-77" class="level4">
<h4>Answer 3 (score 77)</h4>
<p>Doing <code>sizeof( myArray )</code> will get you the total number of bytes allocated for that array. You can then find out the number of elements in the array by dividing by the size of one element in the array: <code>sizeof( myArray[0] )</code></p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-can-i-convert-a-stdstring-to-int-score-1229147-in-2018" class="level3">
<h3>7: How can I convert a std::string to int? (score <a href="https://stackoverflow.com/q/7663709.html">1229147</a> in 2018)</h3>
<section id="question-6" class="level4">
<h4>Question</h4>
<p>Just have a quick question. I’ve looked around the internet quite a bit and I’ve found a few solutions but none of them have worked yet. Looking at converting a string to an int and I don’t mean ASCII codes.</p>
<p>For a quick run-down, we are passed in an equation as a string. We are to break it down, format it correctly and solve the linear equations. Now, in saying that, I’m not able to convert a string to an int.</p>
<p>I know that the string will be in either the format (-5) or (25) etc. so it’s definitely an int. But how do we extract that from a string?</p>
<p>One way I was thinking is running a for/while loop through the string, check for a digit, extract all the digits after that and then look to see if there was a leading ‘-’, if there is, multiply the int by -1.</p>
<p>It seems a bit over complicated for such a small problem though. Any ideas?</p>
</section>
<section id="answer-accepted-score-647" class="level4">
<h4>Answer accepted (score 647)</h4>
<p>In C++11 there are some nice new convert functions from <code>std::string</code> to a number type.</p>
<p>So instead of</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true"></a>atoi( str.c_str() )</span></code></pre></div>
<p>you can use</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true"></a><span class="bu">std::</span>stoi( str )</span></code></pre></div>
<p>where <code>str</code> is your number as <code>std::string</code>.</p>
<p>
There are version for all flavours of numbers: <code>long stol(string)</code>, <code>float stof(string)</code>, <code>double stod(string)</code>,… see <a href="http://en.cppreference.com/w/cpp/string/basic_string/stol">http://en.cppreference.com/w/cpp/string/basic_string/stol</a>
</p>
</section>
<section id="answer-2-score-58" class="level4">
<h4>Answer 2 (score 58)</h4>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true"></a><span class="bu">std::</span>istringstream ss(thestring);</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true"></a>ss &gt;&gt; thevalue;</span></code></pre></div>
<p>To be fully correct you’ll want to check the error flags.</p>
</section>
<section id="answer-3-score-37" class="level4">
<h4>Answer 3 (score 37)</h4>
<p>use the atoi function to convert the string to an integer:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true"></a>string a = <span class="st">&quot;25&quot;</span>;</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true"></a><span class="dt">int</span> b = atoi(a.c_str());</span></code></pre></div>
<p><a href="http://www.cplusplus.com/reference/clibrary/cstdlib/atoi/">http://www.cplusplus.com/reference/clibrary/cstdlib/atoi/</a></p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="read-file-line-by-line-using-ifstream-in-c-score-1228489-in-2018" class="level3">
<h3>8: Read file line by line using ifstream in C++ (score <a href="https://stackoverflow.com/q/7868936.html">1228489</a> in 2018)</h3>
<section id="question-7" class="level4">
<h4>Question</h4>
<p>The contents of file.txt are:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true"></a><span class="dv">5</span> <span class="dv">3</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true"></a><span class="dv">6</span> <span class="dv">4</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true"></a><span class="dv">7</span> <span class="dv">1</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true"></a><span class="dv">10</span> <span class="dv">5</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true"></a><span class="dv">11</span> <span class="dv">6</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true"></a><span class="dv">12</span> <span class="dv">3</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true"></a><span class="dv">12</span> <span class="dv">4</span></span></code></pre></div>
<p>
Where <code>5 3</code> is a coordinate pair. How do I process this data line by line in C++?
</p>
<p>I am able to get the first line, but how do I get the next line of the file?</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true"></a>ifstream myfile;</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true"></a>myfile.open (<span class="st">&quot;text.txt&quot;</span>);</span></code></pre></div>
</section>
<section id="answer-accepted-score-856" class="level4">
<h4>Answer accepted (score 856)</h4>
<p>First, make an <code>ifstream</code>:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true"></a></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;fstream&gt;</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true"></a><span class="bu">std::</span>ifstream infile(<span class="st">&quot;thefile.txt&quot;</span>);</span></code></pre></div>
<p>The two standard methods are:</p>
<ol>
<li>
<p>
Assume that every line consists of two numbers and read token by token:
</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true"></a><span class="dt">int</span> a, b;</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true"></a><span class="cf">while</span> (infile &gt;&gt; a &gt;&gt; b)</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true"></a>{</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true"></a>    <span class="co">// process pair (a,b)</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true"></a>}</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true"></a>&lt;li&gt;&lt;p&gt;Line-based parsing, <span class="kw">using</span> string streams:&lt;/p&gt;</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true"></a></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true"></a></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sstream&gt;</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true"></a></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true"></a></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true"></a><span class="bu">std::</span>string line;</span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true"></a><span class="cf">while</span> (<span class="bu">std::</span>getline(infile, line))</span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true"></a>{</span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true"></a>    <span class="bu">std::</span>istringstream iss(line);</span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true"></a>    <span class="dt">int</span> a, b;</span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true"></a>    <span class="cf">if</span> (!(iss &gt;&gt; a &gt;&gt; b)) { <span class="cf">break</span>; } <span class="co">// error</span></span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true"></a></span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true"></a>    <span class="co">// process pair (a,b)</span></span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true"></a>}</span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true"></a>&lt;/ol&gt;</span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true"></a></span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true"></a>You shouldn<span class="ch">&#39;t</span><span class="er"> mix (1) and (2), since the token-based parsing doesn</span><span class="ch">&#39;</span>t gobble up newlines, so you may end up with spurious empty lines <span class="cf">if</span> you use <span class="er">`</span>getline()<span class="er">`</span> after token-based extraction got you to the end of a line already.  </span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true"></a></span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true"></a></span>
<span id="cb47-30"><a href="#cb47-30" aria-hidden="true"></a><span class="pp">#</span><span class="er">### Answer 2 (score 164)</span></span>
<span id="cb47-31"><a href="#cb47-31" aria-hidden="true"></a>Use <span class="er">`</span>ifstream<span class="er">`</span> to read data from a file:  </span>
<span id="cb47-32"><a href="#cb47-32" aria-hidden="true"></a></span>
<span id="cb47-33"><a href="#cb47-33" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb47-34"><a href="#cb47-34" aria-hidden="true"></a><span class="bu">std::</span>ifstream input( <span class="st">&quot;filename.ext&quot;</span> );</span></code></pre></div>
<p>If you really need to read line by line, then do this:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true"></a><span class="cf">for</span>( <span class="bu">std::</span>string line; getline( input, line ); )</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true"></a>{</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true"></a>    ...<span class="cf">for</span> each line in input...</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>But you probably just need to extract coordinate pairs:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true"></a><span class="dt">int</span> x, y;</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true"></a>input &gt;&gt; x &gt;&gt; y;</span></code></pre></div>
<p><strong>Update:</strong></p>
<p>In your code you use <code>ofstream myfile;</code>, however the <code>o</code> in <code>ofstream</code> stands for <code>output</code>. If you want to read from the file (input) use <code>ifstream</code>. If you want to both read and write use <code>fstream</code>.</p>
</section>
<section id="answer-3-score-39" class="level4">
<h4>Answer 3 (score 39)</h4>
<p>Reading a file line by line in C++ can be done in some different ways.</p>
<h5>
[Fast] Loop with std::getline()
</h2>
<p>The simplest approach is to open an std::ifstream and loop using std::getline() calls. The code is clean and easy to understand.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true"></a></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;fstream&gt;</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true"></a></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true"></a><span class="bu">std::</span>ifstream file(FILENAME);</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true"></a><span class="cf">if</span> (file.is_open()) {</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true"></a>    <span class="bu">std::</span>string line;</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true"></a>    <span class="cf">while</span> (getline(file, line)) {</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true"></a>        <span class="co">// using printf() in all tests for consistency</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true"></a>        printf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>, line.c_str());</span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true"></a>    }</span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true"></a>    file.close();</span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true"></a>}</span></code></pre></div>
<h5>
[Fast] Use Boost’s file_description_source
</h2>
<p>Another possibility is to use the Boost library, but the code gets a bit more verbose. The performance is quite similar to the code above (Loop with std::getline()).</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true"></a></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;boost/iostreams/device/file_descriptor.hpp&gt;</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true"></a></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;boost/iostreams/stream.hpp&gt;</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true"></a></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true"></a></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true"></a><span class="kw">namespace</span> io = <span class="ex">boost::</span>iostreams;</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true"></a></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true"></a><span class="dt">void</span> readLineByLineBoost() {</span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true"></a>    <span class="dt">int</span> fdr = open(FILENAME, O_RDONLY);</span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true"></a>    <span class="cf">if</span> (fdr &gt;= <span class="dv">0</span>) {</span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true"></a>        io::file_descriptor_source fdDevice(fdr, io::file_descriptor_flags::close_handle);</span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true"></a>        io::stream &lt;io::file_descriptor_source&gt; in(fdDevice);</span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true"></a>        <span class="cf">if</span> (fdDevice.is_open()) {</span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true"></a>            <span class="bu">std::</span>string line;</span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true"></a>            <span class="cf">while</span> (<span class="bu">std::</span>getline(in, line)) {</span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true"></a>                <span class="co">// using printf() in all tests for consistency</span></span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true"></a>                printf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>, line.c_str());</span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true"></a>            }</span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true"></a>            fdDevice.close();</span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true"></a>        }</span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true"></a>    }</span>
<span id="cb51-24"><a href="#cb51-24" aria-hidden="true"></a>}</span></code></pre></div>
<h5>
[Fastest] Use C code
</h2>
<p>If performance is critical for your software, you may consider using the C language. This code can be 4-5 times faster than the C++ versions above, see benchmark below</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true"></a><span class="dt">FILE</span>* fp = fopen(FILENAME, <span class="st">&quot;r&quot;</span>);</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true"></a><span class="cf">if</span> (fp == NULL)</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true"></a>    exit(EXIT_FAILURE);</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true"></a></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true"></a><span class="dt">char</span>* line = NULL;</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true"></a><span class="dt">size_t</span> len = <span class="dv">0</span>;</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true"></a><span class="cf">while</span> ((getline(&amp;line, &amp;len, fp)) != -<span class="dv">1</span>) {</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true"></a>    <span class="co">// using printf() in all tests for consistency</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true"></a>    printf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>, line);</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true"></a>}</span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true"></a>fclose(fp);</span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true"></a><span class="cf">if</span> (line)</span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true"></a>    free(line);</span></code></pre></div>
<h5>
Benchmark – Which one is faster?
</h2>
<p>I have done some performance benchmarks with the code above and the results are interesting. I have tested the code with ASCII files that contain 100,000 lines, 1,000,000 lines and 10,000,000 lines of text. Each line of text contains 10 words in average. The program is compiled with <code>-O3</code> optimization and its output is forwarded to <code>/dev/null</code> in order to remove the logging time variable from the measurement. Last, but not least, each piece of code logs each line with the <code>printf()</code> function for consistency.</p>
<p>The results show the time (in ms) that each piece of code took to read the files.</p>
<p>The performance difference between the two C++ approaches is minimal and shouldn’t make any difference in practice. The performance of the C code is what makes the benchmark impressive and can be a game changer in terms of speed.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true"></a>                             <span class="dv">10</span><span class="er">K</span> lines     <span class="dv">100</span><span class="er">K</span> lines     <span class="dv">1000</span><span class="er">K</span> lines</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true"></a>Loop with <span class="bu">std::</span>getline()         <span class="dv">105</span><span class="bu">ms</span>          <span class="dv">894</span><span class="bu">ms</span>          <span class="dv">9773</span><span class="bu">ms</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true"></a>Boost code                       <span class="dv">106</span><span class="bu">ms</span>          <span class="dv">968</span><span class="bu">ms</span>          <span class="dv">9561</span><span class="bu">ms</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true"></a>C code                            <span class="dv">23</span><span class="bu">ms</span>          <span class="dv">243</span><span class="bu">ms</span>          <span class="dv">2397</span><span class="bu">ms</span></span></code></pre></div>
<p><a href="https://i.stack.imgur.com/fKKqc.png" rel="noreferrer"><img src="https://i.stack.imgur.com/fKKqc.png" alt="enter image description here"></a></p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="what-does-the-c-standard-state-the-size-of-int-long-type-to-be-score-1194580-in-2016" class="level3">
<h3>9: What does the C++ standard state the size of int, long type to be? (score <a href="https://stackoverflow.com/q/589575.html">1194580</a> in 2016)</h3>
<section id="question-8" class="level4">
<h4>Question</h4>
<p>
I’m looking for detailed information regarding the size of basic C++ types. I know that it depends on the architecture (16 bits, 32 bits, 64 bits) and the compiler.
</p>
<p>But are there any standards for C++?</p>
<p>I’m using Visual Studio 2008 on a 32-bit architecture. Here is what I get:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true"></a><span class="dt">char</span>  : <span class="dv">1</span> byte</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true"></a><span class="dt">short</span> : <span class="dv">2</span> bytes</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true"></a><span class="dt">int</span>   : <span class="dv">4</span> bytes</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true"></a><span class="dt">long</span>  : <span class="dv">4</span> bytes</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true"></a><span class="dt">float</span> : <span class="dv">4</span> bytes</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true"></a><span class="dt">double</span>: <span class="dv">8</span> bytes</span></code></pre></div>
<p>I tried to find, without much success, reliable information stating the sizes of <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>double</code>, <code>float</code> (and other types I didn’t think of) under different architectures and compilers.</p>
</section>
<section id="answer-2-score-667" class="level4">
<h4>Answer 2 (score 667)</h4>
<p>
The C++ standard does not specify the size of integral types in bytes, but it specifies minimum ranges they must be able to hold. You can infer minimum size in bits from the required range. You can infer minimum size in bytes from that and the value of the <code>CHAR_BIT</code> macro that <a href="https://stackoverflow.com/questions/437470/type-to-use-to-represent-a-byte-in-ansi-c89-90-c/437640
#437640">defines the number of bits in a byte</a>. In all but the most obscure platforms it’s 8, and it can’t be less than 8. That’s because it must be large enough to hold “the eight-bit code units of the Unicode UTF-8 encoding form.”
</p>
<p>One additional constraint for <code>char</code> is that its size is always 1 byte, or <code>CHAR_BIT</code> bits (hence the name). This is stated explicitly in the standard.</p>
<p>The C standard is a <em>normative reference</em> for the C++ standard, so even though it doesn’t state these requirements explicitly, C++ requires the minimum ranges <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf" rel="nofollow noreferrer">required by the C standard</a> (page 22), which are the same as those from Data Type Ranges on <a href="http://msdn.microsoft.com/en-us/library/s3f49ktz.aspx" rel="nofollow noreferrer">MSDN</a>:</p>
<ol>
<li>
<code>signed char</code>: -127 to 127 (note, not -128 to 127; this accommodates 1’s-complement and sign-and-magnitude platforms)
</li>
<li>
<code>unsigned char</code>: 0 to 255
</li>
<li>
“plain” <code>char</code>: same range as <code>signed char</code> or <code>unsigned char</code>, <a href="https://stackoverflow.com/q/2397984">implementation-defined</a>
</li>
<li>
<code>signed short</code>: -32767 to 32767
</li>
<li>
<code>unsigned short</code>: 0 to 65535
</li>
<li>
<code>signed int</code>: -32767 to 32767
</li>
<li>
<code>unsigned int</code>: 0 to 65535
</li>
<li>
<code>signed long</code>: -2147483647 to 2147483647
</li>
<li>
<code>unsigned long</code>: 0 to 4294967295
</li>
<li>
<code>signed long long</code>: -9223372036854775807 to 9223372036854775807
</li>
<li>
<code>unsigned long long</code>: 0 to 18446744073709551615
</li>
</ol>
<p>A C++ (or C) implementation can define the size of a type in bytes <code>sizeof(type)</code> to any value, as long as</p>
<ol>
<li>
the expression <code>sizeof(type) * CHAR_BIT</code> evaluates to a number of bits high enough to contain required ranges, and
</li>
<li>
the ordering of type is still valid (e.g. <code>sizeof(int) &amp;lt;= sizeof(long)</code>).
</li>
</ol>
<p>Putting this all together, we are guaranteed that:</p>
<ul>
<li>
<code>char</code>, <code>signed char</code>, and <code>unsigned char</code> are at least 8 bits
</li>
<li>
<code>signed short</code>, <code>unsigned short</code>, <code>signed int</code>, and <code>unsigned int</code> are at least 16 bits
</li>
<li>
<code>signed long</code> and <code>unsigned long</code> are at least 32 bits
</li>
<li>
<code>signed long long</code> and <code>unsigned long long</code> are at least 64 bits
</li>
</ul>
<p>No guarantee is made about the size of <code>float</code> or <code>double</code> except that <code>double</code> provides at least as much precision as <code>float</code>.</p>
<p>The actual implementation-specific ranges can be found in <code>&amp;lt;limits.h&amp;gt;</code> header in C, or <code>&amp;lt;climits&amp;gt;</code> in C++ (or even better, templated <code>std::numeric_limits</code> in <code>&amp;lt;limits&amp;gt;</code> header).</p>
<p>For example, this is how you will find maximum range for <code>int</code>:</p>
<p><strong>C:</strong></p>
<div class="sourceCode" id="cb55"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true"></a></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true"></a><span class="at">const</span> <span class="dt">int</span> min_int = INT_MIN;</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true"></a><span class="at">const</span> <span class="dt">int</span> max_int = INT_MAX;</span></code></pre></div>
<p><strong>C++</strong>:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true"></a></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;limits&gt;</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true"></a><span class="at">const</span> <span class="dt">int</span> min_int = <span class="bu">std::</span>numeric_limits&lt;<span class="dt">int</span>&gt;::min();</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true"></a><span class="at">const</span> <span class="dt">int</span> max_int = <span class="bu">std::</span>numeric_limits&lt;<span class="dt">int</span>&gt;::max();</span></code></pre></div>
</section>
<section id="answer-3-score-233" class="level4">
<h4>Answer 3 (score 233)</h4>
<p>For 32-bit systems, the ‘de facto’ standard is ILP32 — that is, <code>int</code>, <code>long</code> and pointer are all 32-bit quantities.</p>
<p>For 64-bit systems, the primary Unix ‘de facto’ standard is LP64 — <code>long</code> and pointer are 64-bit (but <code>int</code> is 32-bit). The Windows 64-bit standard is LLP64 — <code>long long</code> and pointer are 64-bit (but <code>long</code> and <code>int</code> are both 32-bit).</p>
<p>At one time, some Unix systems used an ILP64 organization.</p>
<p>None of these de facto standards is legislated by the C standard (ISO/IEC 9899:1999), but all are permitted by it.</p>
<p>And, by definition, <code>sizeof(char)</code> is <code>1</code>, notwithstanding the test in the Perl configure script.</p>
<p>Note that there were machines (Crays) where <code>CHAR_BIT</code> was much larger than 8. That meant, IIRC, that <code>sizeof(int)</code> was also 1, because both <code>char</code> and <code>int</code> were 32-bit.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="best-c-ide-or-editor-for-windows-score-1193943-in-2009" class="level3">
<h3>10: Best C++ IDE or Editor for Windows (score <a href="https://stackoverflow.com/q/89275.html">1193943</a> in 2009)</h3>
<section id="question-9" class="level4">
<h4>Question</h4>
<p>What is the best C++ IDE or editor for using on Windows? I use Notepad++, but am missing IntelliSense from Visual Studio.</p>
</section>
<section id="answer-accepted-score-41" class="level4">
<h4>Answer accepted (score 41)</h4>
<p>I’ve found the latest release of NetBeans, which includes C/C++ support, to be excellent.</p>
<p><a href="http://www.netbeans.org/features/cpp/index.html" rel="nofollow noreferrer">http://www.netbeans.org/features/cpp/index.html</a></p>
</section>
<section id="answer-2-score-202" class="level4">
<h4>Answer 2 (score 202)</h4>
<p>Um, that’s because Visual Studio is the best IDE. Come back to the darkside.</p>
</section>
<section id="answer-3-score-30" class="level4">
<h4>Answer 3 (score 30)</h4>
<p>I personally like Visual Studio combined with a third party add-in such as Visual Assist (<a href="http://www.wholetomato.com/" rel="nofollow noreferrer">http://www.wholetomato.com/</a>). I’ve tried a few of the others and always ended up back with Visual Studio. Plus, Visual Studio is a widely used product in development industries, so having experience using it can only be a plus.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="sleep-for-milliseconds-score-1182180-in-2015" class="level3">
<h3>11: Sleep for milliseconds (score <a href="https://stackoverflow.com/q/4184468.html">1182180</a> in 2015)</h3>
<section id="question-10" class="level4">
<h4>Question</h4>
<p>I know the POSIX <code>sleep(x)</code> function makes the program sleep for x seconds. Is there a function to make the program sleep for x <em>milliseconds</em> in C++?</p>
</section>
<section id="answer-accepted-score-433" class="level4">
<h4>Answer accepted (score 433)</h4>
<p>Note that there is no standard C API for milliseconds, so (on Unix) you will have to settle for <code>usleep</code>, which accepts microseconds:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true"></a></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true"></a></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true"></a><span class="dt">unsigned</span> <span class="dt">int</span> microseconds;</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true"></a>...</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true"></a>usleep(microseconds);</span></code></pre></div>
</section>
<section id="answer-2-score-1138" class="level4">
<h4>Answer 2 (score 1138)</h4>
<p>In C++11, you can do this with standard library facilities:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true"></a></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;chrono&gt;</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true"></a></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;thread&gt;</span></span></code></pre></div>
<div class="sourceCode" id="cb59"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true"></a><span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="bu">std::</span>chrono<span class="bu">::</span>milliseconds(x));</span></code></pre></div>
<p>Clear and readable, no more need to guess at what units the <code>sleep()</code> function takes.</p>
</section>
<section id="answer-3-score-80" class="level4">
<h4>Answer 3 (score 80)</h4>
<p>To stay portable you could use <a href="http://www.boost.org/doc/libs/1_44_0/doc/html/thread.html" rel="noreferrer">Boost::Thread</a> for sleeping:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true"></a></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;boost/thread/thread.hpp&gt;</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true"></a></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true"></a>{</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true"></a>    <span class="co">//waits 2 seconds</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true"></a>    <span class="ex">boost::</span>this_thread<span class="ex">::</span>sleep( <span class="ex">boost::</span>posix_time<span class="ex">::</span>seconds(<span class="dv">1</span>) );</span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true"></a>    <span class="ex">boost::</span>this_thread<span class="ex">::</span>sleep( <span class="ex">boost::</span>posix_time<span class="ex">::</span>milliseconds(<span class="dv">1000</span>) );</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true"></a></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true"></a>}</span></code></pre></div>
<p><em>This answer is a duplicate and has been posted in <a href="https://stackoverflow.com/questions/4103707/need-a-better-wait-solution/4103842
#4103842">this question</a> before. Perhaps you could find some usable answers there too.</em></p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-do-you-set-clear-and-toggle-a-single-bit-score-1095506-in-2019" class="level3">
<h3>12: How do you set, clear, and toggle a single bit? (score <a href="https://stackoverflow.com/q/47981.html">1095506</a> in 2019)</h3>
<section id="question-11" class="level4">
<h4>Question</h4>
<p>How do you set, clear, and toggle a bit?</p>
</section>
<section id="answer-accepted-score-3407" class="level4">
<h4>Answer accepted (score 3407)</h4>
<h5>
Setting a bit
</h1>
<p>Use the bitwise OR operator (<code>|</code>) to set a bit.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true"></a>number |= <span class="dv">1</span><span class="bu">UL</span> &lt;&lt; n;</span></code></pre></div>
<p>That will set the <code>n</code>th bit of <code>number</code>. <code>n</code> should be zero, if you want to set the <code>1</code>st bit and so on upto <code>n-1</code>, if you want to set the <code>n</code>th bit.</p>
<p>Use <code>1ULL</code> if <code>number</code> is wider than <code>unsigned long</code>; promotion of <code>1UL &amp;lt;&amp;lt; n</code> doesn’t happen until after evaluating <code>1UL &amp;lt;&amp;lt; n</code> where it’s undefined behaviour to shift by more than the width of a <code>long</code>. The same applies to all the rest of the examples.</p>
<h5>
Clearing a bit
</h1>
<p>Use the bitwise AND operator (<code>&amp;amp;</code>) to clear a bit.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true"></a>number &amp;= ~(<span class="dv">1</span><span class="bu">UL</span> &lt;&lt; n);</span></code></pre></div>
<p>That will clear the <code>n</code>th bit of <code>number</code>. You must invert the bit string with the bitwise NOT operator (<code>~</code>), then AND it.</p>
<h5>
Toggling a bit
</h1>
<p>The XOR operator (<code>^</code>) can be used to toggle a bit.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true"></a>number ^= <span class="dv">1</span><span class="bu">UL</span> &lt;&lt; n;</span></code></pre></div>
<p>That will toggle the <code>n</code>th bit of <code>number</code>.</p>
<h5>
Checking a bit
</h1>
<p>You didn’t ask for this, but I might as well add it.</p>
<p>To check a bit, shift the number n to the right, then bitwise AND it:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true"></a>bit = (number &gt;&gt; n) &amp; <span class="dv">1</span><span class="bu">U</span>;</span></code></pre></div>
<p>That will put the value of the <code>n</code>th bit of <code>number</code> into the variable <code>bit</code>.</p>
<h5>
Changing the <em>n</em>th bit to <em>x</em>
</h1>
<p>Setting the <code>n</code>th bit to either <code>1</code> or <code>0</code> can be achieved with the following on a 2’s complement C++ implementation:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true"></a>number ^= (-x ^ number) &amp; (<span class="dv">1</span><span class="bu">UL</span> &lt;&lt; n);</span></code></pre></div>
<p>Bit <code>n</code> will be set if <code>x</code> is <code>1</code>, and cleared if <code>x</code> is <code>0</code>. If <code>x</code> has some other value, you get garbage. <code>x = !!x</code> will booleanize it to 0 or 1.</p>
<p>To make this independent of 2’s complement negation behaviour (where <code>-1</code> has all bits set, unlike on a 1’s complement or sign/magnitude C++ implementation), use unsigned negation.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true"></a>number ^= (-(<span class="dt">unsigned</span> <span class="dt">long</span>)x ^ number) &amp; (<span class="dv">1</span><span class="bu">UL</span> &lt;&lt; n);</span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true"></a><span class="dt">unsigned</span> <span class="dt">long</span> newbit = !!x;    <span class="co">// Also booleanize to force 0 or 1</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true"></a>number ^= (-newbit ^ number) &amp; (<span class="dv">1</span><span class="bu">UL</span> &lt;&lt; n);</span></code></pre></div>
<p>It’s generally a good idea to use unsigned types for portable bit manipulation.</p>
<p>or</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true"></a>number = (number &amp; ~(<span class="dv">1</span><span class="bu">UL</span> &lt;&lt; n)) | (x &lt;&lt; n);</span></code></pre></div>
<p><code>(number &amp;amp; ~(1UL &amp;lt;&amp;lt; n))</code> will clear the <code>n</code>th bit and <code>(x &amp;lt;&amp;lt; n)</code> will set the <code>n</code>th bit to <code>x</code>.</p>
<p>It’s also generally a good idea to not to copy/paste code in general and so many people use preprocessor macros (like <a href="https://stackoverflow.com/a/263738/52074">the community wiki answer further down</a>) or some sort of encapsulation.</p>
</section>
<section id="answer-2-score-438" class="level4">
<h4>Answer 2 (score 438)</h4>
<p>Using the Standard C++ Library: <a href="http://en.cppreference.com/w/cpp/utility/bitset" rel="noreferrer"><code>std::bitset&amp;lt;N&amp;gt;</code></a>.</p>
<p>Or the <a href="http://en.wikipedia.org/wiki/Boost_%28C%2B%2B_libraries%29" rel="noreferrer">Boost</a> version: <a href="http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html" rel="noreferrer"><code>boost::dynamic_bitset</code></a>.</p>
<p>There is no need to roll your own:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true"></a></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;bitset&gt;</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true"></a></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true"></a></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true"></a>{</span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true"></a>    <span class="bu">std::</span>bitset&lt;<span class="dv">5</span>&gt; x;</span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true"></a></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true"></a>    x[<span class="dv">1</span>] = <span class="dv">1</span>;</span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true"></a>    x[<span class="dv">2</span>] = <span class="dv">0</span>;</span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true"></a>    <span class="co">// Note x[0-4]  valid</span></span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true"></a></span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true"></a>}</span></code></pre></div>
<hr>
<div class="sourceCode" id="cb70"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true"></a>[Alpha:] &gt; ./a.out</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true"></a><span class="bn">00010</span></span></code></pre></div>
<p>The Boost version allows a runtime sized bitset compared with a <a href="https://en.wikipedia.org/wiki/C%2B%2B_Standard_Library" rel="noreferrer">standard library</a> compile-time sized bitset.</p>
</section>
<section id="answer-3-score-234" class="level4">
<h4>Answer 3 (score 234)</h4>
<p>The other option is to use bit fields:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true"></a><span class="kw">struct</span> bits {</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> a:<span class="dv">1</span>;</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> b:<span class="dv">1</span>;</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> c:<span class="dv">1</span>;</span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true"></a>};</span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true"></a></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true"></a><span class="kw">struct</span> bits mybits;</span></code></pre></div>
<p>defines a 3-bit field (actually, it’s three 1-bit felds). Bit operations now become a bit (haha) simpler:</p>
<p>To set or clear a bit:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true"></a>mybits.b = <span class="dv">1</span>;</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true"></a>mybits.c = <span class="dv">0</span>;</span></code></pre></div>
<p>To toggle a bit:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true"></a>mybits.a = !mybits.a;</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true"></a>mybits.b = ~mybits.b;</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true"></a>mybits.c ^= <span class="dv">1</span>;  <span class="co">/* all work */</span></span></code></pre></div>
<p>Checking a bit:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true"></a><span class="cf">if</span> (mybits.c)  <span class="co">//if mybits.c is non zero the next line below will execute</span></span></code></pre></div>
<p>This only works with fixed-size bit fields. Otherwise you have to resort to the bit-twiddling techniques described in previous posts.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-to-get-current-time-and-date-in-c-score-1051055-in-2015" class="level3">
<h3>13: How to get current time and date in C++? (score <a href="https://stackoverflow.com/q/997946.html">1051055</a> in 2015)</h3>
<section id="question-12" class="level4">
<h4>Question</h4>
<p>Is there a cross-platform way to get the current date and time in C++?</p>
</section>
<section id="answer-accepted-score-498" class="level4">
<h4>Answer accepted (score 498)</h4>
<p>In C++ 11 you can use <a href="http://en.cppreference.com/w/cpp/chrono/system_clock/now" rel="noreferrer"><code>std::chrono::system_clock::now()</code></a></p>
<p>Example (copied from <a href="https://en.cppreference.com/w/cpp/chrono" rel="noreferrer">en.cppreference.com</a>):</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true"></a></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true"></a></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;chrono&gt;</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true"></a></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;ctime&gt;</span><span class="pp">    </span></span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true"></a></span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true"></a>{</span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true"></a>    <span class="kw">auto</span> start = <span class="bu">std::</span>chrono<span class="bu">::</span>system_clock<span class="bu">::</span>now();</span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true"></a>    <span class="co">// Some computation here</span></span>
<span id="cb75-12"><a href="#cb75-12" aria-hidden="true"></a>    <span class="kw">auto</span> end = <span class="bu">std::</span>chrono<span class="bu">::</span>system_clock<span class="bu">::</span>now();</span>
<span id="cb75-13"><a href="#cb75-13" aria-hidden="true"></a></span>
<span id="cb75-14"><a href="#cb75-14" aria-hidden="true"></a>    <span class="bu">std::</span>chrono<span class="bu">::</span>duration&lt;<span class="dt">double</span>&gt; elapsed_seconds = end-start;</span>
<span id="cb75-15"><a href="#cb75-15" aria-hidden="true"></a>    <span class="bu">std::</span>time_t end_time = <span class="bu">std::</span>chrono<span class="bu">::</span>system_clock<span class="bu">::</span>to_time_t(end);</span>
<span id="cb75-16"><a href="#cb75-16" aria-hidden="true"></a></span>
<span id="cb75-17"><a href="#cb75-17" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;finished computation at &quot;</span> &lt;&lt; <span class="bu">std::</span>ctime(&amp;end_time)</span>
<span id="cb75-18"><a href="#cb75-18" aria-hidden="true"></a>              &lt;&lt; <span class="st">&quot;elapsed time: &quot;</span> &lt;&lt; elapsed_seconds.count() &lt;&lt; <span class="st">&quot;s</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb75-19"><a href="#cb75-19" aria-hidden="true"></a>}</span></code></pre></div>
<p>This should print something like this:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true"></a>finished computation at Mon Oct  <span class="dv">2</span> <span class="bn">00</span>:<span class="dv">59</span>:<span class="er">08</span> <span class="dv">2017</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true"></a>elapsed time: <span class="fl">1.88232</span><span class="bu">s</span></span></code></pre></div>
</section>
<section id="answer-2-score-463" class="level4">
<h4>Answer 2 (score 463)</h4>
<p>C++ shares its date/time functions with C. The <a href="http://en.cppreference.com/w/cpp/chrono/c/tm" rel="noreferrer">tm structure</a> is probably the easiest for a C++ programmer to work with - the following prints today’s date:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true"></a></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;ctime&gt;</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true"></a></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true"></a></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true"></a>    <span class="bu">std::</span>time_t t = <span class="bu">std::</span>time(<span class="dv">0</span>);   <span class="co">// get time now</span></span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true"></a>    <span class="bu">std::</span>tm* now = <span class="bu">std::</span>localtime(&amp;t);</span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; (now-&gt;tm_year + <span class="dv">1900</span>) &lt;&lt; <span class="ch">&#39;-&#39;</span> </span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true"></a>         &lt;&lt; (now-&gt;tm_mon + <span class="dv">1</span>) &lt;&lt; <span class="ch">&#39;-&#39;</span></span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true"></a>         &lt;&lt;  now-&gt;tm_mday</span>
<span id="cb77-12"><a href="#cb77-12" aria-hidden="true"></a>         &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb77-13"><a href="#cb77-13" aria-hidden="true"></a>}</span></code></pre></div>
</section>
<section id="answer-3-score-175" class="level4">
<h4>Answer 3 (score 175)</h4>
<p>You can try the following cross-platform code to get current date/time:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true"></a></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true"></a></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true"></a></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true"></a></span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;time.h&gt;</span></span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true"></a></span>
<span id="cb78-10"><a href="#cb78-10" aria-hidden="true"></a><span class="co">// Get current date/time, format is YYYY-MM-DD.HH:mm:ss</span></span>
<span id="cb78-11"><a href="#cb78-11" aria-hidden="true"></a><span class="at">const</span> <span class="bu">std::</span>string currentDateTime() {</span>
<span id="cb78-12"><a href="#cb78-12" aria-hidden="true"></a>    <span class="dt">time_t</span>     now = time(<span class="dv">0</span>);</span>
<span id="cb78-13"><a href="#cb78-13" aria-hidden="true"></a>    <span class="kw">struct</span> tm  tstruct;</span>
<span id="cb78-14"><a href="#cb78-14" aria-hidden="true"></a>    <span class="dt">char</span>       buf[<span class="dv">80</span>];</span>
<span id="cb78-15"><a href="#cb78-15" aria-hidden="true"></a>    tstruct = *localtime(&amp;now);</span>
<span id="cb78-16"><a href="#cb78-16" aria-hidden="true"></a>    <span class="co">// Visit http://en.cppreference.com/w/cpp/chrono/c/strftime</span></span>
<span id="cb78-17"><a href="#cb78-17" aria-hidden="true"></a>    <span class="co">// for more information about date/time format</span></span>
<span id="cb78-18"><a href="#cb78-18" aria-hidden="true"></a>    strftime(buf, <span class="kw">sizeof</span>(buf), <span class="st">&quot;%Y-%m-</span><span class="sc">%d</span><span class="st">.</span><span class="sc">%X</span><span class="st">&quot;</span>, &amp;tstruct);</span>
<span id="cb78-19"><a href="#cb78-19" aria-hidden="true"></a></span>
<span id="cb78-20"><a href="#cb78-20" aria-hidden="true"></a>    <span class="cf">return</span> buf;</span>
<span id="cb78-21"><a href="#cb78-21" aria-hidden="true"></a>}</span>
<span id="cb78-22"><a href="#cb78-22" aria-hidden="true"></a></span>
<span id="cb78-23"><a href="#cb78-23" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb78-24"><a href="#cb78-24" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;currentDateTime()=&quot;</span> &lt;&lt; currentDateTime() &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb78-25"><a href="#cb78-25" aria-hidden="true"></a>    getchar();  <span class="co">// wait for keyboard input</span></span>
<span id="cb78-26"><a href="#cb78-26" aria-hidden="true"></a>}</span></code></pre></div>
<p>Output:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true"></a>currentDateTime()=<span class="dv">2012</span>-<span class="bn">05</span>-<span class="fl">06.21</span>:<span class="dv">47</span>:<span class="dv">59</span></span></code></pre></div>
<p>Please visit <a href="http://en.cppreference.com/w/cpp/chrono/c/strftime">here</a> for more information about date/time format</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="c-ide-for-linux-score-967131-in-2017" class="level3">
<h3>14: C++ IDE for Linux? (score <a href="https://stackoverflow.com/q/24109.html">967131</a> in 2017)</h3>
<section id="question-13" class="level4">
<h4>Question</h4>
<p>I want to expand my programming horizons to Linux. A good, dependable basic toolset is important, and what is more basic than an IDE?</p>
<p>I could find these SO topics:</p>
<ul>
<li>
<a href="https://stackoverflow.com/questions/2756/lightweight-ide-for-linux">Lightweight IDE for linux</a> and
</li>
<li>
<a href="https://stackoverflow.com/questions/17228/what-tools-do-you-use-to-develop-c-applications-on-linux">What tools do you use to develop C++ applications on Linux?</a>
</li>
</ul>
<p>I’m not looking for a <em>lightweight</em> IDE. If an IDE is worth the money, then I will pay for it, so it need not be free.</p>
<p>My question, then:</p>
<blockquote>
<em>What good, C++ programming IDE is available for Linux?</em>
</blockquote>
<p>
The minimums are fairly standard: syntax highlighting, code completion (like <a href="http://en.wikipedia.org/wiki/IntelliSense" rel="nofollow noreferrer">intellisense</a> or its Eclipse counterpart) and integrated debugging (e.g., basic breakpoints).
</p>
<p>I have searched for it myself, but there are so many that it is almost impossible to separate the good from the bads by hand, especially for someone like me who has little C++ coding experience in Linux. I know that <a href="http://www.eclipse.org/cdt/" rel="nofollow noreferrer">Eclipse supports C++</a>, and I really like that IDE for Java, but is it any good for C++ and is there something better?</p>
<p>The second post actually has some good suggestions, but what I am missing is what exactly makes the sugested IDE so good for the user, what are its (dis)advantages?</p>
<p>Maybe my question should therefore be:</p>
<blockquote>
<em>What IDE do you propose (given your experiences), and why?</em>
</blockquote>
</section>
<section id="answer-accepted-score-261" class="level4">
<h4>Answer accepted (score 261)</h4>
<h5>
Initially: confusion
</h2>
<p>When originally writing this answer, I had recently made the switch from Visual Studio (with years of experience) to Linux and the first thing I did was try to find a reasonable IDE. At the time this was impossible: no good IDE existed.</p>
<h5>
Epiphany: UNIX is an IDE. <em>All of it.</em><sup>1</sup>
</h2>
<p>And then I realised that the IDE in Linux is the command line with its tools:</p>
<ul>
<li>
<p>First you set up your shell</p>
<ul>
<li>
Bash, in my case, but many people prefer
</li>
<li>
<a href="https://fishshell.com/" rel="noreferrer">fish</a> or
</li>
<li>
<a href="https://github.com/robbyrussell/oh-my-zsh" rel="noreferrer">(Oh My) Zsh</a>;
</li>
</ul>
</li>
<li>
<p>and your editor; pick your poison — both are state of the art:</p>
<ul>
<li>
<a href="https://neovim.io/" rel="noreferrer">Neovim</a><sup>2</sup> or
</li>
<li>
<a href="https://www.gnu.org/software/emacs/" rel="noreferrer">Emacs</a>.
</li>
</ul>
</li>
</ul>
<p>Depending on your needs, you will then have to install and configure several plugins to make the editor work nicely (that’s the one annoying part). For example, most programmers on Vim will benefit from the <a href="https://valloric.github.io/YouCompleteMe/" rel="noreferrer">YouCompleteMe</a> plugin for smart autocompletion.</p>
<p>Once that’s done, the shell is your command interface to interact with the various tools — Debuggers (gdb), Profilers (gprof, valgrind), etc. You set up your project/build environment using <a href="https://www.gnu.org/software/make/" rel="noreferrer">Make</a>, <a href="https://bitbucket.org/snakemake/snakemake/wiki/Home" rel="noreferrer">CMake</a>, <a href="https://bitbucket.org/snakemake/snakemake/wiki/Home" rel="noreferrer">SnakeMake</a> or any of the various alternatives. And you manage your code with a version control system (most people use <a href="https://git-scm.com/" rel="noreferrer">Git</a>). You also use <a href="https://tmux.github.io/" rel="noreferrer">tmux</a> (previously also screen) to multiplex (= think multiple windows/tabs/panels) and persist your terminal session.</p>
<p>The point is that, thanks to the shell and a few tool writing conventions, these all <em>integrate with each other</em>. And that way <strong>the Linux shell is a truly integrated development environment</strong>, completely on par with other modern IDEs. (This doesn’t mean that individual IDEs don’t have features that the command line may be lacking, but the inverse is also true.)</p>
<h5>
To each their own
</h2>
<p>I cannot overstate how well the above workflow functions once you’ve gotten into the habit. But some people simply prefer graphical editors, and in the years since this answer was originally written, Linux has gained a suite of excellent graphical IDEs for several different programming languages (but not, as far as I’m aware, for C++). Do give them a try even if — like me — you end up not using them. Here’s just a small and biased selection:</p>
<ul>
<li>
For Python development, there’s <a href="https://www.jetbrains.com/pycharm/" rel="noreferrer">PyCharm</a>
</li>
<li>
For R, there’s <a href="https://www.rstudio.com/" rel="noreferrer">RStudio</a>
</li>
<li>
For JavaScript and TypeScript, there’s <a href="https://code.visualstudio.com/" rel="noreferrer">Visual Studio Code</a> (which is also a good all-round editor)
</li>
<li>
And finally, many people love the <a href="https://www.sublimetext.com/" rel="noreferrer">Sublime Text editor</a> for general code editing.
</li>
</ul>
<p>Keep in mind that this list is far from complete.</p>
<hr>
<p><sup>1</sup> I stole that title from dsm’s comment.</p>
<p><sup>2</sup> I used to refer to Vim here. And while plain Vim is still more than capable, Neovim is a promising restart, and it’s modernised a few old warts.</p>
</section>
<section id="answer-2-score-86" class="level4">
<h4>Answer 2 (score 86)</h4>
<p>My personal favorite is the <strong>CodeLite 2.x</strong> IDE.</p>
<p>see: <a href="http://www.codelite.org/" rel="noreferrer" title="codelite website">http://www.codelite.org</a></p>
<p>The decision to use CodeLite was based on a research regarding the following C++ IDE for Linux:</p>
<ul>
<li>
Eclipse Galileo with CDT Plugin
</li>
<li>
NetBeans 6.7 (which is also the base for the SunStudio IDE)
</li>
<li>
KDevelop4
</li>
<li>
CodeBlocks 8.02
</li>
<li>
CodeLite 2.x
</li>
</ul>
<p>After all I have decided to use <em>CodeLite 2.x</em>.</p>
<p>Below I have listed some Pros and Cons regarding the mentioned C++ IDEs. Please note, that this reflects my personal opinion only!</p>
<p><strong>EDIT</strong>: what a pity that SOF doesn’t support tables, so I have to write in paragraphs …</p>
<p><strong>Eclipse Galileo with CDT Plugin</strong></p>
<p>Pros:</p>
<ul>
<li>
reasonable fast
</li>
<li>
also supports Java, Perl(with E.P.I.C plugin)
</li>
<li>
commonly used and well maintained
</li>
<li>
also available for other OS flavours (Windows, MacOS, Solaris, AIX(?))
</li>
</ul>
<p>Cons:</p>
<ul>
<li>
GUI is very confusing and somewhat inconsistent - not very intuitive at all
</li>
<li>
heavy weight
</li>
<li>
Only supports CVS (AFAIK)
</li>
</ul>
<p><strong>NetBeans 6.7</strong> (note this is also the base for the SunStudio IDE)</p>
<p>Pros:</p>
<ul>
<li>
one of the most intuitive GUI I have ever seen
</li>
<li>
also supports Java, Python, Ruby
</li>
<li>
integrates CVS, SVN, Mercurial
</li>
<li>
commonly used and well maintained
</li>
<li>
also available for other OS flavours (Windows, MacOS, Solaris)
</li>
</ul>
<p>Cons:</p>
<ul>
<li>
extremly slow
</li>
<li>
heavy weight
</li>
<li>
uses Spaces for indentation, which is not the policy at my work. I’m sure this is configurable, but I couldn’t find out how to to that
</li>
</ul>
<p><strong>KDevelop4</strong> (note: I did not much testing on it)</p>
<p>Pros:</p>
<ul>
<li>
commonly used on Linux
</li>
<li>
integrates CVS, SVN, Mercurial
</li>
</ul>
<p>Cons:</p>
<ul>
<li>
the GUI looks somewhat old fashioned
</li>
<li>
heavy weight
</li>
<li>
very specific to the KDE environment
</li>
</ul>
<p><strong>CodeBlocks 8.02</strong> (note: I did not much testing on it)</p>
<p>Pros:</p>
<ul>
<li>
reasonable fast
</li>
</ul>
<p>Cons:</p>
<ul>
<li>
the GUI looks somewhat old fashioned (although it has a nice startup screen)
</li>
<li>
the fonts in the editor are very small
</li>
<li>
some icons (e.g. the debugger related icons starting/stepping) are very small
</li>
<li>
no source control integration
</li>
</ul>
<p><strong>CodeLite 2.x</strong> (note: this is my personal favorite)</p>
<p>Pros:</p>
<ul>
<li>
the best, modern looking and intuitive GUI I have seen on Linux
</li>
<li>
lightweight
</li>
<li>
reasonable fast
</li>
<li>
integrates SVN
</li>
<li>
also available on other OS flavours(Windows, MacOS, Solaris(?))
</li>
</ul>
<p>Cons:</p>
<ul>
<li>
no CVS integration (that’s important for me because I have to use it at work)
</li>
<li>
no support for Java, Perl, Python (would be nice to have)
</li>
</ul>
</section>
<section id="answer-3-score-75" class="level4">
<h4>Answer 3 (score 75)</h4>
<ol>
<li>
<a href="http://www.codeblocks.org/" rel="noreferrer">Code::Blocks</a>
</li>
<li>
<a href="http://www.eclipse.org/cdt/" rel="noreferrer">Eclipse CDT</a>
</li>
</ol>
<p>Soon you’ll find that IDEs are not enough, and you’ll have to learn the GCC toolchain anyway (which isn’t hard, at least learning the basic functionality). But no harm in reducing the transitional pain with the IDEs, IMO.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-to-use-the-pi-constant-in-c-score-959136-in-2014" class="level3">
<h3>15: How to use the PI constant in C++ (score <a href="https://stackoverflow.com/q/1727881.html">959136</a> in 2014)</h3>
<section id="question-14" class="level4">
<h4>Question</h4>
<p>I want to use the PI constant and trigonometric functions in some C++ program. I get the trigonometric functions with <code>include &amp;lt;math.h&amp;gt;</code>. However, there doesn’t seem to be a definition for PI in this header file.</p>
<p>How can I get PI without defining it manually?</p>
</section>
<section id="answer-accepted-score-496" class="level4">
<h4>Answer accepted (score 496)</h4>
<p>On some (especially older) platforms (see the comments below) you might need to</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true"></a></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true"></a><span class="pp">#define _USE_MATH_DEFINES</span></span></code></pre></div>
<p>and then include the necessary header file:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true"></a></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;math.h&gt;</span></span></code></pre></div>
<p>and the value of pi can be accessed via:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true"></a>M_PI</span></code></pre></div>
<p>In my <code>math.h</code> (2014) it is defined as:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true"></a></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true"></a><span class="pp"># define M_PI           </span><span class="fl">3.14159265358979323846</span><span class="pp">  </span><span class="co">/* pi */</span></span></code></pre></div>
<p>but check your <code>math.h</code> for more. An extract from the “old” <code>math.h</code> (in 2009):</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true"></a><span class="co">/* Define _USE_MATH_DEFINES before including math.h to expose these macro</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true"></a><span class="co"> * definitions for common math constants.  These are placed under an</span></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true"></a><span class="co">#ifdef</span></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true"></a><span class="co"> * since these commonly-defined names are not part of the C/C++ standards.</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true"></a><span class="co"> */</span></span></code></pre></div>
<p>However:</p>
<ol>
<li>
<p>
on newer platforms (at least on my 64 bit Ubuntu 14.04) I do not need to define the <code>_USE_MATH_DEFINES</code>
</p>
</li>
<li>
<p>
On (recent) Linux platforms there are <code>long double</code> values too provided as a GNU Extension:
</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true"></a></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true"></a><span class="pp"># define M_PIl          </span><span class="fl">3.141592653589793238462643383279502884</span><span class="bu">L</span><span class="pp"> </span><span class="co">/* pi */</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true"></a>&lt;/ol&gt;</span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true"></a></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true"></a></span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true"></a><span class="pp">#</span><span class="er">### Answer 2 (score 164)</span></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true"></a>Pi can be calculated as <span class="er">`</span>atan(<span class="dv">1</span>)*<span class="dv">4</span><span class="er">`</span>. You could calculate the value <span class="kw">this</span> way <span class="kw">and</span> cache it.  </span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true"></a></span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true"></a></span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true"></a><span class="pp">#</span><span class="er">### Answer 3 (score 108)</span></span>
<span id="cb85-12"><a href="#cb85-12" aria-hidden="true"></a>You could also use boost, which defines important math constants with maximum accuracy <span class="cf">for</span> the requested type (i.e. <span class="dt">float</span> vs <span class="dt">double</span>).    </span>
<span id="cb85-13"><a href="#cb85-13" aria-hidden="true"></a></span>
<span id="cb85-14"><a href="#cb85-14" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb85-15"><a href="#cb85-15" aria-hidden="true"></a><span class="at">const</span> <span class="dt">double</span> pi = <span class="ex">boost::</span>math<span class="ex">::</span>constants<span class="ex">::</span>pi&lt;<span class="dt">double</span>&gt;();</span></code></pre></div>
<p>Check out the <a href="http://www.boost.org/doc/libs/1_37_0/libs/math/doc/sf_and_dist/html/math_toolkit/toolkit/internals1/constants.html" rel="noreferrer">boost documentation</a> for more examples.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="parse-split-a-string-in-c-using-string-delimiter-standard-c-score-952287-in-2018" class="level3">
<h3>16: Parse (split) a string in C++ using string delimiter (standard C++) (score <a href="https://stackoverflow.com/q/14265581.html">952287</a> in 2018)</h3>
<section id="question-15" class="level4">
<h4>Question</h4>
<p>I am parsing a string in C++ using the following:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true"></a>string parsed,input=<span class="st">&quot;text to be parsed&quot;</span>;</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true"></a>stringstream input_stringstream(input);</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true"></a></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true"></a><span class="cf">if</span>(getline(input_stringstream,parsed,<span class="ch">&#39; &#39;</span>))</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true"></a>{</span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true"></a>     <span class="co">// do some processing.</span></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true"></a>}</span></code></pre></div>
<p>Parsing with a single char delimiter is fine. But what if I want to use a string as delimiter.</p>
<p>Example: I want to split:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true"></a>scott&gt;=tiger</span></code></pre></div>
<p>with &gt;= as delimiter so that I can get scott and tiger.</p>
</section>
<section id="answer-accepted-score-487" class="level4">
<h4>Answer accepted (score 487)</h4>
<p>You can use the <a href="http://en.cppreference.com/w/cpp/string/basic_string/find"><code>std::string::find()</code></a> function to find the position of your string delimiter, then use <a href="http://en.cppreference.com/w/cpp/string/basic_string/substr"><code>std::string::substr()</code></a> to get a token.</p>
<p>Example:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true"></a><span class="bu">std::</span>string s = <span class="st">&quot;scott&gt;=tiger&quot;</span>;</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true"></a><span class="bu">std::</span>string delimiter = <span class="st">&quot;&gt;=&quot;</span>;</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true"></a><span class="bu">std::</span>string token = s.substr(<span class="dv">0</span>, s.find(delimiter)); <span class="co">// token is &quot;scott&quot;</span></span></code></pre></div>
<ul>
<li>
<p>
The <code>find(const string&amp;amp; str, size_t pos = 0)</code> function returns the position of the first occurrence of <code>str</code> in the string, or <a href="http://en.cppreference.com/w/cpp/string/basic_string/npos"><code>npos</code></a> if the string is not found.
</p>
</li>
<li>
<p>
The <code>substr(size_t pos = 0, size_t n = npos)</code> function returns a substring of the object, starting at position <code>pos</code> and of length <code>npos</code>.
</p>
</li>
</ul>
<hr>
<p>If you have multiple delimiters, after you have extracted one token, you can remove it (delimiter included) to proceed with subsequent extractions (if you want to preserve the original string, just use <code>s = s.substr(pos + delimiter.length());</code>):</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true"></a>s.erase(<span class="dv">0</span>, s.find(delimiter) + delimiter.length());</span></code></pre></div>
<p>This way you can easily loop to get each token.</p>
<h5>
Complete Example
</h2>
<div class="sourceCode" id="cb90"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true"></a><span class="bu">std::</span>string s = <span class="st">&quot;scott&gt;=tiger&gt;=mushroom&quot;</span>;</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true"></a><span class="bu">std::</span>string delimiter = <span class="st">&quot;&gt;=&quot;</span>;</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true"></a></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true"></a><span class="dt">size_t</span> pos = <span class="dv">0</span>;</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true"></a><span class="bu">std::</span>string token;</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true"></a><span class="cf">while</span> ((pos = s.find(delimiter)) != <span class="bu">std::</span>string<span class="bu">::</span>npos) {</span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true"></a>    token = s.substr(<span class="dv">0</span>, pos);</span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; token &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true"></a>    s.erase(<span class="dv">0</span>, pos + delimiter.length());</span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true"></a>}</span>
<span id="cb90-11"><a href="#cb90-11" aria-hidden="true"></a><span class="bu">std::</span>cout &lt;&lt; s &lt;&lt; <span class="bu">std::</span>endl;</span></code></pre></div>
<p>Output:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true"></a>scott</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true"></a>tiger</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true"></a>mushroom</span></code></pre></div>
</section>
<section id="answer-2-score-53" class="level4">
<h4>Answer 2 (score 53)</h4>
<p>This method uses <code>std::string::find</code> without mutating the original string by remembering the beginning and end of the previous substring token.</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true"></a></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true"></a></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true"></a></span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true"></a>{</span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true"></a>    <span class="bu">std::</span>string s = <span class="st">&quot;scott&gt;=tiger&quot;</span>;</span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true"></a>    <span class="bu">std::</span>string delim = <span class="st">&quot;&gt;=&quot;</span>;</span>
<span id="cb92-10"><a href="#cb92-10" aria-hidden="true"></a></span>
<span id="cb92-11"><a href="#cb92-11" aria-hidden="true"></a>    <span class="kw">auto</span> start = <span class="dv">0</span><span class="bu">U</span>;</span>
<span id="cb92-12"><a href="#cb92-12" aria-hidden="true"></a>    <span class="kw">auto</span> end = s.find(delim);</span>
<span id="cb92-13"><a href="#cb92-13" aria-hidden="true"></a>    <span class="cf">while</span> (end != <span class="bu">std::</span>string<span class="bu">::</span>npos)</span>
<span id="cb92-14"><a href="#cb92-14" aria-hidden="true"></a>    {</span>
<span id="cb92-15"><a href="#cb92-15" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; s.substr(start, end - start) &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb92-16"><a href="#cb92-16" aria-hidden="true"></a>        start = end + delim.length();</span>
<span id="cb92-17"><a href="#cb92-17" aria-hidden="true"></a>        end = s.find(delim, start);</span>
<span id="cb92-18"><a href="#cb92-18" aria-hidden="true"></a>    }</span>
<span id="cb92-19"><a href="#cb92-19" aria-hidden="true"></a></span>
<span id="cb92-20"><a href="#cb92-20" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; s.substr(start, end);</span>
<span id="cb92-21"><a href="#cb92-21" aria-hidden="true"></a>}</span></code></pre></div>
</section>
<section id="answer-3-score-31" class="level4">
<h4>Answer 3 (score 31)</h4>
<p>You can use next function to split string:</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true"></a>vector&lt;string&gt; split(<span class="at">const</span> string&amp; str, <span class="at">const</span> string&amp; delim)</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true"></a>{</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true"></a>    vector&lt;string&gt; tokens;</span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true"></a>    <span class="dt">size_t</span> prev = <span class="dv">0</span>, pos = <span class="dv">0</span>;</span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true"></a>    <span class="cf">do</span></span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true"></a>    {</span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true"></a>        pos = str.find(delim, prev);</span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true"></a>        <span class="cf">if</span> (pos == string::npos) pos = str.length();</span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true"></a>        string token = str.substr(prev, pos-prev);</span>
<span id="cb93-10"><a href="#cb93-10" aria-hidden="true"></a>        <span class="cf">if</span> (!token.empty()) tokens.push_back(token);</span>
<span id="cb93-11"><a href="#cb93-11" aria-hidden="true"></a>        prev = pos + delim.length();</span>
<span id="cb93-12"><a href="#cb93-12" aria-hidden="true"></a>    }</span>
<span id="cb93-13"><a href="#cb93-13" aria-hidden="true"></a>    <span class="cf">while</span> (pos &lt; str.length() &amp;&amp; prev &lt; str.length());</span>
<span id="cb93-14"><a href="#cb93-14" aria-hidden="true"></a>    <span class="cf">return</span> tokens;</span>
<span id="cb93-15"><a href="#cb93-15" aria-hidden="true"></a>}</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="what-is-the-difference-between-float-and-double-score-936859-in-2018" class="level3">
<h3>17: What is the difference between float and double? (score <a href="https://stackoverflow.com/q/2386772.html">936859</a> in 2018)</h3>
<section id="question-16" class="level4">
<h4>Question</h4>
<p>I’ve read about the difference between double precision and single precision. However, in most cases, <code>float</code> and <code>double</code> seem to be interchangeable, i.e. using one or the other does not seem to affect the results. Is this really the case? When are floats and doubles interchangeable? What are the differences between them?</p>
</section>
<section id="answer-accepted-score-466" class="level4">
<h4>Answer accepted (score 466)</h4>
<p>Huge difference.</p>
<p>As the name implies, a <a href="http://en.wikipedia.org/wiki/Double_precision_floating-point_format" rel="noreferrer"><code>double</code></a> has 2x the precision of <a href="http://en.wikipedia.org/wiki/Single_precision_floating-point_format" rel="noreferrer"><code>float</code></a><sup>[1]</sup>. In general a <code>double</code> has 15 decimal digits of precision, while <code>float</code> has 7.</p>
<p>Here’s how the number of digits are calculated:</p>
<blockquote>
<p><code>double</code> has 52 mantissa bits + 1 hidden bit: log(2<sup>53</sup>)÷log(10) = 15.95 digits</p>
<code>float</code> has 23 mantissa bits + 1 hidden bit: log(2<sup>24</sup>)÷log(10) = 7.22 digits
</blockquote>
<p>This precision loss could lead to greater truncation errors being accumulated when repeated calculations are done, e.g. </p>
<div class="sourceCode" id="cb94"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true"></a><span class="dt">float</span> a = <span class="fl">1.</span><span class="bu">f</span> / <span class="dv">81</span>;</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true"></a><span class="dt">float</span> b = <span class="dv">0</span>;</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true"></a><span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">729</span>; ++ i)</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true"></a>    b += a;</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true"></a>printf(<span class="st">&quot;</span><span class="sc">%.7g\n</span><span class="st">&quot;</span>, b); <span class="co">// prints 9.000023</span></span></code></pre></div>
<p>while</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true"></a><span class="dt">double</span> a = <span class="fl">1.0</span> / <span class="dv">81</span>;</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true"></a><span class="dt">double</span> b = <span class="dv">0</span>;</span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true"></a><span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">729</span>; ++ i)</span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true"></a>    b += a;</span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true"></a>printf(<span class="st">&quot;</span><span class="sc">%.15g\n</span><span class="st">&quot;</span>, b); <span class="co">// prints 8.99999999999996</span></span></code></pre></div>
<p>Also, the maximum value of float is about <code>3e38</code>, but double is about <code>1.7e308</code>, so using <code>float</code> can hit “infinity” (i.e. a special floating-point number) much more easily than <code>double</code> for something simple, e.g. computing the factorial of 60.</p>
<p>During testing, maybe a few test cases contain these huge numbers, which may cause your programs to fail if you use floats.</p>
<hr>
<p>Of course, sometimes, even <code>double</code> isn’t accurate enough, hence we sometimes have <code>long double</code><sup>[1]</sup> (the above example gives 9.000000000000000066 on Mac), but all floating point types suffer from <em>round-off errors</em>, so if precision is very important (e.g. money processing) you should use <code>int</code> or a fraction class.</p>
<hr>
<p>Furthermore, don’t use <code>+=</code> to sum lots of floating point numbers, as the errors accumulate quickly. If you’re using Python, use <code>fsum</code>. Otherwise, try to implement the <a href="http://en.wikipedia.org/wiki/Kahan_summation_algorithm" rel="noreferrer">Kahan summation algorithm</a>.</p>
<hr>
<p><sup>[1]: The C and C++ standards do not specify the representation of <code>float</code>, <code>double</code> and <code>long double</code>. It is possible that all three are implemented as IEEE double-precision. Nevertheless, for most architectures (gcc, MSVC; x86, x64, ARM) <code>float</code> <em>is</em> indeed a IEEE single-precision floating point number (binary32), and <code>double</code> <em>is</em> a IEEE double-precision floating point number (binary64).</sup></p>
</section>
<section id="answer-2-score-54" class="level4">
<h4>Answer 2 (score 54)</h4>
<p>Here is what the standard C99 (ISO-IEC 9899 6.2.5 §10) or C++2003 (ISO-IEC 14882-2003 3.1.9 §8) standards say:</p>
<blockquote>
There are three floating point types: <code>float</code>, <code>double</code>, and <code>long double</code>. The type <code>double</code> provides at least as much precision as <code>float</code>, and the type <code>long double</code> provides at least as much precision as <code>double</code>. The set of values of the type <code>float</code> is a subset of the set of values of the type <code>double</code>; the set of values of the type <code>double</code> is a subset of the set of values of the type <code>long double</code>.
</blockquote>
<p>The C++ standard adds:</p>
<blockquote>
The value representation of floating-point types is implementation-defined.
</blockquote>
<p>I would suggest having a look at the excellent <a href="http://docs.sun.com/source/806-3568/ncg_goldberg.html" rel="noreferrer">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a> that covers the IEEE floating-point standard in depth. You’ll learn about the representation details and you’ll realize there is a tradeoff between magnitude and precision. The precision of the floating point representation increases as the magnitude decreases, hence floating point numbers between -1 and 1 are those with the most precision.</p>
</section>
<section id="answer-3-score-26" class="level4">
<h4>Answer 3 (score 26)</h4>
<p>Given a quadratic equation: <em>x</em><sup>2</sup> − 4.0000000 <em>x</em> + 3.9999999 = 0, the exact roots to 10 significant digits are, <em>r</em><sub>1</sub> = 2.000316228 and <em>r</em><sub>2</sub> = 1.999683772.</p>
<p>Using <code>float</code> and <code>double</code>, we can write a test program:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true"></a></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true"></a></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;math.h&gt;</span></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true"></a></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true"></a><span class="dt">void</span> dbl_solve(<span class="dt">double</span> a, <span class="dt">double</span> b, <span class="dt">double</span> c)</span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true"></a>{</span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true"></a>    <span class="dt">double</span> d = b*b - <span class="fl">4.0</span>*a*c;</span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true"></a>    <span class="dt">double</span> sd = sqrt(d);</span>
<span id="cb96-10"><a href="#cb96-10" aria-hidden="true"></a>    <span class="dt">double</span> r1 = (-b + sd) / (<span class="fl">2.0</span>*a);</span>
<span id="cb96-11"><a href="#cb96-11" aria-hidden="true"></a>    <span class="dt">double</span> r2 = (-b - sd) / (<span class="fl">2.0</span>*a);</span>
<span id="cb96-12"><a href="#cb96-12" aria-hidden="true"></a>    printf(<span class="st">&quot;</span><span class="sc">%.5f\t%.5f\n</span><span class="st">&quot;</span>, r1, r2);</span>
<span id="cb96-13"><a href="#cb96-13" aria-hidden="true"></a>}</span>
<span id="cb96-14"><a href="#cb96-14" aria-hidden="true"></a></span>
<span id="cb96-15"><a href="#cb96-15" aria-hidden="true"></a><span class="dt">void</span> flt_solve(<span class="dt">float</span> a, <span class="dt">float</span> b, <span class="dt">float</span> c)</span>
<span id="cb96-16"><a href="#cb96-16" aria-hidden="true"></a>{</span>
<span id="cb96-17"><a href="#cb96-17" aria-hidden="true"></a>    <span class="dt">float</span> d = b*b - <span class="fl">4.0</span><span class="bu">f</span>*a*c;</span>
<span id="cb96-18"><a href="#cb96-18" aria-hidden="true"></a>    <span class="dt">float</span> sd = sqrtf(d);</span>
<span id="cb96-19"><a href="#cb96-19" aria-hidden="true"></a>    <span class="dt">float</span> r1 = (-b + sd) / (<span class="fl">2.0</span><span class="bu">f</span>*a);</span>
<span id="cb96-20"><a href="#cb96-20" aria-hidden="true"></a>    <span class="dt">float</span> r2 = (-b - sd) / (<span class="fl">2.0</span><span class="bu">f</span>*a);</span>
<span id="cb96-21"><a href="#cb96-21" aria-hidden="true"></a>    printf(<span class="st">&quot;</span><span class="sc">%.5f\t%.5f\n</span><span class="st">&quot;</span>, r1, r2);</span>
<span id="cb96-22"><a href="#cb96-22" aria-hidden="true"></a>}   </span>
<span id="cb96-23"><a href="#cb96-23" aria-hidden="true"></a></span>
<span id="cb96-24"><a href="#cb96-24" aria-hidden="true"></a><span class="dt">int</span> main(<span class="dt">void</span>)</span>
<span id="cb96-25"><a href="#cb96-25" aria-hidden="true"></a>{</span>
<span id="cb96-26"><a href="#cb96-26" aria-hidden="true"></a>    <span class="dt">float</span> fa = <span class="fl">1.0</span><span class="bu">f</span>;</span>
<span id="cb96-27"><a href="#cb96-27" aria-hidden="true"></a>    <span class="dt">float</span> fb = -<span class="fl">4.0000000</span><span class="bu">f</span>;</span>
<span id="cb96-28"><a href="#cb96-28" aria-hidden="true"></a>    <span class="dt">float</span> fc = <span class="fl">3.9999999</span><span class="bu">f</span>;</span>
<span id="cb96-29"><a href="#cb96-29" aria-hidden="true"></a>    <span class="dt">double</span> da = <span class="fl">1.0</span>;</span>
<span id="cb96-30"><a href="#cb96-30" aria-hidden="true"></a>    <span class="dt">double</span> db = -<span class="fl">4.0000000</span>;</span>
<span id="cb96-31"><a href="#cb96-31" aria-hidden="true"></a>    <span class="dt">double</span> dc = <span class="fl">3.9999999</span>;</span>
<span id="cb96-32"><a href="#cb96-32" aria-hidden="true"></a>    flt_solve(fa, fb, fc);</span>
<span id="cb96-33"><a href="#cb96-33" aria-hidden="true"></a>    dbl_solve(da, db, dc);</span>
<span id="cb96-34"><a href="#cb96-34" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb96-35"><a href="#cb96-35" aria-hidden="true"></a>}  </span></code></pre></div>
<p>Running the program gives me:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true"></a><span class="fl">2.00000</span> <span class="fl">2.00000</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true"></a><span class="fl">2.00032</span> <span class="fl">1.99968</span></span></code></pre></div>
<p>Note that the numbers aren’t large, but still you get cancellation effects using <code>float</code>.</p>
<p>(In fact, the above is not the best way of solving quadratic equations using either single- or double-precision floating-point numbers, but the answer remains unchanged even if one uses a <a href="http://en.wikipedia.org/wiki/Quadratic_equation
#Floating_point_implementation" rel="noreferrer">more stable method</a>.)</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in-c-score-933961-in-2018" class="level3">
<h3>18: What are the differences between a pointer variable and a reference variable in C++? (score <a href="https://stackoverflow.com/q/57483.html">933961</a> in 2018)</h3>
<section id="question-17" class="level4">
<h4>Question</h4>
<p>I know references are syntactic sugar, so code is easier to read and write.</p>
<p>But what are the differences?</p>
<hr>
<p>Summary from answers and links below:</p>
<ol>
<li>
A pointer can be re-assigned any number of times while a reference cannot be re-assigned after binding.
</li>
<li>
Pointers can point nowhere (<code>NULL</code>), whereas a reference always refers to an object.
</li>
<li>
You can’t take the address of a reference like you can with pointers.
</li>
<li>
There’s no “reference arithmetic” (but you can take the address of an object pointed by a reference and do pointer arithmetic on it as in <code>&amp;amp;obj + 5</code>).
</li>
</ol>
<p>To clarify a misconception:</p>
<blockquote>
<p>
<em>The C++ standard is very careful to avoid dictating how a compiler may implement references, but every C++ compiler implements references as pointers. That is, a declaration such as:</em>
</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true"></a><span class="dt">int</span> &amp;ri = i;</span></code></pre></div>
<p>
<strong><em>if it’s not optimized away entirely</em></strong>, <em>allocates the same amount of storage as a pointer, and places the address of <code>i</code> into that storage.</em>
</p>
</blockquote>
<p><strong><em>So, a pointer and a reference both use the same amount of memory.</em></strong></p>
<p>As a general rule,</p>
<ul>
<li>
Use references in function parameters and return types to provide useful and self-documenting interfaces.
</li>
<li>
Use pointers for implementing algorithms and data structures.
</li>
</ul>
<p>Interesting read:</p>
<ul>
<li>
My all-time favorite <a href="http://yosefk.com/c++fqa/ref.html" rel="noreferrer">C++ FAQ lite</a>.
</li>
<li>
<a href="http://www.embedded.com/electronics-blogs/programming-pointers/4023307/References-vs-Pointers" rel="noreferrer">References vs. Pointers</a>.
</li>
<li>
<a href="http://www.embedded.com/electronics-blogs/programming-pointers/4024641/An-Introduction-to-References" rel="noreferrer">An Introduction to References</a>.
</li>
<li>
<a href="http://www.embedded.com/electronics-blogs/programming-pointers/4023290/References-and-const" rel="noreferrer">References and const</a>.
</li>
</ul>
</section>
<section id="answer-2-score-1599" class="level4">
<h4>Answer 2 (score 1599)</h4>
<ol>
<li>
<p>
A pointer can be re-assigned:
</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true"></a><span class="dt">int</span> x = <span class="dv">5</span>;</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true"></a><span class="dt">int</span> y = <span class="dv">6</span>;</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true"></a><span class="dt">int</span> *p;</span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true"></a>p = &amp;x;</span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true"></a>p = &amp;y;</span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true"></a>*p = <span class="dv">10</span>;</span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true"></a><span class="ot">assert</span>(x == <span class="dv">5</span>);</span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true"></a><span class="ot">assert</span>(y == <span class="dv">10</span>);</span></code></pre></div>
<p>A reference cannot, and must be assigned at initialization:</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true"></a><span class="dt">int</span> x = <span class="dv">5</span>;</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true"></a><span class="dt">int</span> y = <span class="dv">6</span>;</span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true"></a><span class="dt">int</span> &amp;r = x;</span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true"></a>&lt;li&gt;&lt;p&gt;A pointer has its own memory address <span class="kw">and</span> size on the stack (<span class="dv">4</span> bytes on x86), whereas a reference shares the same memory address (with the original variable) but also takes up some space on the stack.  Since a reference has the same address as the original variable itself, it is safe to think of a reference as another name <span class="cf">for</span> the same variable.  Note: What a pointer points to can be on the stack <span class="kw">or</span> heap.  Ditto a reference. My claim in <span class="kw">this</span> statement is <span class="kw">not</span> that a pointer must point to the stack.  A pointer is just a variable that holds a memory address.  This variable is on the stack.  Since a reference has its own space on the stack, <span class="kw">and</span> since the address is the same as the variable it references.  More on &lt;a href=<span class="st">&quot;https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap</span></span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true"></a><span class="pp">#79936&quot;&gt;stack vs heap&lt;/a&gt;.  This implies that there is a real address of a reference that the compiler will not tell you. &lt;/p&gt;</span></span>
<span id="cb100-7"><a href="#cb100-7" aria-hidden="true"></a></span>
<span id="cb100-8"><a href="#cb100-8" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb100-9"><a href="#cb100-9" aria-hidden="true"></a><span class="dt">int</span> x = <span class="dv">0</span>;</span>
<span id="cb100-10"><a href="#cb100-10" aria-hidden="true"></a><span class="dt">int</span> &amp;r = x;</span>
<span id="cb100-11"><a href="#cb100-11" aria-hidden="true"></a><span class="dt">int</span> *p = &amp;x;</span>
<span id="cb100-12"><a href="#cb100-12" aria-hidden="true"></a><span class="dt">int</span> *p2 = &amp;r;</span>
<span id="cb100-13"><a href="#cb100-13" aria-hidden="true"></a><span class="ot">assert</span>(p == p2);</span>
<span id="cb100-14"><a href="#cb100-14" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb100-15"><a href="#cb100-15" aria-hidden="true"></a>&lt;li&gt;&lt;p&gt;You can have pointers to pointers to pointers offering extra levels of indirection.  Whereas references only offer one level of indirection. &lt;/p&gt;</span>
<span id="cb100-16"><a href="#cb100-16" aria-hidden="true"></a></span>
<span id="cb100-17"><a href="#cb100-17" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb100-18"><a href="#cb100-18" aria-hidden="true"></a><span class="dt">int</span> x = <span class="dv">0</span>;</span>
<span id="cb100-19"><a href="#cb100-19" aria-hidden="true"></a><span class="dt">int</span> y = <span class="dv">0</span>;</span>
<span id="cb100-20"><a href="#cb100-20" aria-hidden="true"></a><span class="dt">int</span> *p = &amp;x;</span>
<span id="cb100-21"><a href="#cb100-21" aria-hidden="true"></a><span class="dt">int</span> *q = &amp;y;</span>
<span id="cb100-22"><a href="#cb100-22" aria-hidden="true"></a><span class="dt">int</span> **pp = &amp;p;</span>
<span id="cb100-23"><a href="#cb100-23" aria-hidden="true"></a>pp = &amp;q;<span class="co">//*pp = q</span></span>
<span id="cb100-24"><a href="#cb100-24" aria-hidden="true"></a>**pp = <span class="dv">4</span>;</span>
<span id="cb100-25"><a href="#cb100-25" aria-hidden="true"></a><span class="ot">assert</span>(y == <span class="dv">4</span>);</span>
<span id="cb100-26"><a href="#cb100-26" aria-hidden="true"></a><span class="ot">assert</span>(x == <span class="dv">0</span>);</span>
<span id="cb100-27"><a href="#cb100-27" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb100-28"><a href="#cb100-28" aria-hidden="true"></a>&lt;li&gt;&lt;p&gt;Pointer can be assigned <span class="er">`</span>nullptr<span class="er">`</span> directly, whereas reference cannot. If you <span class="cf">try</span> hard enough, <span class="kw">and</span> you know how, you can make the address of a reference <span class="er">`</span>nullptr<span class="er">`</span>.  Likewise, <span class="cf">if</span> you <span class="cf">try</span> hard enough you can have a reference to a pointer, <span class="kw">and</span> then that reference can contain <span class="er">`</span>nullptr<span class="er">`</span>.&lt;/p&gt;</span>
<span id="cb100-29"><a href="#cb100-29" aria-hidden="true"></a></span>
<span id="cb100-30"><a href="#cb100-30" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb100-31"><a href="#cb100-31" aria-hidden="true"></a><span class="dt">int</span> *p = <span class="kw">nullptr</span>;</span>
<span id="cb100-32"><a href="#cb100-32" aria-hidden="true"></a><span class="dt">int</span> &amp;r = <span class="kw">nullptr</span>; &lt;--- compiling error</span>
<span id="cb100-33"><a href="#cb100-33" aria-hidden="true"></a><span class="dt">int</span> &amp;r = *p;  &lt;--- likely no compiling error, especially <span class="cf">if</span> the <span class="kw">nullptr</span> is hidden behind a function call, yet it refers to a non-existent <span class="dt">int</span> at address <span class="dv">0</span></span>
<span id="cb100-34"><a href="#cb100-34" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb100-35"><a href="#cb100-35" aria-hidden="true"></a>&lt;li&gt;&lt;p&gt;Pointers can iterate over an array, you can use <span class="er">`</span>++<span class="er">`</span> to go to the next item that a pointer is pointing to, <span class="kw">and</span> <span class="er">`</span>+ <span class="dv">4</span><span class="er">`</span> to go to the <span class="dv">5</span><span class="er">th</span> element.  This is no matter what size the object is that the pointer points to.&lt;/p&gt;&lt;/li&gt;</span>
<span id="cb100-36"><a href="#cb100-36" aria-hidden="true"></a>&lt;li&gt;&lt;p&gt;A pointer needs to be dereferenced with <span class="er">`</span>*<span class="er">`</span> to access the memory location it points to, whereas a reference can be used directly.  A pointer to a <span class="kw">class</span>/<span class="kw">struct</span> uses <span class="er">`</span>-&amp;gt;<span class="er">`</span> to access it<span class="ch">&#39;s</span><span class="er"> members whereas a reference uses a `.`.&lt;/p&gt;&lt;/li&gt;</span></span>
<span id="cb100-37"><a href="#cb100-37" aria-hidden="true"></a>&lt;li&gt;&lt;p&gt;A pointer is a variable that holds a memory address.  Regardless of how a reference is implemented, a reference has the same memory address as the item it references.&lt;/p&gt;&lt;/li&gt;</span>
<span id="cb100-38"><a href="#cb100-38" aria-hidden="true"></a>&lt;li&gt;&lt;p&gt;References cannot be stuffed into an array, whereas pointers can be (Mentioned by user <span class="er">@</span>litb)&lt;/p&gt;&lt;/li&gt;</span>
<span id="cb100-39"><a href="#cb100-39" aria-hidden="true"></a>&lt;li&gt;&lt;p&gt;Const references can be bound to temporaries. Pointers cannot (<span class="kw">not</span> without some indirection):&lt;/p&gt;</span>
<span id="cb100-40"><a href="#cb100-40" aria-hidden="true"></a></span>
<span id="cb100-41"><a href="#cb100-41" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb100-42"><a href="#cb100-42" aria-hidden="true"></a><span class="at">const</span> <span class="dt">int</span> &amp;x = <span class="dt">int</span>(<span class="dv">12</span>); <span class="co">//legal C++</span></span>
<span id="cb100-43"><a href="#cb100-43" aria-hidden="true"></a><span class="dt">int</span> *y = &amp;<span class="dt">int</span>(<span class="dv">12</span>); <span class="co">//illegal to dereference a temporary.</span></span></code></pre></div>
This makes <code>const&amp;amp;</code> safer for use in argument lists and so forth.
</li>
</ol>
</section>
<section id="answer-3-score-357" class="level4">
<h4>Answer 3 (score 357)</h4>
<h5>
What’s a C++ reference (<em>for C programmers</em>)
</h1>
<p>A <em>reference</em> can be thought of as a <em>constant pointer</em> (not to be confused with a pointer to a constant value!) with automatic indirection, ie the compiler will apply the <code>*</code> operator for you.</p>
<p>All references must be initialized with a non-null value or compilation will fail. It’s neither possible to get the address of a reference - the address operator will return the address of the referenced value instead - nor is it possible to do arithmetics on references.</p>
<p>C programmers might dislike C++ references as it will no longer be obvious when indirection happens or if an argument gets passed by value or by pointer without looking at function signatures.</p>
<p>C++ programmers might dislike using pointers as they are considered unsafe - although references aren’t really any safer than constant pointers except in the most trivial cases - lack the convenience of automatic indirection and carry a different semantic connotation.</p>
<p>Consider the following statement from the <a href="https://isocpp.org/wiki/faq/references
#overview-refs" rel="noreferrer"><em>C++ FAQ</em></a>:</p>
<blockquote>
<p>
Even though a reference is often implemented using an address in the underlying assembly language, please do <em>not</em> think of a reference as a funny looking pointer to an object. A reference <em>is</em> the object. It is not a pointer to the object, nor a copy of the object. It <em>is</em> the object.
</p>
</blockquote>
<p>But if a reference <em>really</em> were the object, how could there be dangling references? In unmanaged languages, it’s impossible for references to be any ‘safer’ than pointers - there generally just isn’t a way to reliably alias values across scope boundaries!</p>
<h5>
Why I consider C++ references useful
</h1>
<p>Coming from a C background, C++ references may look like a somewhat silly concept, but one should still use them instead of pointers where possible: Automatic indirection <em>is</em> convenient, and references become especially useful when dealing with <a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization" rel="noreferrer">RAII</a> - but not because of any perceived safety advantage, but rather because they make writing idiomatic code less awkward.</p>
<p>RAII is one of the central concepts of C++, but it interacts non-trivially with copying semantics. Passing objects by reference avoids these issues as no copying is involved. If references were not present in the language, you’d have to use pointers instead, which are more cumbersome to use, thus violating the language design principle that the best-practice solution should be easier than the alternatives.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-to-convert-a-stdstring-to-const-char-or-char-score-881988-in-2014" class="level3">
<h3>19: How to convert a std::string to const char* or char*? (score <a href="https://stackoverflow.com/q/347949.html">881988</a> in 2014)</h3>
<section id="question-18" class="level4">
<h4>Question</h4>
<p>How can I convert an <code>std::string</code> to a <code>char*</code> or a <code>const char*</code>?</p>
</section>
<section id="answer-accepted-score-1014" class="level4">
<h4>Answer accepted (score 1014)</h4>
<p>If you just want to pass a <a href="http://en.cppreference.com/w/cpp/string/basic_string" rel="noreferrer"><code>std::string</code></a> to a function that needs <code>const char*</code> you can use</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true"></a><span class="bu">std::</span>string str;</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true"></a><span class="at">const</span> <span class="dt">char</span> * c = str.c_str();</span></code></pre></div>
<p>If you want to get a writable copy, like <code>char *</code>, you can do that with this:</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true"></a><span class="bu">std::</span>string str;</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true"></a><span class="dt">char</span> * writable = <span class="kw">new</span> <span class="dt">char</span>[str.size() + <span class="dv">1</span>];</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true"></a><span class="bu">std::</span>copy(str.begin(), str.end(), writable);</span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true"></a>writable[str.size()] = <span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span>; <span class="co">// don&#39;t forget the terminating 0</span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true"></a></span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true"></a><span class="co">// don&#39;t forget to free the string after finished using it</span></span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true"></a><span class="kw">delete</span>[] writable;</span></code></pre></div>
<p><strong>Edit</strong>: Notice that the above is not exception safe. If anything between the <code>new</code> call and the <code>delete</code> call throws, you will leak memory, as nothing will call <code>delete</code> for you automatically. There are two immediate ways to solve this.</p>
<h5>
boost::scoped_array
</h3>
<p><a href="http://www.boost.org/doc/libs/release/libs/smart_ptr/scoped_array.htm" rel="noreferrer"><code>boost::scoped_array</code></a> will delete the memory for you upon going out of scope:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true"></a><span class="bu">std::</span>string str;</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true"></a><span class="ex">boost::</span>scoped_array&lt;<span class="dt">char</span>&gt; writable(<span class="kw">new</span> <span class="dt">char</span>[str.size() + <span class="dv">1</span>]);</span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true"></a><span class="bu">std::</span>copy(str.begin(), str.end(), writable.get());</span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true"></a>writable[str.size()] = <span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span>; <span class="co">// don&#39;t forget the terminating 0</span></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true"></a></span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true"></a><span class="co">// get the char* using writable.get()</span></span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true"></a></span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true"></a><span class="co">// memory is automatically freed if the smart pointer goes </span></span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true"></a><span class="co">// out of scope</span></span></code></pre></div>
<h5>
std::vector
</h3>
<p>This is the standard way (does not require any external library). You use <a href="http://en.cppreference.com/w/cpp/container/vector" rel="noreferrer"><code>std::vector</code></a>, which completely manages the memory for you.</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true"></a><span class="bu">std::</span>string str;</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="dt">char</span>&gt; writable(str.begin(), str.end());</span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true"></a>writable.push_back(<span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span>);</span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true"></a></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true"></a><span class="co">// get the char* using &amp;writable[0] or &amp;*writable.begin()</span></span></code></pre></div>
</section>
<section id="answer-2-score-186" class="level4">
<h4>Answer 2 (score 186)</h4>
<p>Given say…</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true"></a><span class="bu">std::</span>string x = <span class="st">&quot;hello&quot;</span>;</span></code></pre></div>
<h5>
Getting a <code>char *</code> or <code>const char*</code> from a <code>string</code>
</h2>
<p><strong>How to get a character pointer that’s valid while <code>x</code> remains in scope and isn’t modified further</strong></p>
<p><strong>C++11</strong> simplifies things; the following all give access to the same internal string buffer:</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true"></a><span class="at">const</span> <span class="dt">char</span>* p_c_str = x.c_str();</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true"></a><span class="at">const</span> <span class="dt">char</span>* p_data  = x.data();</span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true"></a><span class="dt">char</span>* p_writable_data = x.data(); <span class="co">// for non-const x from C++17 </span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true"></a><span class="at">const</span> <span class="dt">char</span>* p_x0    = &amp;x[<span class="dv">0</span>];</span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true"></a></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true"></a>      <span class="dt">char</span>* p_x0_rw = &amp;x[<span class="dv">0</span>];  <span class="co">// compiles iff x is not const...</span></span></code></pre></div>
<p>All the above pointers will hold the <em>same value</em> - the address of the first character in the buffer. Even an empty string has a “first character in the buffer”, because C++11 guarantees to always keep an extra NUL/0 terminator character after the explicitly assigned string content (e.g. <code>std::string("this\0that", 9)</code> will have a buffer holding <code>"this\0that\0"</code>).</p>
<p>Given any of the above pointers:</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true"></a><span class="dt">char</span> c = p[n];   <span class="co">// valid for n &lt;= x.size()</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true"></a>                 <span class="co">// i.e. you can safely read the NUL at p[x.size()]</span></span></code></pre></div>
<p>Only for the non-<code>const</code> pointer <code>p_writable_data</code> and from <code>&amp;amp;x[0]</code>:</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true"></a>p_writable_data[n] = c;</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true"></a>p_x0_rw[n] = c;  <span class="co">// valid for n &lt;= x.size() - 1</span></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true"></a>                 <span class="co">// i.e. don&#39;t overwrite the implementation maintained NUL</span></span></code></pre></div>
<p>Writing a NUL elsewhere in the string does <em>not</em> change the <code>string</code>’s <code>size()</code>; <code>string</code>’s are allowed to contain any number of NULs - they are given no special treatment by <code>std::string</code> (same in C++03).</p>
<p>In <strong>C++03</strong>, things were considerably more complicated (key differences <strong><em>highlighted</em></strong>):</p>
<ul>
<li>
<p>
<code>x.data()</code>
</p>
<ul>
<li>
<p>returns <code>const char*</code> to the string’s internal buffer <strong><em>which wasn’t required by the Standard to conclude with a NUL</em></strong> (i.e. might be <code>['h', 'e', 'l', 'l', 'o']</code> followed by uninitialised or garbage values, with accidental accesses thereto having <em>undefined behaviour</em>).</p>
<ul>
<li>
<code>x.size()</code> characters are safe to read, i.e. <code>x[0]</code> through <code>x[x.size() - 1]</code>
</li>
<li>
for empty strings, you’re guaranteed some non-NULL pointer to which 0 can be safely added (hurray!), but you shouldn’t dereference that pointer.
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>
<code>&amp;amp;x[0]</code>
</p>
<ul>
<li>
<p><strong><em>for empty strings this has undefined behaviour</em></strong> (21.3.4)</p>
<ul>
<li>
e.g. given <code>f(const char* p, size_t n) { if (n == 0) return; ...whatever... }</code> you mustn’t call <code>f(&amp;amp;x[0], x.size());</code> when <code>x.empty()</code> - just use <code>f(x.data(), ...)</code>.
</li>
</ul>
</li>
<li>
<p>otherwise, as per <code>x.data()</code> but:</p>
<ul>
<li>
for non-<code>const</code> <code>x</code> this yields a non-<code>const</code> <code>char*</code> pointer; you can overwrite string content
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>
<code>x.c_str()</code>
</p>
<ul>
<li>
returns <code>const char*</code> to an ASCIIZ (NUL-terminated) representation of the value (i.e. [‘h’, ‘e’, ‘l’, ‘l’, ‘o’, ‘\0’]).
</li>
<li>
although few if any implementations chose to do so, the C++03 Standard was worded to allow the string implementation the freedom to create a <strong><em>distinct NUL-terminated buffer</em></strong> <em>on the fly</em>, from the potentially non-NUL terminated buffer “exposed” by <code>x.data()</code> and <code>&amp;amp;x[0]</code>
</li>
<li>
<code>x.size()</code> + 1 characters are safe to read.
</li>
<li>
guaranteed safe even for empty strings ([‘\0’]).
</li>
</ul>
</li>
</ul>
<h5>
Consequences of accessing outside legal indices
</h2>
<p>Whichever way you get a pointer, you must not access memory further along from the pointer than the characters guaranteed present in the descriptions above. Attempts to do so have <em>undefined behaviour</em>, with a very real chance of application crashes and garbage results even for reads, and additionally wholesale data, stack corruption and/or security vulnerabilities for writes.</p>
<h5>
When do those pointers get invalidated?
</h2>
<p>If you call some <code>string</code> member function that modifies the <code>string</code> or reserves further capacity, any pointer values returned beforehand by any of the above methods are <em>invalidated</em>. You can use those methods again to get another pointer. (The rules are the same as for iterators into <code>string</code>s).</p>
<p>See also <em>How to get a character pointer valid even after <code>x</code> leaves scope or is modified further</em> below….</p>
<h5>
So, which is <em>better</em> to use?
</h2>
<p>From C++11, use <code>.c_str()</code> for ASCIIZ data, and <code>.data()</code> for “binary” data (explained further below).</p>
<p>In C++03, use <code>.c_str()</code> unless certain that <code>.data()</code> is adequate, and prefer <code>.data()</code> over <code>&amp;amp;x[0]</code> as it’s safe for empty strings….</p>
<p><em>…try to understand the program enough to use <code>data()</code> when appropriate, or you’ll probably make other mistakes…</em></p>
<p>The ASCII NUL ‘\0’ character guaranteed by <code>.c_str()</code> is used by many functions as a sentinel value denoting the end of relevant and safe-to-access data. This applies to both C++-only functions like say <code>fstream::fstream(const char* filename, ...)</code> and shared-with-C functions like <code>strchr()</code>, and <code>printf()</code>.</p>
<p>Given C++03’s <code>.c_str()</code>’s guarantees about the returned buffer are a super-set of <code>.data()</code>’s, you can always safely use <code>.c_str()</code>, but people sometimes don’t because:</p>
<ul>
<li>
using <code>.data()</code> communicates to other programmers reading the source code that the data is not ASCIIZ (rather, you’re using the string to store a block of data (which sometimes isn’t even really textual)), or that you’re passing it to another function that treats it as a block of “binary” data. This can be a crucial insight in ensuring that other programmers’ code changes continue to handle the data properly.
</li>
<li>
C++03 only: there’s a slight chance that your <code>string</code> implementation will need to do some extra memory allocation and/or data copying in order to prepare the NUL terminated buffer
</li>
</ul>
<p>As a further hint, if a function’s parameters require the (<code>const</code>) <code>char*</code> but don’t insist on getting <code>x.size()</code>, the function <em>probably</em> needs an ASCIIZ input, so <code>.c_str()</code> is a good choice (the function needs to know where the text terminates somehow, so if it’s not a separate parameter it can only be a convention like a length-prefix or sentinel or some fixed expected length).</p>
<h5>
How to get a character pointer valid even after <code>x</code> leaves scope or is modified further
</h2>
<p>You’ll need to <strong><em>copy</em></strong> the contents of the <code>string</code> <code>x</code> to a new memory area outside <code>x</code>. This external buffer could be in many places such as another <code>string</code> or character array variable, it may or may not have a different lifetime than <code>x</code> due to being in a different scope (e.g. namespace, global, static, heap, shared memory, memory mapped file).</p>
<p>To copy the text from <code>std::string x</code> into an independent character array:</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true"></a><span class="co">// USING ANOTHER STRING - AUTO MEMORY MANAGEMENT, EXCEPTION SAFE</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true"></a><span class="bu">std::</span>string old_x = x;</span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true"></a><span class="co">// - old_x will not be affected by subsequent modifications to x...</span></span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true"></a><span class="co">// - you can use `&amp;old_x[0]` to get a writable char* to old_x&#39;s textual content</span></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true"></a><span class="co">// - you can use resize() to reduce/expand the string</span></span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true"></a><span class="co">//   - resizing isn&#39;t possible from within a function passed only the char* address</span></span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true"></a></span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true"></a><span class="bu">std::</span>string old_x = x.c_str(); <span class="co">// old_x will terminate early if x embeds NUL</span></span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true"></a><span class="co">// Copies ASCIIZ data but could be less efficient as it needs to scan memory to</span></span>
<span id="cb109-10"><a href="#cb109-10" aria-hidden="true"></a><span class="co">// find the NUL terminator indicating string length before allocating that amount</span></span>
<span id="cb109-11"><a href="#cb109-11" aria-hidden="true"></a><span class="co">// of memory to copy into, or more efficient if it ends up allocating/copying a</span></span>
<span id="cb109-12"><a href="#cb109-12" aria-hidden="true"></a><span class="co">// lot less content.</span></span>
<span id="cb109-13"><a href="#cb109-13" aria-hidden="true"></a><span class="co">// Example, x == &quot;ab\0cd&quot; -&gt; old_x == &quot;ab&quot;.</span></span>
<span id="cb109-14"><a href="#cb109-14" aria-hidden="true"></a></span>
<span id="cb109-15"><a href="#cb109-15" aria-hidden="true"></a><span class="co">// USING A VECTOR OF CHAR - AUTO, EXCEPTION SAFE, HINTS AT BINARY CONTENT, GUARANTEED CONTIGUOUS EVEN IN C++03</span></span>
<span id="cb109-16"><a href="#cb109-16" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="dt">char</span>&gt; old_x(x.data(), x.data() + x.size());       <span class="co">// without the NUL</span></span>
<span id="cb109-17"><a href="#cb109-17" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="dt">char</span>&gt; old_x(x.c_str(), x.c_str() + x.size() + <span class="dv">1</span>);  <span class="co">// with the NUL</span></span>
<span id="cb109-18"><a href="#cb109-18" aria-hidden="true"></a></span>
<span id="cb109-19"><a href="#cb109-19" aria-hidden="true"></a><span class="co">// USING STACK WHERE MAXIMUM SIZE OF x IS KNOWN TO BE COMPILE-TIME CONSTANT &quot;N&quot;</span></span>
<span id="cb109-20"><a href="#cb109-20" aria-hidden="true"></a><span class="co">// (a bit dangerous, as &quot;known&quot; things are sometimes wrong and often become wrong)</span></span>
<span id="cb109-21"><a href="#cb109-21" aria-hidden="true"></a><span class="dt">char</span> y[N + <span class="dv">1</span>];</span>
<span id="cb109-22"><a href="#cb109-22" aria-hidden="true"></a>strcpy(y, x.c_str());</span>
<span id="cb109-23"><a href="#cb109-23" aria-hidden="true"></a></span>
<span id="cb109-24"><a href="#cb109-24" aria-hidden="true"></a><span class="co">// USING STACK WHERE UNEXPECTEDLY LONG x IS TRUNCATED (e.g. Hello\0-&gt;Hel\0)</span></span>
<span id="cb109-25"><a href="#cb109-25" aria-hidden="true"></a><span class="dt">char</span> y[N + <span class="dv">1</span>];</span>
<span id="cb109-26"><a href="#cb109-26" aria-hidden="true"></a>strncpy(y, x.c_str(), N);  <span class="co">// copy at most N, zero-padding if shorter</span></span>
<span id="cb109-27"><a href="#cb109-27" aria-hidden="true"></a>y[N] = <span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span>;               <span class="co">// ensure NUL terminated</span></span>
<span id="cb109-28"><a href="#cb109-28" aria-hidden="true"></a></span>
<span id="cb109-29"><a href="#cb109-29" aria-hidden="true"></a><span class="co">// USING THE STACK TO HANDLE x OF UNKNOWN (BUT SANE) LENGTH</span></span>
<span id="cb109-30"><a href="#cb109-30" aria-hidden="true"></a><span class="dt">char</span>* y = alloca(x.size() + <span class="dv">1</span>);</span>
<span id="cb109-31"><a href="#cb109-31" aria-hidden="true"></a>strcpy(y, x.c_str());</span>
<span id="cb109-32"><a href="#cb109-32" aria-hidden="true"></a></span>
<span id="cb109-33"><a href="#cb109-33" aria-hidden="true"></a><span class="co">// USING THE STACK TO HANDLE x OF UNKNOWN LENGTH (NON-STANDARD GCC EXTENSION)</span></span>
<span id="cb109-34"><a href="#cb109-34" aria-hidden="true"></a><span class="dt">char</span> y[x.size() + <span class="dv">1</span>];</span>
<span id="cb109-35"><a href="#cb109-35" aria-hidden="true"></a>strcpy(y, x.c_str());</span>
<span id="cb109-36"><a href="#cb109-36" aria-hidden="true"></a></span>
<span id="cb109-37"><a href="#cb109-37" aria-hidden="true"></a><span class="co">// USING new/delete HEAP MEMORY, MANUAL DEALLOC, NO INHERENT EXCEPTION SAFETY</span></span>
<span id="cb109-38"><a href="#cb109-38" aria-hidden="true"></a><span class="dt">char</span>* y = <span class="kw">new</span> <span class="dt">char</span>[x.size() + <span class="dv">1</span>];</span>
<span id="cb109-39"><a href="#cb109-39" aria-hidden="true"></a>strcpy(y, x.c_str());</span>
<span id="cb109-40"><a href="#cb109-40" aria-hidden="true"></a><span class="co">//     or as a one-liner: char* y = strcpy(new char[x.size() + 1], x.c_str());</span></span>
<span id="cb109-41"><a href="#cb109-41" aria-hidden="true"></a><span class="co">// use y...</span></span>
<span id="cb109-42"><a href="#cb109-42" aria-hidden="true"></a><span class="kw">delete</span>[] y; <span class="co">// make sure no break, return, throw or branching bypasses this</span></span>
<span id="cb109-43"><a href="#cb109-43" aria-hidden="true"></a></span>
<span id="cb109-44"><a href="#cb109-44" aria-hidden="true"></a><span class="co">// USING new/delete HEAP MEMORY, SMART POINTER DEALLOCATION, EXCEPTION SAFE</span></span>
<span id="cb109-45"><a href="#cb109-45" aria-hidden="true"></a><span class="co">// see boost shared_array usage in Johannes Schaub&#39;s answer</span></span>
<span id="cb109-46"><a href="#cb109-46" aria-hidden="true"></a></span>
<span id="cb109-47"><a href="#cb109-47" aria-hidden="true"></a><span class="co">// USING malloc/free HEAP MEMORY, MANUAL DEALLOC, NO INHERENT EXCEPTION SAFETY</span></span>
<span id="cb109-48"><a href="#cb109-48" aria-hidden="true"></a><span class="dt">char</span>* y = strdup(x.c_str());</span>
<span id="cb109-49"><a href="#cb109-49" aria-hidden="true"></a><span class="co">// use y...</span></span>
<span id="cb109-50"><a href="#cb109-50" aria-hidden="true"></a>free(y);</span></code></pre></div>
<h5>
Other reasons to want a <code>char*</code> or <code>const char*</code> generated from a <code>string</code>
</h2>
<p>So, above you’ve seen how to get a (<code>const</code>) <code>char*</code>, and how to make a copy of the text independent of the original <code>string</code>, but what can you <em>do</em> with it? A random smattering of examples…</p>
<ul>
<li>
give “C” code access to the C++ <code>string</code>’s text, as in <code>printf("x is '%s'", x.c_str());</code>
</li>
<li>
copy <code>x</code>’s text to a buffer specified by your function’s caller (e.g. <code>strncpy(callers_buffer, callers_buffer_size, x.c_str())</code>), or volatile memory used for device I/O (e.g. <code>for (const char* p = x.c_str(); *p; ++p) *p_device = *p;</code>)
</li>
<li>
append <code>x</code>’s text to an character array already containing some ASCIIZ text (e.g. <code>strcat(other_buffer, x.c_str())</code>) - be careful not to overrun the buffer (in many situations you may need to use <code>strncat</code>)
</li>
<li>
<p>return a <code>const char*</code> or <code>char*</code> from a function (perhaps for historical reasons - client’s using your existing API - or for C compatibility you don’t want to return a <code>std::string</code>, but do want to copy your <code>string</code>’s data somewhere for the caller)</p>
<ul>
<li>
be careful not to return a pointer that may be dereferenced by the caller after a local <code>string</code> variable to which that pointer pointed has left scope
</li>
<li>
some projects with shared objects compiled/linked for different <code>std::string</code> implementations (e.g. STLport and compiler-native) may pass data as ASCIIZ to avoid conflicts
</li>
</ul>
</li>
</ul>
</section>
<section id="answer-3-score-33" class="level4">
<h4>Answer 3 (score 33)</h4>
<p>Use the <code>.c_str()</code> method for <code>const char *</code>.</p>
<p>You can use <code>&amp;amp;mystring[0]</code> to get a <code>char *</code> pointer, but there are a couple of gotcha’s: you won’t necessarily get a zero terminated string, and you won’t be able to change the string’s size. You especially have to be careful not to add characters past the end of the string or you’ll get a buffer overrun (and probable crash).</p>
<p>There was no guarantee that all of the characters would be part of the same contiguous buffer until C++11, but in practice all known implementations of <code>std::string</code> worked that way anyway; see <a href="https://stackoverflow.com/questions/1986966/does-s0-point-to-contiguous-characters-in-a-stdstring">Does “&amp;s[0]” point to contiguous characters in a std::string?</a>.</p>
<p>Note that many <code>string</code> member functions will reallocate the internal buffer and invalidate any pointers you might have saved. Best to use them immediately and then discard.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="what-are-the-basic-rules-and-idioms-for-operator-overloading-score-880173-in-2017" class="level3">
<h3>20: What are the basic rules and idioms for operator overloading? (score <a href="https://stackoverflow.com/q/4421706.html">880173</a> in 2017)</h3>
<section id="question-19" class="level4">
<h4>Question</h4>
<p>Note: The answers were given in <em>a specific order</em>, but since many users sort answers according to votes, rather than the time they were given, here’s an <strong><em>index of the answers</em></strong> in the order in which they make most sense:</p>
<ul>
<li>
<a href="https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421715
#4421715">The General Syntax of operator overloading in C++</a>
</li>
<li>
<a href="https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421708
#4421708">The Three Basic Rules of Operator Overloading in C++</a>
</li>
<li>
<a href="https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421729
#4421729">The Decision between Member and Non-member</a>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421719
#4421719">Common operators to overload</a></p>
<ul>
<li>
Assignment Operator
</li>
<li>
Input and Output Operators
</li>
<li>
Function call operator
</li>
<li>
Comparison operators
</li>
<li>
Arithmetic Operators
</li>
<li>
Array Subscripting
</li>
<li>
Operators for Pointer-like Types
</li>
<li>
<a href="https://stackoverflow.com/questions/4421706/operator-overloading/16615725
#16615725">Conversion Operators</a>
</li>
</ul>
</li>
<li>
<a href="https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421791
#4421791">Overloading new and delete</a>
</li>
</ul>
<p>
<sub> <em>(Note: This is meant to be an entry to <a href="https://stackoverflow.com/questions/tagged/c++-faq">Stack Overflow’s C++ FAQ</a>. If you want to critique the idea of providing an FAQ in this form, then <a href="https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag">the posting on meta that started all this</a> would be the place to do that. Answers to that question are monitored in the <a href="http://chat.stackoverflow.com/rooms/10/c-lounge">C++ chatroom</a>, where the FAQ idea started out in the first place, so your answer is very likely to get read by those who came up with the idea.)</em> </sub>
</p>
</section>
<section id="answer-2-score-997" class="level4">
<h4>Answer 2 (score 997)</h4>
<h5>
Common operators to overload
</h1>
<p>Most of the work in overloading operators is boiler-plate code. That is little wonder, since operators are merely syntactic sugar, their actual work could be done by (and often is forwarded to) plain functions. But it is important that you get this boiler-plate code right. If you fail, either your operator’s code won’t compile or your users’ code won’t compile or your users’ code will behave surprisingly.</p>
<h5>
Assignment Operator
</h2>
<p>There’s a lot to be said about assignment. However, most of it has already been said in <a href="https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom">GMan’s famous Copy-And-Swap FAQ</a>, so I’ll skip most of it here, only listing the perfect assignment operator for reference:</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true"></a>X&amp; X::<span class="kw">operator</span>=(X rhs)</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true"></a>{</span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true"></a>  swap(rhs);</span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true"></a>  <span class="cf">return</span> *<span class="kw">this</span>;</span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true"></a>}</span></code></pre></div>
<h5>
Bitshift Operators (used for Stream I/O)
</h2>
<p>The bitshift operators <code>&amp;lt;&amp;lt;</code> and <code>&amp;gt;&amp;gt;</code>, although still used in hardware interfacing for the bit-manipulation functions they inherit from C, have become more prevalent as overloaded stream input and output operators in most applications. For guidance overloading as bit-manipulation operators, see the section below on Binary Arithmetic Operators. For implementing your own custom format and parsing logic when your object is used with iostreams, continue.</p>
<p>
The stream operators, among the most commonly overloaded operators, are binary infix operators for which the syntax specifies no restriction on whether they should be members or non-members. Since they change their left argument (they alter the stream’s state), they should, according to the rules of thumb, be implemented as members of their left operand’s type. However, their left operands are streams from the standard library, and while most of the stream output and input operators defined by the standard library are indeed defined as members of the stream classes, when you implement output and input operations for your own types, you cannot change the standard library’s stream types. That’s why you need to implement these operators for your own types as non-member functions. The canonical forms of the two are these:
</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true"></a><span class="bu">std::</span>ostream&amp; <span class="kw">operator</span>&lt;&lt;(<span class="bu">std::</span>ostream&amp; os, <span class="at">const</span> T&amp; obj)</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true"></a>{</span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true"></a>  <span class="co">// write obj to stream</span></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true"></a></span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true"></a>  <span class="cf">return</span> os;</span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true"></a>}</span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true"></a></span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true"></a><span class="bu">std::</span>istream&amp; <span class="kw">operator</span>&gt;&gt;(<span class="bu">std::</span>istream&amp; is, T&amp; obj)</span>
<span id="cb111-9"><a href="#cb111-9" aria-hidden="true"></a>{</span>
<span id="cb111-10"><a href="#cb111-10" aria-hidden="true"></a>  <span class="co">// read obj from stream</span></span>
<span id="cb111-11"><a href="#cb111-11" aria-hidden="true"></a></span>
<span id="cb111-12"><a href="#cb111-12" aria-hidden="true"></a>  <span class="cf">if</span>( <span class="co">/* no valid object of T found in stream */</span> )</span>
<span id="cb111-13"><a href="#cb111-13" aria-hidden="true"></a>    is.setstate(<span class="bu">std::</span>ios<span class="bu">::</span>failbit);</span>
<span id="cb111-14"><a href="#cb111-14" aria-hidden="true"></a></span>
<span id="cb111-15"><a href="#cb111-15" aria-hidden="true"></a>  <span class="cf">return</span> is;</span>
<span id="cb111-16"><a href="#cb111-16" aria-hidden="true"></a>}</span></code></pre></div>
<p>When implementing <code>operator&amp;gt;&amp;gt;</code>, manually setting the stream’s state is only necessary when the reading itself succeeded, but the result is not what would be expected.</p>
<h5>
Function call operator
</h2>
<p>The function call operator, used to create function objects, also known as functors, must be defined as a <strong><em>member</em></strong> function, so it always has the implicit <code>this</code> argument of member functions. Other than this, it can be overloaded to take any number of additional arguments, including zero.</p>
<p>Here’s an example of the syntax:</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true"></a><span class="kw">class</span> foo {</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true"></a>    <span class="co">// Overloaded call operator</span></span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true"></a>    <span class="dt">int</span> <span class="kw">operator</span>()(<span class="at">const</span> <span class="bu">std::</span>string&amp; y) {</span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true"></a>        <span class="co">// ...</span></span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true"></a>    }</span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true"></a>};</span></code></pre></div>
<p>Usage:</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true"></a>foo f;</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true"></a><span class="dt">int</span> a = f(<span class="st">&quot;hello&quot;</span>);</span></code></pre></div>
<p>Throughout the C++ standard library, function objects are always copied. Your own function objects should therefore be cheap to copy. If a function object absolutely needs to use data which is expensive to copy, it is better to store that data elsewhere and have the function object refer to it.</p>
<h5>
Comparison operators
</h2>
<p>The binary infix comparison operators should, according to the rules of thumb, be implemented as non-member functions<sup>1</sup>. The unary prefix negation <code>!</code> should (according to the same rules) be implemented as a member function. (but it is usually not a good idea to overload it.)</p>
<p>The standard library’s algorithms (e.g. <code>std::sort()</code>) and types (e.g. <code>std::map</code>) will always only expect <code>operator&amp;lt;</code> to be present. However, the <em>users of your type will expect all the other operators to be present</em>, too, so if you define <code>operator&amp;lt;</code>, be sure to follow the third fundamental rule of operator overloading and also define all the other boolean comparison operators. The canonical way to implement them is this:</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true"></a><span class="kw">inline</span> <span class="dt">bool</span> <span class="kw">operator</span>==(<span class="at">const</span> X&amp; lhs, <span class="at">const</span> X&amp; rhs){ <span class="co">/* do actual comparison */</span> }</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true"></a><span class="kw">inline</span> <span class="dt">bool</span> <span class="kw">operator</span>!=(<span class="at">const</span> X&amp; lhs, <span class="at">const</span> X&amp; rhs){<span class="cf">return</span> !<span class="kw">operator</span>==(lhs,rhs);}</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true"></a><span class="kw">inline</span> <span class="dt">bool</span> <span class="kw">operator</span>&lt; (<span class="at">const</span> X&amp; lhs, <span class="at">const</span> X&amp; rhs){ <span class="co">/* do actual comparison */</span> }</span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true"></a><span class="kw">inline</span> <span class="dt">bool</span> <span class="kw">operator</span>&gt; (<span class="at">const</span> X&amp; lhs, <span class="at">const</span> X&amp; rhs){<span class="cf">return</span>  <span class="kw">operator</span>&lt; (rhs,lhs);}</span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true"></a><span class="kw">inline</span> <span class="dt">bool</span> <span class="kw">operator</span>&lt;=(<span class="at">const</span> X&amp; lhs, <span class="at">const</span> X&amp; rhs){<span class="cf">return</span> !<span class="kw">operator</span>&gt; (lhs,rhs);}</span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true"></a><span class="kw">inline</span> <span class="dt">bool</span> <span class="kw">operator</span>&gt;=(<span class="at">const</span> X&amp; lhs, <span class="at">const</span> X&amp; rhs){<span class="cf">return</span> !<span class="kw">operator</span>&lt; (lhs,rhs);}</span></code></pre></div>
<p>The important thing to note here is that only two of these operators actually do anything, the others are just forwarding their arguments to either of these two to do the actual work.</p>
<p>The syntax for overloading the remaining binary boolean operators (<code>||</code>, <code>&amp;amp;&amp;amp;</code>) follows the rules of the comparison operators. However, it is <em>very</em> unlikely that you would find a reasonable use case for these<sup>2</sup>.</p>
<p><sup>1</sup> <sub>As with all rules of thumb, sometimes there might be reasons to break this one, too. If so, do not forget that the left-hand operand of the binary comparison operators, which for member functions will be <code>*this</code>, needs to be <code>const</code>, too. So a comparison operator implemented as a member function would have to have this signature:</sub></p>
<div class="sourceCode" id="cb115"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true"></a><span class="dt">bool</span> <span class="kw">operator</span>&lt;(<span class="at">const</span> X&amp; rhs) <span class="at">const</span> { <span class="co">/* do actual comparison with *this */</span> }</span></code></pre></div>
<p><sub>(Note the <code>const</code> at the end.)</sub></p>
<p><sup>2</sup> <sub>It should be noted that the built-in version of <code>||</code> and <code>&amp;amp;&amp;amp;</code> use shortcut semantics. While the user defined ones (because they are syntactic sugar for method calls) do not use shortcut semantics. User will expect these operators to have shortcut semantics, and their code may depend on it, Therefore it is highly advised NEVER to define them.</sub></p>
<h5>
Arithmetic Operators
</h2>
<h5>
Unary arithmetic operators
</h3>
<p>
The unary increment and decrement operators come in both prefix and postfix flavor. To tell one from the other, the postfix variants take an additional dummy int argument. If you overload increment or decrement, be sure to always implement both prefix and postfix versions. Here is the canonical implementation of increment, decrement follows the same rules:
</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true"></a><span class="kw">class</span> X {</span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true"></a>  X&amp; <span class="kw">operator</span>++()</span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true"></a>  {</span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true"></a>    <span class="co">// do actual increment</span></span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true"></a>    <span class="cf">return</span> *<span class="kw">this</span>;</span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true"></a>  }</span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true"></a>  X <span class="kw">operator</span>++(<span class="dt">int</span>)</span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true"></a>  {</span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true"></a>    X tmp(*<span class="kw">this</span>);</span>
<span id="cb116-10"><a href="#cb116-10" aria-hidden="true"></a>    <span class="kw">operator</span>++();</span>
<span id="cb116-11"><a href="#cb116-11" aria-hidden="true"></a>    <span class="cf">return</span> tmp;</span>
<span id="cb116-12"><a href="#cb116-12" aria-hidden="true"></a>  }</span>
<span id="cb116-13"><a href="#cb116-13" aria-hidden="true"></a>};</span></code></pre></div>
<p>Note that the postfix variant is implemented in terms of prefix. Also note that postfix does an extra copy.<sup>2</sup></p>
<p>Overloading unary minus and plus is not very common and probably best avoided. If needed, they should probably be overloaded as member functions.</p>
<p><sup>2</sup> <sub>Also note that the postfix variant does more work and is therefore less efficient to use than the prefix variant. This is a good reason to generally prefer prefix increment over postfix increment. While compilers can usually optimize away the additional work of postfix increment for built-in types, they might not be able to do the same for user-defined types (which could be something as innocently looking as a list iterator). Once you got used to do <code>i++</code>, it becomes very hard to remember to do <code>++i</code> instead when <code>i</code> is not of a built-in type (plus you’d have to change code when changing a type), so it is better to make a habit of always using prefix increment, unless postfix is explicitly needed.</sub></p>
<h5>
Binary arithmetic operators
</h3>
<p>For the binary arithmetic operators, do not forget to obey the third basic rule operator overloading: If you provide <code>+</code>, also provide <code>+=</code>, if you provide <code>-</code>, do not omit <code>-=</code>, etc. Andrew Koenig is said to have been the first to observe that the compound assignment operators can be used as a base for their non-compound counterparts. That is, operator <code>+</code> is implemented in terms of <code>+=</code>, <code>-</code> is implemented in terms of <code>-=</code> etc.</p>
<p>According to our rules of thumb, <code>+</code> and its companions should be non-members, while their compound assignment counterparts (<code>+=</code> etc.), changing their left argument, should be a member. Here is the exemplary code for <code>+=</code> and <code>+</code>; the other binary arithmetic operators should be implemented in the same way:</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true"></a><span class="kw">class</span> X {</span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true"></a>  X&amp; <span class="kw">operator</span>+=(<span class="at">const</span> X&amp; rhs)</span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true"></a>  {</span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true"></a>    <span class="co">// actual addition of rhs to *this</span></span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true"></a>    <span class="cf">return</span> *<span class="kw">this</span>;</span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true"></a>  }</span>
<span id="cb117-7"><a href="#cb117-7" aria-hidden="true"></a>};</span>
<span id="cb117-8"><a href="#cb117-8" aria-hidden="true"></a><span class="kw">inline</span> X <span class="kw">operator</span>+(X lhs, <span class="at">const</span> X&amp; rhs)</span>
<span id="cb117-9"><a href="#cb117-9" aria-hidden="true"></a>{</span>
<span id="cb117-10"><a href="#cb117-10" aria-hidden="true"></a>  lhs += rhs;</span>
<span id="cb117-11"><a href="#cb117-11" aria-hidden="true"></a>  <span class="cf">return</span> lhs;</span>
<span id="cb117-12"><a href="#cb117-12" aria-hidden="true"></a>}</span></code></pre></div>
<p>
<code>operator+=</code> returns its result per reference, while <code>operator+</code> returns a copy of its result. Of course, returning a reference is usually more efficient than returning a copy, but in the case of <code>operator+</code>, there is no way around the copying. When you write <code>a + b</code>, you expect the result to be a new value, which is why <code>operator+</code> has to return a new value.<sup>3</sup> Also note that <code>operator+</code> takes its left operand <strong><em>by copy</em></strong> rather than by const reference. The reason for this is the same as the reason giving for <code>operator=</code> taking its argument per copy.
</p>
<p>The bit manipulation operators <code>~</code> <code>&amp;amp;</code> <code>|</code> <code>^</code> <code>&amp;lt;&amp;lt;</code> <code>&amp;gt;&amp;gt;</code> should be implemented in the same way as the arithmetic operators. However, (except for overloading <code>&amp;lt;&amp;lt;</code> and <code>&amp;gt;&amp;gt;</code> for output and input) there are very few reasonable use cases for overloading these.</p>
<p><sup>3</sup> <sub>Again, the lesson to be taken from this is that <code>a += b</code> is, in general, more efficient than <code>a + b</code> and should be preferred if possible.</sub></p>
<h5>
Array Subscripting
</h2>
<p>
The array subscript operator is a binary operator which must be implemented as a class member. It is used for container-like types that allow access to their data elements by a key. The canonical form of providing these is this:
</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true"></a><span class="kw">class</span> X {</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true"></a>        <span class="dt">value_type</span>&amp; <span class="kw">operator</span>[](<span class="dt">index_type</span> idx);</span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true"></a>  <span class="at">const</span> <span class="dt">value_type</span>&amp; <span class="kw">operator</span>[](<span class="dt">index_type</span> idx) <span class="at">const</span>;</span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true"></a>  <span class="co">// ...</span></span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true"></a>};</span></code></pre></div>
<p>Unless you do not want users of your class to be able to change data elements returned by <code>operator[]</code> (in which case you can omit the non-const variant), you should always provide both variants of the operator.</p>
<p>If value_type is known to refer to a built-in type, the const variant of the operator should better return a copy instead of a const reference:</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true"></a><span class="kw">class</span> X {</span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true"></a>  <span class="dt">value_type</span>&amp; <span class="kw">operator</span>[](<span class="dt">index_type</span> idx);</span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true"></a>  <span class="dt">value_type</span>  <span class="kw">operator</span>[](<span class="dt">index_type</span> idx) <span class="at">const</span>;</span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true"></a>  <span class="co">// ...</span></span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true"></a>};</span></code></pre></div>
<h5>
Operators for Pointer-like Types
</h2>
<p>For defining your own iterators or smart pointers, you have to overload the unary prefix dereference operator <code>*</code> and the binary infix pointer member access operator <code>-&amp;gt;</code>:</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true"></a><span class="kw">class</span> my_ptr {</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true"></a>        <span class="dt">value_type</span>&amp; <span class="kw">operator</span>*();</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true"></a>  <span class="at">const</span> <span class="dt">value_type</span>&amp; <span class="kw">operator</span>*() <span class="at">const</span>;</span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true"></a>        <span class="dt">value_type</span>* <span class="kw">operator</span>-&gt;();</span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true"></a>  <span class="at">const</span> <span class="dt">value_type</span>* <span class="kw">operator</span>-&gt;() <span class="at">const</span>;</span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true"></a>};</span></code></pre></div>
<p>
Note that these, too, will almost always need both a const and a non-const version. For the <code>-&amp;gt;</code> operator, if <code>value_type</code> is of <code>class</code> (or <code>struct</code> or <code>union</code>) type, another <code>operator-&amp;gt;()</code> is called recursively, until an <code>operator-&amp;gt;()</code> returns a value of non-class type.
</p>
<p>The unary address-of operator should never be overloaded.</p>
<p>For <code>operator-&amp;gt;*()</code> see <a href="https://stackoverflow.com/q/8777845/140719">this question</a>. It’s rarely used and thus rarely ever overloaded. In fact, even iterators do not overload it.</p>
<hr>
<p>Continue to <a href="https://stackoverflow.com/questions/4421706/operator-overloading/16615725
#16615725">Conversion Operators</a></p>
</section>
<section id="answer-3-score-475" class="level4">
<h4>Answer 3 (score 475)</h4>
<h5>
The Three Basic Rules of Operator Overloading in C++
</h1>
<p>When it comes to operator overloading in C++, there are <strong><em>three basic rules you should follow</em></strong>. As with all such rules, there are indeed exceptions. Sometimes people have deviated from them and the outcome was not bad code, but such positive deviations are few and far between. At the very least, 99 out of 100 such deviations I have seen were unjustified. However, it might just as well have been 999 out of 1000. So you’d better stick to the following rules.</p>
<ol>
<li>
<p>
<strong><em>Whenever the meaning of an operator is not obviously clear and undisputed, it should not be overloaded.</em></strong> <em>Instead, provide a function with a well-chosen name.</em><br> Basically, the first and foremost rule for overloading operators, at its very heart, says: <em>Don’t do it</em>. That might seem strange, because there is a lot to be known about operator overloading and so a lot of articles, book chapters, and other texts deal with all this. But despite this seemingly obvious evidence, <em>there are only a surprisingly few cases where operator overloading is appropriate</em>. The reason is that actually it is hard to understand the semantics behind the application of an operator unless the use of the operator in the application domain is well known and undisputed. Contrary to popular belief, this is hardly ever the case.
</p>
</li>
<li>
<p>
<strong><em>Always stick to the operator’s well-known semantics.</em></strong><br> C++ poses no limitations on the semantics of overloaded operators. Your compiler will happily accept code that implements the binary <code>+</code> operator to subtract from its right operand. However, the users of such an operator would never suspect the expression <code>a + b</code> to subtract <code>a</code> from <code>b</code>. Of course, this supposes that the semantics of the operator in the application domain is undisputed.
</p>
</li>
<li>
<p>
<strong><em>Always provide all out of a set of related operations.</em></strong><br> <em>Operators are related to each other</em> and to other operations. If your type supports <code>a + b</code>, users will expect to be able to call <code>a += b</code>, too. If it supports prefix increment <code>++a</code>, they will expect <code>a++</code> to work as well. If they can check whether <code>a &amp;lt; b</code>, they will most certainly expect to also to be able to check whether <code>a &amp;gt; b</code>. If they can copy-construct your type, they expect assignment to work as well.
</p>
</li>
</ol>
<hr>
<p>Continue to <a href="https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421729
#4421729">The Decision between Member and Non-member</a>.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-to-find-out-if-an-item-is-present-in-a-stdvector-score-864239-in-2017" class="level3">
<h3>21: How to find out if an item is present in a std::vector? (score <a href="https://stackoverflow.com/q/571394.html">864239</a> in 2017)</h3>
<section id="question-20" class="level4">
<h4>Question</h4>
<p>All I want to do is to check whether an element exists in the vector or not, so I can deal with each case.</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true"></a><span class="cf">if</span> ( item_present )</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true"></a>   do_this();</span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true"></a><span class="cf">else</span></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true"></a>   do_that();</span></code></pre></div>
</section>
<section id="answer-accepted-score-863" class="level4">
<h4>Answer accepted (score 863)</h4>
<p>You can use <a href="http://en.cppreference.com/w/cpp/algorithm/find" rel="noreferrer"><code>std::find</code></a> from <code>&amp;lt;algorithm&amp;gt;</code>:</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true"></a></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true"></a>vector&lt;<span class="dt">int</span>&gt; vec; </span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true"></a><span class="co">//can have other data types instead of int but must same datatype as item </span></span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true"></a><span class="bu">std::</span>find(vec.begin(), vec.end(), item) != vec.end()</span></code></pre></div>
<p>This returns a bool (<code>true</code> if present, <code>false</code> otherwise). With your example:</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true"></a></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true"></a></span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true"></a></span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true"></a><span class="cf">if</span> ( <span class="bu">std::</span>find(vec.begin(), vec.end(), item) != vec.end() )</span>
<span id="cb123-7"><a href="#cb123-7" aria-hidden="true"></a>   do_this();</span>
<span id="cb123-8"><a href="#cb123-8" aria-hidden="true"></a><span class="cf">else</span></span>
<span id="cb123-9"><a href="#cb123-9" aria-hidden="true"></a>   do_that();</span></code></pre></div>
</section>
<section id="answer-2-score-107" class="level4">
<h4>Answer 2 (score 107)</h4>
<p>As others have said, use the STL <a href="http://en.cppreference.com/w/cpp/algorithm/find" rel="noreferrer"><code>find</code></a> or <a href="http://en.cppreference.com/w/cpp/algorithm/find" rel="noreferrer"><code>find_if</code></a> functions. But if you are searching in very large vectors and this impacts performance, you may want to sort your vector and then use the <a href="http://en.cppreference.com/w/cpp/algorithm/binary_search" rel="noreferrer"><code>binary_search</code></a>, <a href="http://en.cppreference.com/w/cpp/algorithm/lower_bound" rel="noreferrer"><code>lower_bound</code></a>, or <a href="http://en.cppreference.com/w/cpp/algorithm/upper_bound" rel="noreferrer"><code>upper_bound</code></a> algorithms.</p>
</section>
<section id="answer-3-score-46" class="level4">
<h4>Answer 3 (score 46)</h4>
<p>Use find from the algorithm header of stl.I’ve illustrated its use with int type. You can use any type you like as long as you can compare for equality (overload == if you need to for your custom class).</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true"></a></span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true"></a></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true"></a></span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb124-7"><a href="#cb124-7" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb124-8"><a href="#cb124-8" aria-hidden="true"></a>{   </span>
<span id="cb124-9"><a href="#cb124-9" aria-hidden="true"></a>    <span class="kw">typedef</span> vector&lt;<span class="dt">int</span>&gt; IntContainer;</span>
<span id="cb124-10"><a href="#cb124-10" aria-hidden="true"></a>    <span class="kw">typedef</span> IntContainer::iterator IntIterator;</span>
<span id="cb124-11"><a href="#cb124-11" aria-hidden="true"></a></span>
<span id="cb124-12"><a href="#cb124-12" aria-hidden="true"></a>    IntContainer vw;</span>
<span id="cb124-13"><a href="#cb124-13" aria-hidden="true"></a></span>
<span id="cb124-14"><a href="#cb124-14" aria-hidden="true"></a>    <span class="co">//...</span></span>
<span id="cb124-15"><a href="#cb124-15" aria-hidden="true"></a></span>
<span id="cb124-16"><a href="#cb124-16" aria-hidden="true"></a>    <span class="co">// find 5</span></span>
<span id="cb124-17"><a href="#cb124-17" aria-hidden="true"></a>    IntIterator i = find(vw.begin(), vw.end(), <span class="dv">5</span>);</span>
<span id="cb124-18"><a href="#cb124-18" aria-hidden="true"></a></span>
<span id="cb124-19"><a href="#cb124-19" aria-hidden="true"></a>    <span class="cf">if</span> (i != vw.end()) {</span>
<span id="cb124-20"><a href="#cb124-20" aria-hidden="true"></a>        <span class="co">// found it</span></span>
<span id="cb124-21"><a href="#cb124-21" aria-hidden="true"></a>    } <span class="cf">else</span> {</span>
<span id="cb124-22"><a href="#cb124-22" aria-hidden="true"></a>        <span class="co">// doesn&#39;t exist</span></span>
<span id="cb124-23"><a href="#cb124-23" aria-hidden="true"></a>    }</span>
<span id="cb124-24"><a href="#cb124-24" aria-hidden="true"></a></span>
<span id="cb124-25"><a href="#cb124-25" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb124-26"><a href="#cb124-26" aria-hidden="true"></a>}</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-do-i-declare-a-2d-array-in-c-using-new-score-851223-in-2016" class="level3">
<h3>22: How do I declare a 2d array in C++ using new? (score <a href="https://stackoverflow.com/q/936687.html">851223</a> in 2016)</h3>
<section id="question-21" class="level4">
<h4>Question</h4>
<p>How do i declare a 2d array using new?</p>
<p>Like, for a “normal” array I would:</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true"></a><span class="dt">int</span>* ary = <span class="kw">new</span> <span class="dt">int</span>[Size]</span></code></pre></div>
<p>but</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true"></a><span class="dt">int</span>** ary = <span class="kw">new</span> <span class="dt">int</span>[sizeY][sizeX]</span></code></pre></div>
<ol type="a">
<li>doesn’t work/compile and b) doesn’t accomplish what:</li>
</ol>
<div class="sourceCode" id="cb127"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true"></a><span class="dt">int</span> ary[sizeY][sizeX] </span></code></pre></div>
<p>does.</p>
</section>
<section id="answer-accepted-score-701" class="level4">
<h4>Answer accepted (score 701)</h4>
<p>A dynamic 2D array is basically an array of <em>pointers to arrays</em>. You can initialize it using a loop, like this:</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true"></a><span class="dt">int</span>** a = <span class="kw">new</span> <span class="dt">int</span>*[rowCount];</span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true"></a><span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; rowCount; ++i)</span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true"></a>    a[i] = <span class="kw">new</span> <span class="dt">int</span>[colCount];</span></code></pre></div>
<p>The above, for <code>colCount= 5</code> and <code>rowCount = 4</code>, would produce the following:</p>
<p><img src="https://i.stack.imgur.com/M75kn.png" alt="enter image description here"></p>
</section>
<section id="answer-2-score-290" class="level4">
<h4>Answer 2 (score 290)</h4>
<div class="sourceCode" id="cb129"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true"></a><span class="dt">int</span>** ary = <span class="kw">new</span> <span class="dt">int</span>[sizeY][sizeX]</span></code></pre></div>
<p>should be:</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true"></a><span class="dt">int</span> **ary = <span class="kw">new</span> <span class="dt">int</span>*[sizeY];</span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true"></a><span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; sizeY; ++i) {</span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true"></a>    ary[i] = <span class="kw">new</span> <span class="dt">int</span>[sizeX];</span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>and then clean up would be:</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true"></a><span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; sizeY; ++i) {</span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true"></a>    <span class="kw">delete</span> [] ary[i];</span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true"></a>}</span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true"></a><span class="kw">delete</span> [] ary;</span></code></pre></div>
<p><strong>EDIT:</strong> as Dietrich Epp pointed out in the comments this is not exactly a light weight solution. An alternative approach would be to use one large block of memory:</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true"></a><span class="dt">int</span> *ary = <span class="kw">new</span> <span class="dt">int</span>[sizeX*sizeY];</span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true"></a></span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true"></a><span class="co">// ary[i][j] is then rewritten as</span></span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true"></a>ary[i*sizeY+j]</span></code></pre></div>
</section>
<section id="answer-3-score-196" class="level4">
<h4>Answer 3 (score 196)</h4>
<p>Although <a href="https://stackoverflow.com/a/936702/358475">this popular answer</a> will give you your desired indexing syntax, it is doubly inefficient: big and slow both in space and time. There’s a better way.</p>
<p><strong>Why That Answer is Big and Slow</strong></p>
<p>The proposed solution is to create a dynamic array of pointers, then initializing each pointer to its own, independent dynamic array. The <strong>advantage</strong> of this approach is that it gives you the indexing syntax you’re used to, so if you want to find the value of the matrix at position x,y, you say:</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true"></a><span class="dt">int</span> val = matrix[ x ][ y ];</span></code></pre></div>
<p>This works because matrix[x] returns a pointer to an array, which is then indexed with [y]. Breaking it down:</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true"></a><span class="dt">int</span>* row = matrix[ x ];</span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true"></a><span class="dt">int</span>  val = row[ y ];</span></code></pre></div>
<p>Convenient, yes? We like our [ x ][ y ] syntax.</p>
<p>But the solution has a big <strong>disadvantage</strong>, which is that it is both fat and slow.</p>
<p>Why?</p>
<p>The reason that it’s both fat and slow is actually the same. Each “row” in the matrix is a separately allocated dynamic array. Making a heap allocation is expensive both in time and space. The allocator takes time to make the allocation, sometimes running O(n) algorithms to do it. And the allocator “pads” each of your row arrays with extra bytes for bookkeeping and alignment. That extra space costs…well…extra space. The deallocator will <em>also</em> take extra time when you go to deallocate the matrix, painstakingly free-ing up each individual row allocation. Gets me in a sweat just thinking about it.</p>
<p>There’s another reason it’s slow. These separate allocations tend to live in discontinuous parts of memory. One row may be at address 1,000, another at address 100,000—you get the idea. This means that when you’re traversing the matrix, you’re leaping through memory like a wild person. This tends to result in cache misses that vastly slow down your processing time.</p>
<p>So, if you absolute must have your cute [x][y] indexing syntax, use that solution. If you want quickness and smallness (and if you don’t care about those, why are you working in C++?), you need a different solution.</p>
<p><strong>A Different Solution</strong></p>
<p>The better solution is to allocate your whole matrix as a single dynamic array, then use (slightly) clever indexing math of your own to access cells. The indexing math is only very slightly clever; nah, it’s not clever at all: it’s obvious.</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true"></a><span class="kw">class</span> Matrix</span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true"></a>{</span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true"></a>    ...</span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true"></a>    <span class="dt">size_t</span> index( <span class="dt">int</span> x, <span class="dt">int</span> y ) <span class="at">const</span> { <span class="cf">return</span> x + <span class="va">m_width</span> * y; }</span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true"></a>};</span></code></pre></div>
<p>Given this <code>index()</code> function (which I’m imagining is a member of a class because it needs to know the <code>m_width</code> of your matrix), you can access cells within your matrix array. The matrix array is allocated like this:</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true"></a>array = <span class="kw">new</span> <span class="dt">int</span>[ width * height ];</span></code></pre></div>
<p>So the equivalent of this in the slow, fat solution:</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true"></a>array[ x ][ y ]</span></code></pre></div>
<p>…is this in the quick, small solution:</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true"></a>array[ index( x, y )]</span></code></pre></div>
<p>Sad, I know. But you’ll get used to it. And your CPU will thank you.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="usrbinld-cannot-find--l-score-838868-in-2016" class="level3">
<h3>23: usr/bin/ld: cannot find -l<nameOfTheLibrary> (score <a href="https://stackoverflow.com/q/16710047.html">838868</a> in 2016)</h3>
<section id="question-22" class="level4">
<h4>Question</h4>
<p>I’m trying to compile my program and it returns this error :</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true"></a>usr/bin/ld: cannot find -l&lt;nameOfTheLibrary&gt;</span></code></pre></div>
<p>in my makefile I use the command <code>g++</code> and link to my library which is a symbolic link to my library located on an other directory.</p>
<p>Is there an option to add to make it work please?</p>
</section>
<section id="answer-accepted-score-172" class="level4">
<h4>Answer accepted (score 172)</h4>
<p>If your library name is say <code>libxyz.so</code> and it is located on path say:</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true"></a>/home/user/myDir</span></code></pre></div>
<p>then to link it to your program:</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true"></a>g++ -L/home/user/myDir -lxyz myprog.cpp -o myprog</span></code></pre></div>
</section>
<section id="answer-2-score-416" class="level4">
<h4>Answer 2 (score 416)</h4>
<p>To figure out what the linker is looking for, run it in verbose mode.</p>
<p>For example, I encountered this issue while trying to compile MySQL with ZLIB support. I was receiving an error like this during compilation:</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true"></a>/usr/bin/ld: cannot find -lzlib</span></code></pre></div>
<p>I did some Googl’ing and kept coming across different issues of the same kind where people would say to make sure the .so file actually exists and if it doesn’t, then create a symlink to the versioned file, for example, zlib.so.1.2.8. But, when I checked, zlib.so DID exist. So, I thought, surely that couldn’t be the problem.</p>
<p>I came across another post on the Internets that suggested to run make with LD_DEBUG=all:</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true"></a>LD_DEBUG=all make</span></code></pre></div>
<p>Although I got a TON of debugging output, it wasn’t actually helpful. It added more confusion than anything else. So, I was about to give up.</p>
<p>Then, I had an epiphany. I thought to actually check the help text for the ld command:</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true"></a>ld --help</span></code></pre></div>
<p>From that, I figured out how to run ld in verbose mode (imagine that):</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true"></a>ld -lzlib --verbose</span></code></pre></div>
<p>This is the output I got:</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true"></a>==================================================</span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true"></a>attempt to open /usr/x86_64-<span class="ot">linux</span>-gnu/lib64/libzlib.so failed</span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true"></a>attempt to open /usr/x86_64-<span class="ot">linux</span>-gnu/lib64/libzlib.a failed</span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true"></a>attempt to open /usr/local/lib64/libzlib.so failed</span>
<span id="cb146-5"><a href="#cb146-5" aria-hidden="true"></a>attempt to open /usr/local/lib64/libzlib.a failed</span>
<span id="cb146-6"><a href="#cb146-6" aria-hidden="true"></a>attempt to open /lib64/libzlib.so failed</span>
<span id="cb146-7"><a href="#cb146-7" aria-hidden="true"></a>attempt to open /lib64/libzlib.a failed</span>
<span id="cb146-8"><a href="#cb146-8" aria-hidden="true"></a>attempt to open /usr/lib64/libzlib.so failed</span>
<span id="cb146-9"><a href="#cb146-9" aria-hidden="true"></a>attempt to open /usr/lib64/libzlib.a failed</span>
<span id="cb146-10"><a href="#cb146-10" aria-hidden="true"></a>attempt to open /usr/x86_64-<span class="ot">linux</span>-gnu/lib/libzlib.so failed</span>
<span id="cb146-11"><a href="#cb146-11" aria-hidden="true"></a>attempt to open /usr/x86_64-<span class="ot">linux</span>-gnu/lib/libzlib.a failed</span>
<span id="cb146-12"><a href="#cb146-12" aria-hidden="true"></a>attempt to open /usr/local/lib/libzlib.so failed</span>
<span id="cb146-13"><a href="#cb146-13" aria-hidden="true"></a>attempt to open /usr/local/lib/libzlib.a failed</span>
<span id="cb146-14"><a href="#cb146-14" aria-hidden="true"></a>attempt to open /lib/libzlib.so failed</span>
<span id="cb146-15"><a href="#cb146-15" aria-hidden="true"></a>attempt to open /lib/libzlib.a failed</span>
<span id="cb146-16"><a href="#cb146-16" aria-hidden="true"></a>attempt to open /usr/lib/libzlib.so failed</span>
<span id="cb146-17"><a href="#cb146-17" aria-hidden="true"></a>attempt to open /usr/lib/libzlib.a failed</span>
<span id="cb146-18"><a href="#cb146-18" aria-hidden="true"></a>/usr/bin/ld.bfd.real: cannot find -lzlib</span></code></pre></div>
<p>Ding, ding, ding…</p>
<p>So, to finally fix it so I could compile MySQL with my own version of ZLIB (rather than the bundled version):</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true"></a>sudo ln -s /usr/lib/libz.so<span class="fl">.1</span><span class="er">.2</span><span class="fl">.8</span> /usr/lib/libzlib.so</span></code></pre></div>
<p>Voila!</p>
</section>
<section id="answer-3-score-38" class="level4">
<h4>Answer 3 (score 38)</h4>
<p>There does not seem to be any answer which addresses the very common beginner problem of failing to install the required library in the first place.</p>
<p>On Debianish platforms, if <code>libfoo</code> is missing, you can frequently install it with something like</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true"></a>apt-get install libfoo-dev</span></code></pre></div>
<p>The <code>-dev</code> version of the package is required for development work, even trivial development work such as compiling source code to link to the library.</p>
<p>The package name will sometimes require some decorations (<code>libfoo0-dev</code>? <code>foo-dev</code> without the <code>lib</code> prefix? etc), or you can simply use your distro’s <a href="https://packages.debian.org/search?searchon=contents&amp;keywords=libfoo.so&amp;mode=exactfilename&amp;suite=stable&amp;arch=any" rel="noreferrer">package search</a> to find out precisely which packages provide a particular file.</p>
<p>(If there is more than one, you will need to find out what their differences are. Picking the coolest or the most popular is a common shortcut, but not an acceptable procedure for any serious development work.)</p>
<p>For other architectures (most notably RPM) similar procedures apply, though the details will be different.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="stdstring-to-char-score-818531-in" class="level3">
<h3>24: std::string to char* (score <a href="https://stackoverflow.com/q/7352099.html">818531</a> in )</h3>
<section id="question-23" class="level4">
<h4>Question</h4>
<p>I want to convert a <strong>std::string</strong> into a <strong>char*</strong> or <strong>char[]</strong> data type.</p>
<div class="sourceCode" id="cb149"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true"></a><span class="bu">std::</span>string str = <span class="st">&quot;string&quot;</span>;</span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true"></a><span class="dt">char</span>* chr = str;</span></code></pre></div>
<p>Results in: <strong>“error: cannot convert ‘std::string’ to ‘char’ …”</strong>.</p>
<p>What methods are there available to do this?</p>
</section>
<section id="answer-accepted-score-611" class="level4">
<h4>Answer accepted (score 611)</h4>
<p>It won’t automatically convert (thank god). You’ll have to use the method <code>c_str()</code> to get the C string version.</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true"></a><span class="bu">std::</span>string str = <span class="st">&quot;string&quot;</span>;</span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true"></a><span class="at">const</span> <span class="dt">char</span> *cstr = str.c_str();</span></code></pre></div>
<p>Note that it returns a <code>const char *</code>; you aren’t allowed to change the C-style string returned by <code>c_str()</code>. If you want to process it you’ll have to copy it first:</p>
<div class="sourceCode" id="cb151"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true"></a><span class="bu">std::</span>string str = <span class="st">&quot;string&quot;</span>;</span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true"></a><span class="dt">char</span> *cstr = <span class="kw">new</span> <span class="dt">char</span>[str.length() + <span class="dv">1</span>];</span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true"></a>strcpy(cstr, str.c_str());</span>
<span id="cb151-4"><a href="#cb151-4" aria-hidden="true"></a><span class="co">// do stuff</span></span>
<span id="cb151-5"><a href="#cb151-5" aria-hidden="true"></a><span class="kw">delete</span> [] cstr;</span></code></pre></div>
<p>Or in modern C++:</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="dt">char</span>&gt; cstr(str.c_str(), str.c_str() + str.size() + <span class="dv">1</span>);</span></code></pre></div>
</section>
<section id="answer-2-score-137" class="level4">
<h4>Answer 2 (score 137)</h4>
<p><a href="https://stackoverflow.com/a/4152881/111307">More details here</a>, and <a href="https://stackoverflow.com/a/10916896/111307">here</a> but you can use</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true"></a>string str = <span class="st">&quot;some string&quot;</span> ;</span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true"></a><span class="dt">char</span> *cstr = &amp;str[<span class="dv">0</span>];</span></code></pre></div>
</section>
<section id="answer-3-score-38-1" class="level4">
<h4>Answer 3 (score 38)</h4>
<p>If I’d need a mutable raw copy of a c++’s string contents, then I’d do this:</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true"></a><span class="bu">std::</span>string str = <span class="st">&quot;string&quot;</span>;</span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true"></a><span class="dt">char</span>* chr = strdup(str.c_str());</span></code></pre></div>
<p>and later:</p>
<div class="sourceCode" id="cb155"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true"></a>free(chr); </span></code></pre></div>
<p>So why don’t I fiddle with std::vector or new[] like anyone else? Because <em>when I need a mutable C-style raw char* string, then because I want to call C code which changes the string and C code deallocates stuff with free() and allocates with malloc() (strdup uses malloc)</em>. So if I pass my raw string to some function X <em>written in C</em> it <em>might</em> have a constraint on it’s argument that it has to allocated on the heap (for example if the function might want to call realloc on the parameter). But it is highly unlikely that it would expect an argument allocated with (some user-redefined) new[]!</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-to-convert-stdstring-to-lower-case-score-810490-in-2018" class="level3">
<h3>25: How to convert std::string to lower case? (score <a href="https://stackoverflow.com/q/313970.html">810490</a> in 2018)</h3>
<section id="question-24" class="level4">
<h4>Question</h4>
<p>I want to convert a <code>std::string</code> to lowercase. I am aware of the function <code>tolower()</code>, however in the past I have had issues with this function and it is hardly ideal anyway as use with a <code>std::string</code> would require iterating over each character.</p>
<p>Is there an alternative which works 100% of the time?</p>
</section>
<section id="answer-accepted-score-855" class="level4">
<h4>Answer accepted (score 855)</h4>
<p>Adapted from <a href="http://notfaq.wordpress.com/2007/08/04/cc-convert-string-to-upperlower-case/" rel="noreferrer"><em>Not So Frequently Asked Questions</em></a>:</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true"></a></span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true"></a></span>
<span id="cb156-4"><a href="#cb156-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb156-5"><a href="#cb156-5" aria-hidden="true"></a></span>
<span id="cb156-6"><a href="#cb156-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb156-7"><a href="#cb156-7" aria-hidden="true"></a></span>
<span id="cb156-8"><a href="#cb156-8" aria-hidden="true"></a><span class="bu">std::</span>string data = <span class="st">&quot;Abc&quot;</span>;</span>
<span id="cb156-9"><a href="#cb156-9" aria-hidden="true"></a><span class="bu">std::</span>transform(data.begin(), data.end(), data.begin(),</span>
<span id="cb156-10"><a href="#cb156-10" aria-hidden="true"></a>    [](<span class="dt">unsigned</span> <span class="dt">char</span> c){ <span class="cf">return</span> <span class="bu">std::</span>tolower(c); });</span></code></pre></div>
<p>You’re really not going to get away without iterating through each character. There’s no way to know whether the character is lowercase or uppercase otherwise.</p>
<p>If you really hate <a href="https://en.cppreference.com/w/cpp/string/byte/tolower" rel="noreferrer"><code>tolower()</code></a>, here’s a specialized ASCII-only alternative that I don’t recommend you use:</p>
<div class="sourceCode" id="cb157"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true"></a><span class="dt">char</span> asciitolower(<span class="dt">char</span> in) {</span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true"></a>    <span class="cf">if</span> (in &lt;= <span class="ch">&#39;Z&#39;</span> &amp;&amp; in &gt;= <span class="ch">&#39;A&#39;</span>)</span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true"></a>        <span class="cf">return</span> in - (<span class="ch">&#39;Z&#39;</span> - <span class="ch">&#39;z&#39;</span>);</span>
<span id="cb157-4"><a href="#cb157-4" aria-hidden="true"></a>    <span class="cf">return</span> in;</span>
<span id="cb157-5"><a href="#cb157-5" aria-hidden="true"></a>}</span>
<span id="cb157-6"><a href="#cb157-6" aria-hidden="true"></a></span>
<span id="cb157-7"><a href="#cb157-7" aria-hidden="true"></a><span class="bu">std::</span>transform(data.begin(), data.end(), data.begin(), asciitolower);</span></code></pre></div>
<p>Be aware that <code>tolower()</code> can only do a per-single-byte-character substitution, which is ill-fitting for many scripts, especially if using a multi-byte-encoding like UTF-8.</p>
</section>
<section id="answer-2-score-299" class="level4">
<h4>Answer 2 (score 299)</h4>
<p><a href="https://www.boost.org/doc/libs/1_70_0/doc/html/boost/algorithm/to_lower.html" rel="nofollow noreferrer">Boost provides a string algorithm for this</a>:</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true"></a></span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;boost/algorithm/string.hpp&gt;</span></span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true"></a></span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true"></a><span class="bu">std::</span>string str = <span class="st">&quot;HELLO, WORLD!&quot;</span>;</span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true"></a><span class="ex">boost::</span>algorithm<span class="ex">::</span>to_lower(str); <span class="co">// modifies str</span></span></code></pre></div>
<p><a href="https://www.boost.org/doc/libs/1_70_0/doc/html/boost/algorithm/to_lower_copy.html" rel="nofollow noreferrer">Or, for non-in-place</a>:</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true"></a></span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;boost/algorithm/string.hpp&gt;</span></span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true"></a></span>
<span id="cb159-4"><a href="#cb159-4" aria-hidden="true"></a><span class="at">const</span> <span class="bu">std::</span>string str = <span class="st">&quot;HELLO, WORLD!&quot;</span>;</span>
<span id="cb159-5"><a href="#cb159-5" aria-hidden="true"></a><span class="at">const</span> <span class="bu">std::</span>string lower_str = <span class="ex">boost::</span>algorithm<span class="ex">::</span>to_lower_copy(str);</span></code></pre></div>
</section>
<section id="answer-3-score-213" class="level4">
<h4>Answer 3 (score 213)</h4>
<p><strong>tl;dr</strong></p>
<p><strong>Use the <a href="http://www.icu-project.org" rel="noreferrer">ICU library</a>.</strong></p>
<hr>
<p>First you have to answer a question: What is the <em>encoding</em> of your <code>std::string</code>? Is it ISO-8859-1? Or perhaps ISO-8859-8? Or Windows Codepage 1252? <em>Does whatever you’re using to convert upper-to-lowercase know that?</em> (Or does it fail miserably for characters over <code>0x7f</code>?)</p>
<p>If you are using UTF-8 (the only sane choice among the 8-bit encodings) with <code>std::string</code> as container, you are already deceiving yourself into believing that you are still in control of things, because you are storing a multibyte character sequence in a container that is not aware of the multibyte concept. Even something as simple as <code>.substr()</code> is a ticking timebomb. (Because splitting a multibyte sequence will result in an invalid (sub-) string.)</p>
<p>And as soon as you try something like <code>std::toupper( 'ß' )</code>, in <em>any</em> encoding, you are in deep trouble. (Because it’s simply not possible to do this “right” with the standard library, which can only deliver <em>one</em> result character, not the <code>"SS"</code> needed here.) [1] Another example would be <code>std::tolower( 'I' )</code>, which should yield different results <em>depending on the locale</em>. In Germany, <code>'i'</code> would be correct; in Turkey, <code>'ı'</code> (LATIN SMALL LETTER DOTLESS I) is the expected result (which, again, is more than one byte in UTF-8 encoding).</p>
<p>Then there is the point that the standard library is depending on which locales are <em>supported</em> on the machine your software is running on… and what do you do if it isn’t?</p>
<p>So what you are <em>really</em> looking for is a string class that is capable of dealing with all this correctly, <strong>and that is <em>not</em> any of the <code>std::basic_string&amp;lt;&amp;gt;</code> variants</strong>.</p>
<p>(C++11 note: <code>std::u16string</code> and <code>std::u32string</code> are <em>better</em>, but still not perfect. C++20 brought <code>std::u8string</code>, but all these do is specify the encoding. In many other respects they still remain ignorant of Unicode mechanics, like normalization, collation, …)</p>
<p>While Boost <em>looks</em> nice, API wise, Boost.Locale is basically a wrapper around <a href="http://www.icu-project.org" rel="noreferrer">ICU</a>. <strong>If</strong> Boost is <em>compiled</em> with ICU support… if it isn’t, Boost.Locale is limited to the locale support compiled for the standard library.</p>
<p>And believe me, <em>getting</em> Boost to compile with ICU can be a real pain sometimes. (There are no pre-compiled binaries for Windows, so you’d have to supply them together with your application, and <em>that</em> opens a whole new can of worms…)</p>
<p>So personally I would recommend getting full Unicode support straight from the horse’s mouth and using the <a href="http://www.icu-project.org" rel="noreferrer">ICU</a> library directly:</p>
<div class="sourceCode" id="cb160"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true"></a></span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;unicode/unistr.h&gt;</span></span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true"></a></span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;unicode/ustream.h&gt;</span></span>
<span id="cb160-5"><a href="#cb160-5" aria-hidden="true"></a></span>
<span id="cb160-6"><a href="#cb160-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;unicode/locid.h&gt;</span></span>
<span id="cb160-7"><a href="#cb160-7" aria-hidden="true"></a></span>
<span id="cb160-8"><a href="#cb160-8" aria-hidden="true"></a></span>
<span id="cb160-9"><a href="#cb160-9" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb160-10"><a href="#cb160-10" aria-hidden="true"></a></span>
<span id="cb160-11"><a href="#cb160-11" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb160-12"><a href="#cb160-12" aria-hidden="true"></a>{</span>
<span id="cb160-13"><a href="#cb160-13" aria-hidden="true"></a>    <span class="dt">char</span> <span class="at">const</span> * someString = <span class="st">&quot;Eidenges</span><span class="sc">\xe4\xdf</span><span class="st">&quot;</span>;</span>
<span id="cb160-14"><a href="#cb160-14" aria-hidden="true"></a>    icu::UnicodeString someUString( someString, <span class="st">&quot;ISO-8859-1&quot;</span> );</span>
<span id="cb160-15"><a href="#cb160-15" aria-hidden="true"></a>    <span class="co">// Setting the locale explicitly here for completeness.</span></span>
<span id="cb160-16"><a href="#cb160-16" aria-hidden="true"></a>    <span class="co">// Usually you would use the user-specified system locale.</span></span>
<span id="cb160-17"><a href="#cb160-17" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; someUString.toLower( <span class="st">&quot;de_DE&quot;</span> ) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb160-18"><a href="#cb160-18" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; someUString.toUpper( <span class="st">&quot;de_DE&quot;</span> ) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb160-19"><a href="#cb160-19" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb160-20"><a href="#cb160-20" aria-hidden="true"></a>}</span></code></pre></div>
<p>Compile (with G++ in this example):</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true"></a>g++ -Wall example.cpp -licuuc -licuio</span></code></pre></div>
<p>This gives:</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true"></a>eidengesäß</span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true"></a>EIDENGESÄSS</span></code></pre></div>
<hr>
<p>[1] In 2017, the Council for German Orthography ruled that “ẞ” U+1E9E LATIN CAPITAL LETTER SHARP S could be used officially, as an option beside the traditional “SS” conversion to avoid ambiguity e.g. in passports (where names are capitalized). My beautiful go-to example, made obsolete by committee decision…</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-can-i-get-the-list-of-files-in-a-directory-using-c-or-c-score-806406-in-2018" class="level3">
<h3>26: How can I get the list of files in a directory using C or C++? (score <a href="https://stackoverflow.com/q/612097.html">806406</a> in 2018)</h3>
<section id="question-25" class="level4">
<h4>Question</h4>
<p>How can I determine the list of files in a directory from inside my C or C++ code?</p>
<p>I’m not allowed to execute the <code>ls</code> command and parse the results from within my program.</p>
</section>
<section id="answer-accepted-score-749" class="level4">
<h4>Answer accepted (score 749)</h4>
<p>In small and simple tasks I do not use boost, I use <strong>dirent.h</strong> which is also available for windows:</p>
<div class="sourceCode" id="cb163"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true"></a>DIR *dir;</span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true"></a><span class="kw">struct</span> dirent *ent;</span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true"></a><span class="cf">if</span> ((dir = opendir (<span class="st">&quot;c:</span><span class="sc">\\</span><span class="st">src</span><span class="sc">\\</span><span class="st">&quot;</span>)) != NULL) {</span>
<span id="cb163-4"><a href="#cb163-4" aria-hidden="true"></a>  <span class="co">/* print all the files and directories within directory */</span></span>
<span id="cb163-5"><a href="#cb163-5" aria-hidden="true"></a>  <span class="cf">while</span> ((ent = readdir (dir)) != NULL) {</span>
<span id="cb163-6"><a href="#cb163-6" aria-hidden="true"></a>    printf (<span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span>, ent-&gt;d_name);</span>
<span id="cb163-7"><a href="#cb163-7" aria-hidden="true"></a>  }</span>
<span id="cb163-8"><a href="#cb163-8" aria-hidden="true"></a>  closedir (dir);</span>
<span id="cb163-9"><a href="#cb163-9" aria-hidden="true"></a>} <span class="cf">else</span> {</span>
<span id="cb163-10"><a href="#cb163-10" aria-hidden="true"></a>  <span class="co">/* could not open directory */</span></span>
<span id="cb163-11"><a href="#cb163-11" aria-hidden="true"></a>  perror (<span class="st">&quot;&quot;</span>);</span>
<span id="cb163-12"><a href="#cb163-12" aria-hidden="true"></a>  <span class="cf">return</span> EXIT_FAILURE;</span>
<span id="cb163-13"><a href="#cb163-13" aria-hidden="true"></a>}</span></code></pre></div>
<p>It is just a small header file and does most of the simple stuff you need without using a big template-based approach like boost(no offence, I like boost!).</p>
<p>The author of the windows compatibility layer is Toni Ronkko. In Unix, it is a standard header.</p>
<p><strong>UPDATE 2017</strong>:</p>
<p>In C++17 there is now an official way to list files of your file system: <code>std::filesystem</code>. There is an excellent answer from <a href="https://stackoverflow.com/a/37494654/23264"><strong>Shreevardhan</strong></a> below with this source code:</p>
<div class="sourceCode" id="cb164"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true"></a></span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true"></a></span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb164-5"><a href="#cb164-5" aria-hidden="true"></a></span>
<span id="cb164-6"><a href="#cb164-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;filesystem&gt;</span></span>
<span id="cb164-7"><a href="#cb164-7" aria-hidden="true"></a><span class="kw">namespace</span> fs = <span class="bu">std::</span>filesystem;</span>
<span id="cb164-8"><a href="#cb164-8" aria-hidden="true"></a></span>
<span id="cb164-9"><a href="#cb164-9" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb164-10"><a href="#cb164-10" aria-hidden="true"></a>{</span>
<span id="cb164-11"><a href="#cb164-11" aria-hidden="true"></a>    <span class="bu">std::</span>string path = <span class="st">&quot;/path/to/directory&quot;</span>;</span>
<span id="cb164-12"><a href="#cb164-12" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="at">const</span> <span class="kw">auto</span> &amp; entry : fs::directory_iterator(path))</span>
<span id="cb164-13"><a href="#cb164-13" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; entry.path() &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb164-14"><a href="#cb164-14" aria-hidden="true"></a>}</span></code></pre></div>
</section>
<section id="answer-2-score-285" class="level4">
<h4>Answer 2 (score 285)</h4>
<p>C++17 now has a <a href="http://en.cppreference.com/w/cpp/filesystem/directory_iterator" rel="noreferrer"><code>std::filesystem::directory_iterator</code></a>, which can be used as</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true"></a></span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true"></a></span>
<span id="cb165-4"><a href="#cb165-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb165-5"><a href="#cb165-5" aria-hidden="true"></a></span>
<span id="cb165-6"><a href="#cb165-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;filesystem&gt;</span></span>
<span id="cb165-7"><a href="#cb165-7" aria-hidden="true"></a><span class="kw">namespace</span> fs = <span class="bu">std::</span>filesystem;</span>
<span id="cb165-8"><a href="#cb165-8" aria-hidden="true"></a></span>
<span id="cb165-9"><a href="#cb165-9" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb165-10"><a href="#cb165-10" aria-hidden="true"></a>    <span class="bu">std::</span>string path = <span class="st">&quot;/path/to/directory&quot;</span>;</span>
<span id="cb165-11"><a href="#cb165-11" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="at">const</span> <span class="kw">auto</span> &amp; entry : fs::directory_iterator(path))</span>
<span id="cb165-12"><a href="#cb165-12" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; entry.path() &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb165-13"><a href="#cb165-13" aria-hidden="true"></a>}</span></code></pre></div>
<p>Also, <a href="http://en.cppreference.com/w/cpp/filesystem/recursive_directory_iterator" rel="noreferrer"><code>std::filesystem::recursive_directory_iterator</code></a> can iterate the subdirectories as well.</p>
</section>
<section id="answer-3-score-227" class="level4">
<h4>Answer 3 (score 227)</h4>
<p>Unfortunately the C++ standard does not define a standard way of working with files and folders in this way.</p>
<p>Since there is no cross platform way, the best cross platform way is to use a library such as the <a href="http://www.boost.org/doc/libs/1_38_0/libs/filesystem/doc/index.htm" rel="noreferrer">boost filesystem module</a>.</p>
<p><strong>Cross platform boost method:</strong></p>
<blockquote>
<p>The following function, given a directory path and a file name, recursively searches the directory and its sub-directories for the file name, returning a bool, and if successful, the path to the file that was found.</p>
<div class="sourceCode" id="cb166"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true"></a><span class="dt">bool</span> find_file(<span class="at">const</span> path &amp; dir_path,         <span class="co">// in this directory,</span></span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true"></a>               <span class="at">const</span> <span class="bu">std::</span>string &amp; file_name, <span class="co">// search for this name,</span></span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true"></a>               path &amp; path_found)             <span class="co">// placing path here if found</span></span>
<span id="cb166-4"><a href="#cb166-4" aria-hidden="true"></a>{</span>
<span id="cb166-5"><a href="#cb166-5" aria-hidden="true"></a>    <span class="cf">if</span> (!exists(dir_path)) </span>
<span id="cb166-6"><a href="#cb166-6" aria-hidden="true"></a>        <span class="cf">return</span> <span class="kw">false</span>;</span>
<span id="cb166-7"><a href="#cb166-7" aria-hidden="true"></a></span>
<span id="cb166-8"><a href="#cb166-8" aria-hidden="true"></a>    directory_iterator end_itr; <span class="co">// default construction yields past-the-end</span></span>
<span id="cb166-9"><a href="#cb166-9" aria-hidden="true"></a></span>
<span id="cb166-10"><a href="#cb166-10" aria-hidden="true"></a>    <span class="cf">for</span> (directory_iterator itr(dir_path); itr != end_itr; ++itr)</span>
<span id="cb166-11"><a href="#cb166-11" aria-hidden="true"></a>    {</span>
<span id="cb166-12"><a href="#cb166-12" aria-hidden="true"></a>        <span class="cf">if</span> (is_directory(itr-&gt;status()))</span>
<span id="cb166-13"><a href="#cb166-13" aria-hidden="true"></a>        {</span>
<span id="cb166-14"><a href="#cb166-14" aria-hidden="true"></a>            <span class="cf">if</span> (find_file(itr-&gt;path(), file_name, path_found)) </span>
<span id="cb166-15"><a href="#cb166-15" aria-hidden="true"></a>                <span class="cf">return</span> <span class="kw">true</span>;</span>
<span id="cb166-16"><a href="#cb166-16" aria-hidden="true"></a>        }</span>
<span id="cb166-17"><a href="#cb166-17" aria-hidden="true"></a>        <span class="cf">else</span> <span class="cf">if</span> (itr-&gt;leaf() == file_name) <span class="co">// see below</span></span>
<span id="cb166-18"><a href="#cb166-18" aria-hidden="true"></a>        {</span>
<span id="cb166-19"><a href="#cb166-19" aria-hidden="true"></a>            path_found = itr-&gt;path();</span>
<span id="cb166-20"><a href="#cb166-20" aria-hidden="true"></a>            <span class="cf">return</span> <span class="kw">true</span>;</span>
<span id="cb166-21"><a href="#cb166-21" aria-hidden="true"></a>        }</span>
<span id="cb166-22"><a href="#cb166-22" aria-hidden="true"></a>    }</span>
<span id="cb166-23"><a href="#cb166-23" aria-hidden="true"></a>    <span class="cf">return</span> <span class="kw">false</span>;</span>
<span id="cb166-24"><a href="#cb166-24" aria-hidden="true"></a>}</span></code></pre></div>
</blockquote>
<p>Source from the boost page mentioned above.</p>
<p><strong>For Unix/Linux based systems:</strong></p>
<p>You can use <a href="http://www.manpagez.com/man/3/opendir/" rel="noreferrer">opendir</a> / <a href="http://www.manpagez.com/man/3/readdir/" rel="noreferrer">readdir</a> / <a href="http://www.manpagez.com/man/3/closedir/" rel="noreferrer">closedir</a>.</p>
<blockquote>
<p>Sample code which searches a directory for entry ``name’’ is:</p>
<div class="sourceCode" id="cb167"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true"></a>len = strlen(name);</span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true"></a>dirp = opendir(<span class="st">&quot;.&quot;</span>);</span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true"></a><span class="cf">while</span> ((dp = readdir(dirp)) != NULL)</span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true"></a>        <span class="cf">if</span> (dp-&gt;d_namlen == len &amp;&amp; !strcmp(dp-&gt;d_name, name)) {</span>
<span id="cb167-5"><a href="#cb167-5" aria-hidden="true"></a>                (<span class="dt">void</span>)closedir(dirp);</span>
<span id="cb167-6"><a href="#cb167-6" aria-hidden="true"></a>                <span class="cf">return</span> FOUND;</span>
<span id="cb167-7"><a href="#cb167-7" aria-hidden="true"></a>        }</span>
<span id="cb167-8"><a href="#cb167-8" aria-hidden="true"></a>(<span class="dt">void</span>)closedir(dirp);</span>
<span id="cb167-9"><a href="#cb167-9" aria-hidden="true"></a><span class="cf">return</span> NOT_FOUND;</span></code></pre></div>
</blockquote>
<p>Source code from the above man pages.</p>
<p><strong>For a windows based systems:</strong></p>
<p>You can use the Win32 API <a href="http://msdn.microsoft.com/en-us/library/aa364418(VS.85).aspx" rel="noreferrer">FindFirstFile</a> / <a href="http://msdn.microsoft.com/en-us/library/aa364428(VS.85).aspx" rel="noreferrer">FindNextFile</a> / <a href="http://msdn.microsoft.com/en-us/library/aa364413(VS.85).aspx" rel="noreferrer">FindClose</a> functions.</p>
<blockquote>
<p>The following C++ example shows you a minimal use of FindFirstFile.</p>
<div class="sourceCode" id="cb168"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true"></a></span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;windows.h&gt;</span></span>
<span id="cb168-3"><a href="#cb168-3" aria-hidden="true"></a></span>
<span id="cb168-4"><a href="#cb168-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;tchar.h&gt;</span></span>
<span id="cb168-5"><a href="#cb168-5" aria-hidden="true"></a></span>
<span id="cb168-6"><a href="#cb168-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb168-7"><a href="#cb168-7" aria-hidden="true"></a></span>
<span id="cb168-8"><a href="#cb168-8" aria-hidden="true"></a><span class="dt">void</span> _tmain(<span class="dt">int</span> argc, TCHAR *argv[])</span>
<span id="cb168-9"><a href="#cb168-9" aria-hidden="true"></a>{</span>
<span id="cb168-10"><a href="#cb168-10" aria-hidden="true"></a>   WIN32_FIND_DATA FindFileData;</span>
<span id="cb168-11"><a href="#cb168-11" aria-hidden="true"></a>   HANDLE hFind;</span>
<span id="cb168-12"><a href="#cb168-12" aria-hidden="true"></a></span>
<span id="cb168-13"><a href="#cb168-13" aria-hidden="true"></a>   <span class="cf">if</span>( argc != <span class="dv">2</span> )</span>
<span id="cb168-14"><a href="#cb168-14" aria-hidden="true"></a>   {</span>
<span id="cb168-15"><a href="#cb168-15" aria-hidden="true"></a>      _tprintf(TEXT(<span class="st">&quot;Usage: </span><span class="sc">%s</span><span class="st"> [target_file]</span><span class="sc">\n</span><span class="st">&quot;</span>), argv[<span class="dv">0</span>]);</span>
<span id="cb168-16"><a href="#cb168-16" aria-hidden="true"></a>      <span class="cf">return</span>;</span>
<span id="cb168-17"><a href="#cb168-17" aria-hidden="true"></a>   }</span>
<span id="cb168-18"><a href="#cb168-18" aria-hidden="true"></a></span>
<span id="cb168-19"><a href="#cb168-19" aria-hidden="true"></a>   _tprintf (TEXT(<span class="st">&quot;Target file is </span><span class="sc">%s\n</span><span class="st">&quot;</span>), argv[<span class="dv">1</span>]);</span>
<span id="cb168-20"><a href="#cb168-20" aria-hidden="true"></a>   hFind = FindFirstFile(argv[<span class="dv">1</span>], &amp;FindFileData);</span>
<span id="cb168-21"><a href="#cb168-21" aria-hidden="true"></a>   <span class="cf">if</span> (hFind == INVALID_HANDLE_VALUE) </span>
<span id="cb168-22"><a href="#cb168-22" aria-hidden="true"></a>   {</span>
<span id="cb168-23"><a href="#cb168-23" aria-hidden="true"></a>      printf (<span class="st">&quot;FindFirstFile failed (</span><span class="sc">%d</span><span class="st">)</span><span class="sc">\n</span><span class="st">&quot;</span>, GetLastError());</span>
<span id="cb168-24"><a href="#cb168-24" aria-hidden="true"></a>      <span class="cf">return</span>;</span>
<span id="cb168-25"><a href="#cb168-25" aria-hidden="true"></a>   } </span>
<span id="cb168-26"><a href="#cb168-26" aria-hidden="true"></a>   <span class="cf">else</span> </span>
<span id="cb168-27"><a href="#cb168-27" aria-hidden="true"></a>   {</span>
<span id="cb168-28"><a href="#cb168-28" aria-hidden="true"></a>      _tprintf (TEXT(<span class="st">&quot;The first file found is </span><span class="sc">%s\n</span><span class="st">&quot;</span>), </span>
<span id="cb168-29"><a href="#cb168-29" aria-hidden="true"></a>                FindFileData.cFileName);</span>
<span id="cb168-30"><a href="#cb168-30" aria-hidden="true"></a>      FindClose(hFind);</span>
<span id="cb168-31"><a href="#cb168-31" aria-hidden="true"></a>   }</span>
<span id="cb168-32"><a href="#cb168-32" aria-hidden="true"></a>}</span></code></pre></div>
</blockquote>
<p>Source code from the above msdn pages.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="what-does-int-argc-char-argv-mean-score-798351-in-2018" class="level3">
<h3>27: What does int argc, char *argv[] mean? (score <a href="https://stackoverflow.com/q/3024197.html">798351</a> in 2018)</h3>
<section id="question-26" class="level4">
<h4>Question</h4>
<p>In many C++ IDE’s and compilers, when it generates the main function for you, it looks like this:</p>
<div class="sourceCode" id="cb169"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true"></a><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])</span></code></pre></div>
<p>When I code C++ without an IDE, just with a command line compiler, I type:</p>
<div class="sourceCode" id="cb170"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true"></a><span class="dt">int</span> main()</span></code></pre></div>
<p>without any parameters. What does this mean, and is it vital to my program?</p>
</section>
<section id="answer-accepted-score-609" class="level4">
<h4>Answer accepted (score 609)</h4>
<p><code>argv</code> and <code>argc</code> are how command line arguments are passed to <code>main()</code> in C and C++.</p>
<p><code>argc</code> will be the number of strings pointed to by <code>argv</code>. This will (in practice) be 1 plus the number of arguments, as virtually all implementations will prepend the name of the program to the array.</p>
<p>The variables are named <code>argc</code> (<em>argument count</em>) and <code>argv</code> (<em>argument vector</em>) by convention, but they can be given any valid identifier: <code>int main(int num_args, char** arg_strings)</code> is equally valid.</p>
<p>They can also be omitted entirely, yielding <code>int main()</code>, if you do not intend to process command line arguments.</p>
<p>Try the following program:</p>
<div class="sourceCode" id="cb171"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true"></a></span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb171-3"><a href="#cb171-3" aria-hidden="true"></a></span>
<span id="cb171-4"><a href="#cb171-4" aria-hidden="true"></a><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>** argv) {</span>
<span id="cb171-5"><a href="#cb171-5" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Have &quot;</span> &lt;&lt; argc &lt;&lt; <span class="st">&quot; arguments:&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb171-6"><a href="#cb171-6" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; argc; ++i) {</span>
<span id="cb171-7"><a href="#cb171-7" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; argv[i] &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb171-8"><a href="#cb171-8" aria-hidden="true"></a>    }</span>
<span id="cb171-9"><a href="#cb171-9" aria-hidden="true"></a>}</span></code></pre></div>
<p>Running it with <code>./test a1 b2 c3</code> will output</p>
<div class="sourceCode" id="cb172"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true"></a>Have <span class="dv">4</span> arguments:</span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true"></a>./test</span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true"></a>a1</span>
<span id="cb172-4"><a href="#cb172-4" aria-hidden="true"></a>b2</span>
<span id="cb172-5"><a href="#cb172-5" aria-hidden="true"></a>c3</span></code></pre></div>
</section>
<section id="answer-2-score-50" class="level4">
<h4>Answer 2 (score 50)</h4>
<p><code>argc</code> is the number of arguments being passed into your program from the command line and <code>argv</code> is the array of arguments.</p>
<p>You can loop through the arguments knowing the number of them like:</p>
<div class="sourceCode" id="cb173"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true"></a><span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; argc; i++)</span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true"></a>{</span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true"></a>    <span class="co">// argv[i] is the argument at index i</span></span>
<span id="cb173-4"><a href="#cb173-4" aria-hidden="true"></a>}</span></code></pre></div>
</section>
<section id="answer-3-score-17" class="level4">
<h4>Answer 3 (score 17)</h4>
<p>
<p>Suppose you run your program thus (using <code>sh</code> syntax):</p>
<div class="sourceCode" id="cb174"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true"></a>myprog arg1 arg2 <span class="ch">&#39;a</span><span class="er">rg 3</span><span class="ch">&#39;</span></span></code></pre></div>
<p>If you declared your main as <code>int main(int argc, char *argv[])</code>, then (in most environments), your <code>main()</code> will be called as if like:</p>
<div class="sourceCode" id="cb175"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true"></a>p = { <span class="st">&quot;myprog&quot;</span>, <span class="st">&quot;arg1&quot;</span>, <span class="st">&quot;arg2&quot;</span>, <span class="st">&quot;arg 3&quot;</span>, NULL };</span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true"></a>exit(main(<span class="dv">4</span>, p));</span></code></pre></div>
<p>However, if you declared your main as <code>int main()</code>, it will be called something like</p>
<div class="sourceCode" id="cb176"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true"></a>exit(main());</span></code></pre></div>
<p>and you don’t get the arguments passed.</p>
<p>Two additional things to note:</p>
<ol>
<li>
These are the only two standard-mandated signatures for <code>main</code>. If a particular platform accepts extra arguments or a different return type, then that’s an extension and should not be relied upon in a portable program.
</li>
<li>
<code>*argv[]</code> and <code>**argv</code> are exactly equivalent, so you can write <code>int main(int argc, char *argv[])</code> as <code>int main(int argc, char **argv)</code>.
</li>
</ol>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="what-does-the-explicit-keyword-mean-score-795711-in-2018" class="level3">
<h3>28: What does the explicit keyword mean? (score <a href="https://stackoverflow.com/q/121162.html">795711</a> in 2018)</h3>
<section id="question-27" class="level4">
<h4>Question</h4>
<p>What does the <code>explicit</code> keyword mean in C++?</p>
</section>
<section id="answer-accepted-score-3129" class="level4">
<h4>Answer accepted (score 3129)</h4>
<p>The compiler is allowed to make one implicit conversion to resolve the parameters to a function. What this means is that the compiler can use constructors callable with a <strong>single parameter</strong> to convert from one type to another in order to get the right type for a parameter.</p>
<p>Here’s an example class with a constructor that can be used for implicit conversions:</p>
<div class="sourceCode" id="cb177"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true"></a><span class="kw">class</span> Foo</span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true"></a>{</span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb177-4"><a href="#cb177-4" aria-hidden="true"></a>  <span class="co">// single parameter constructor, can be used as an implicit conversion</span></span>
<span id="cb177-5"><a href="#cb177-5" aria-hidden="true"></a>  Foo (<span class="dt">int</span> foo) : <span class="va">m_foo</span> (foo) </span>
<span id="cb177-6"><a href="#cb177-6" aria-hidden="true"></a>  {</span>
<span id="cb177-7"><a href="#cb177-7" aria-hidden="true"></a>  }</span>
<span id="cb177-8"><a href="#cb177-8" aria-hidden="true"></a></span>
<span id="cb177-9"><a href="#cb177-9" aria-hidden="true"></a>  <span class="dt">int</span> GetFoo () { <span class="cf">return</span> <span class="va">m_foo</span>; }</span>
<span id="cb177-10"><a href="#cb177-10" aria-hidden="true"></a></span>
<span id="cb177-11"><a href="#cb177-11" aria-hidden="true"></a><span class="kw">private</span>:</span>
<span id="cb177-12"><a href="#cb177-12" aria-hidden="true"></a>  <span class="dt">int</span> <span class="va">m_foo</span>;</span>
<span id="cb177-13"><a href="#cb177-13" aria-hidden="true"></a>};</span></code></pre></div>
<p>Here’s a simple function that takes a <code>Foo</code> object:</p>
<div class="sourceCode" id="cb178"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true"></a><span class="dt">void</span> DoBar (Foo foo)</span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true"></a>{</span>
<span id="cb178-3"><a href="#cb178-3" aria-hidden="true"></a>  <span class="dt">int</span> i = foo.GetFoo ();</span>
<span id="cb178-4"><a href="#cb178-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>and here’s where the <code>DoBar</code> function is called.</p>
<div class="sourceCode" id="cb179"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true"></a><span class="dt">int</span> main ()</span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true"></a>{</span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true"></a>  DoBar (<span class="dv">42</span>);</span>
<span id="cb179-4"><a href="#cb179-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>The argument is not a <code>Foo</code> object, but an <code>int</code>. However, there exists a constructor for <code>Foo</code> that takes an <code>int</code> so this constructor can be used to convert the parameter to the correct type.</p>
<p>The compiler is allowed to do this once for each parameter.</p>
<p>Prefixing the <code>explicit</code> keyword to the constructor prevents the compiler from using that constructor for implicit conversions. Adding it to the above class will create a compiler error at the function call <code>DoBar (42)</code>. It is now necessary to call for conversion explicitly with <code>DoBar (Foo (42))</code></p>
<p>The reason you might want to do this is to avoid accidental construction that can hide bugs. Contrived example:</p>
<ul>
<li>
You have a <code>MyString(int size)</code> class with a constructor that constructs a string of the given size. You have a function <code>print(const MyString&amp;amp;)</code>, and you call <code>print(3)</code> (when you <em>actually</em> intended to call <code>print("3")</code>). You expect it to print “3”, but it prints an empty string of length 3 instead.
</li>
</ul>
</section>
<section id="answer-2-score-1078" class="level4">
<h4>Answer 2 (score 1078)</h4>
<p>Suppose, you have a class <code>String</code>:</p>
<div class="sourceCode" id="cb180"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true"></a><span class="kw">class</span> String {</span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true"></a>    String(<span class="dt">int</span> n); <span class="co">// allocate n bytes to the String object</span></span>
<span id="cb180-4"><a href="#cb180-4" aria-hidden="true"></a>    String(<span class="at">const</span> <span class="dt">char</span> *p); <span class="co">// initializes object with char *p</span></span>
<span id="cb180-5"><a href="#cb180-5" aria-hidden="true"></a>};</span></code></pre></div>
<p>Now, if you try:</p>
<div class="sourceCode" id="cb181"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true"></a>String mystring = <span class="ch">&#39;x&#39;</span>;</span></code></pre></div>
<p>The character <code>'x'</code> will be implicitly converted to <code>int</code> and then the <code>String(int)</code> constructor will be called. But, this is not what the user might have intended. So, to prevent such conditions, we shall define the constructor as <code>explicit</code>:</p>
<div class="sourceCode" id="cb182"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true"></a><span class="kw">class</span> String {</span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb182-3"><a href="#cb182-3" aria-hidden="true"></a>    <span class="kw">explicit</span> String (<span class="dt">int</span> n); <span class="co">//allocate n bytes</span></span>
<span id="cb182-4"><a href="#cb182-4" aria-hidden="true"></a>    String(<span class="at">const</span> <span class="dt">char</span> *p); <span class="co">// initialize sobject with string p</span></span>
<span id="cb182-5"><a href="#cb182-5" aria-hidden="true"></a>};</span></code></pre></div>
</section>
<section id="answer-3-score-151" class="level4">
<h4>Answer 3 (score 151)</h4>
<p>In C++, a constructor with only one required parameter is considered an implicit conversion function. It converts the parameter type to the class type. Whether this is a good thing or not depends on the semantics of the constructor.</p>
<p>For example, if you have a string class with constructor <code>String(const char* s)</code>, that’s probably exactly what you want. You can pass a <code>const char*</code> to a function expecting a <code>String</code>, and the compiler will automatically construct a temporary <code>String</code> object for you.</p>
<p>On the other hand, if you have a buffer class whose constructor <code>Buffer(int size)</code> takes the size of the buffer in bytes, you probably don’t want the compiler to quietly turn <code>int</code>s into <code>Buffer</code>s. To prevent that, you declare the constructor with the <code>explicit</code> keyword:</p>
<div class="sourceCode" id="cb183"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true"></a><span class="kw">class</span> Buffer { <span class="kw">explicit</span> Buffer(<span class="dt">int</span> size); ... }</span></code></pre></div>
<p>That way,</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true"></a><span class="dt">void</span> useBuffer(Buffer&amp; buf);</span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true"></a>useBuffer(<span class="dv">4</span>);</span></code></pre></div>
<p>becomes a compile-time error. If you want to pass a temporary <code>Buffer</code> object, you have to do so explicitly:</p>
<div class="sourceCode" id="cb185"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true"></a>useBuffer(Buffer(<span class="dv">4</span>));</span></code></pre></div>
<p>In summary, if your single-parameter constructor converts the parameter into an object of your class, you probably don’t want to use the <code>explicit</code> keyword. But if you have a constructor that simply happens to take a single parameter, you should declare it as <code>explicit</code> to prevent the compiler from surprising you with unexpected conversions.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-to-convert-a-char-array-to-a-string-score-781170-in-2014" class="level3">
<h3>29: How to convert a char array to a string? (score <a href="https://stackoverflow.com/q/8960087.html">781170</a> in 2014)</h3>
<section id="question-28" class="level4">
<h4>Question</h4>
<p>Converting a C++ <code>string</code> to a char array is pretty straightorward using the <code>c_str</code> function of string and then doing <code>strcpy</code>. However, how to do the opposite?</p>
<p>
I have a char array like: <code>char arr[ ] = "This is a test";</code> to be converted back to: <code>string str = "This is a test</code>.
</p>
</section>
<section id="answer-accepted-score-351" class="level4">
<h4>Answer accepted (score 351)</h4>
<p>The <code>string</code> class has a constructor that takes a NULL-terminated C-string:</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true"></a><span class="dt">char</span> arr[ ] = <span class="st">&quot;This is a test&quot;</span>;</span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true"></a></span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true"></a>string str(arr);</span>
<span id="cb186-4"><a href="#cb186-4" aria-hidden="true"></a></span>
<span id="cb186-5"><a href="#cb186-5" aria-hidden="true"></a></span>
<span id="cb186-6"><a href="#cb186-6" aria-hidden="true"></a><span class="co">//  You can also assign directly to a string.</span></span>
<span id="cb186-7"><a href="#cb186-7" aria-hidden="true"></a>str = <span class="st">&quot;This is another string&quot;</span>;</span>
<span id="cb186-8"><a href="#cb186-8" aria-hidden="true"></a></span>
<span id="cb186-9"><a href="#cb186-9" aria-hidden="true"></a><span class="co">// or</span></span>
<span id="cb186-10"><a href="#cb186-10" aria-hidden="true"></a>str = arr;</span></code></pre></div>
</section>
<section id="answer-2-score-54-1" class="level4">
<h4>Answer 2 (score 54)</h4>
<p>Another solution might look like this,</p>
<div class="sourceCode" id="cb187"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true"></a><span class="dt">char</span> arr[] = <span class="st">&quot;mom&quot;</span>;</span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true"></a><span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hi &quot;</span> &lt;&lt; <span class="bu">std::</span>string(arr);</span></code></pre></div>
<p>which avoids using an extra variable.</p>
</section>
<section id="answer-3-score-27" class="level4">
<h4>Answer 3 (score 27)</h4>
<p>There is a small problem missed in top-voted answers. Namely, character array may contain 0. If we will use constructor with single parameter as pointed above we will lose some data. The possible solution is:</p>
<div class="sourceCode" id="cb188"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true"></a>cout &lt;&lt; string(<span class="st">&quot;123</span><span class="sc">\0</span><span class="st"> 123&quot;</span>) &lt;&lt; endl;</span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true"></a>cout &lt;&lt; string(<span class="st">&quot;123</span><span class="sc">\0</span><span class="st"> 123&quot;</span>, <span class="dv">8</span>) &lt;&lt; endl;</span></code></pre></div>
<p>Output is:</p>
<blockquote>
<p>
123<br> 123 123
</p>
</blockquote>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="what-is-the-easiest-way-to-initialize-a-stdvector-with-hardcoded-elements-score-775328-in-2019" class="level3">
<h3>30: What is the easiest way to initialize a std::vector with hardcoded elements? (score <a href="https://stackoverflow.com/q/2236197.html">775328</a> in 2019)</h3>
<section id="question-29" class="level4">
<h4>Question</h4>
<p>I can create an array and initialize it like this:</p>
<div class="sourceCode" id="cb189"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true"></a><span class="dt">int</span> a[] = {<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span>};</span></code></pre></div>
<p>How do I create a <code>std::vector</code> and initialize it similarly elegant?</p>
<p>The best way I know is:</p>
<div class="sourceCode" id="cb190"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; ints;</span>
<span id="cb190-2"><a href="#cb190-2" aria-hidden="true"></a></span>
<span id="cb190-3"><a href="#cb190-3" aria-hidden="true"></a>ints.push_back(<span class="dv">10</span>);</span>
<span id="cb190-4"><a href="#cb190-4" aria-hidden="true"></a>ints.push_back(<span class="dv">20</span>);</span>
<span id="cb190-5"><a href="#cb190-5" aria-hidden="true"></a>ints.push_back(<span class="dv">30</span>);</span></code></pre></div>
<p>Is there a better way?</p>
</section>
<section id="answer-accepted-score-528" class="level4">
<h4>Answer accepted (score 528)</h4>
<p>One method would be to use the array to initialize the vector</p>
<div class="sourceCode" id="cb191"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true"></a><span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> arr[] = {<span class="dv">16</span>,<span class="dv">2</span>,<span class="dv">77</span>,<span class="dv">29</span>};</span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true"></a>vector&lt;<span class="dt">int</span>&gt; vec (arr, arr + <span class="kw">sizeof</span>(arr) / <span class="kw">sizeof</span>(arr[<span class="dv">0</span>]) );</span></code></pre></div>
</section>
<section id="answer-2-score-602" class="level4">
<h4>Answer 2 (score 602)</h4>
<p>If your compiler supports C++11, you can simply do:</p>
<div class="sourceCode" id="cb192"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>};</span></code></pre></div>
<p>This is available in GCC <a href="http://gcc.gnu.org/projects/cxx0x.html" rel="noreferrer">as of version 4.4</a>. Unfortunately, VC++ 2010 seems to be lagging behind in this respect.</p>
<p>Alternatively, the <a href="http://www.boost.org/doc/libs/1_42_0/libs/assign/doc/index.html" rel="noreferrer">Boost.Assign</a> library uses non-macro magic to allow the following:</p>
<div class="sourceCode" id="cb193"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true"></a></span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;boost/assign/list_of.hpp&gt;</span></span>
<span id="cb193-3"><a href="#cb193-3" aria-hidden="true"></a>...</span>
<span id="cb193-4"><a href="#cb193-4" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = <span class="ex">boost::</span>assign<span class="ex">::</span>list_of(<span class="dv">1</span>)(<span class="dv">2</span>)(<span class="dv">3</span>)(<span class="dv">4</span>);</span></code></pre></div>
<p>Or:</p>
<div class="sourceCode" id="cb194"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true"></a></span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;boost/assign/std/vector.hpp&gt;</span></span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> <span class="ex">boost::</span>assign;</span>
<span id="cb194-4"><a href="#cb194-4" aria-hidden="true"></a>...</span>
<span id="cb194-5"><a href="#cb194-5" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v;</span>
<span id="cb194-6"><a href="#cb194-6" aria-hidden="true"></a>v += <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>;</span></code></pre></div>
<p>But keep in mind that this has some overhead (basically, <code>list_of</code> constructs a <code>std::deque</code> under the hood) so for performance-critical code you’d be better off doing as Yacoby says.</p>
</section>
<section id="answer-3-score-83" class="level4">
<h4>Answer 3 (score 83)</h4>
<p>If you can, use the modern C++[11,14,17,…] way:</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; vec = {<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">30</span>};</span></code></pre></div>
<p>The old way of looping over a variable-length array or using <code>sizeof()</code> is truly terrible on the eyes and completely unnecessary in terms of mental overhead. Yuck.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="why-is-using-namespace-std-considered-bad-practice-score-770478-in-2019" class="level3">
<h3>31: Why is “using namespace std;” considered bad practice? (score <a href="https://stackoverflow.com/q/1452721.html">770478</a> in 2019)</h3>
<section id="question-30" class="level4">
<h4>Question</h4>
<p>I’ve been told by others that writing <code>using namespace std;</code> in code is wrong, and that I should use <code>std::cout</code> and <code>std::cin</code> directly instead.</p>
<p>Why is <code>using namespace std;</code> considered a bad practice? Is it inefficient or does it risk declaring ambiguous variables (variables that share the same name as a function in <code>std</code> namespace)? Does it impact performance?</p>
</section>
<section id="answer-accepted-score-2068" class="level4">
<h4>Answer accepted (score 2068)</h4>
<p>This is not related to performance at all. But consider this: you are using two libraries called Foo and Bar:</p>
<div class="sourceCode" id="cb196"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> foo;</span>
<span id="cb196-2"><a href="#cb196-2" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> bar;</span></code></pre></div>
<p>Everything works fine, and you can call <code>Blah()</code> from Foo and <code>Quux()</code> from Bar without problems. But one day you upgrade to a new version of Foo 2.0, which now offers a function called <code>Quux()</code>. Now you’ve got a conflict: Both Foo 2.0 and Bar import <code>Quux()</code> into your global namespace. This is going to take some effort to fix, especially if the function parameters happen to match.</p>
<p>If you had used <code>foo::Blah()</code> and <code>bar::Quux()</code>, then the introduction of <code>foo::Quux()</code> would have been a non-event.</p>
</section>
<section id="answer-2-score-1318" class="level4">
<h4>Answer 2 (score 1318)</h4>
<p>I agree with everything <a href="https://stackoverflow.com/questions/1452721/1452738
#1452738">Greg wrote</a>, but I’d like to add: <strong><em>It can even get worse than Greg said!</em></strong></p>
<p>Library Foo 2.0 could introduce a function, <code>Quux()</code>, that is an unambiguously better match for some of your calls to <code>Quux()</code> than the <code>bar::Quux()</code> your code called for years. Then your <strong><em>code still compiles</em></strong>, but <strong><em>it silently calls the wrong function</em></strong> and does god-knows-what. That’s about as bad as things can get.</p>
<p>Keep in mind that the <code>std</code> namespace has tons of identifiers, many of which are <em>very</em> common ones (think <code>list</code>, <code>sort</code>, <code>string</code>, <code>iterator</code>, etc.) which are very likely to appear in other code, too.</p>
<p>
If you consider this unlikely: There was <a href="https://stackoverflow.com/a/2712125/140719">a question asked</a> here on Stack Overflow where pretty much exactly this happened (wrong function called due to omitted <code>std::</code> prefix) about half a year after I gave this answer. <a href="https://stackoverflow.com/questions/13402789/">Here</a> is another, more recent example of such a question. So this is a real problem.
</p>
<hr>
<p>Here’s one more data point: Many, many years ago, I also used to find it annoying having to prefix everything from the standard library with <code>std::</code>. Then I worked in a project where it was decided at the start that both <code>using</code> directives and declarations are banned except for function scopes. Guess what? It took most of us very few weeks to get used to writing the prefix, and after a few more weeks most of us even agreed that it actually made the code <em>more readable</em>. There’s a reason for that: <strong><em>Whether you like shorter or longer prose is subjective, but the prefixes objectively add clarity to the code.</em></strong> Not only the compiler, but you, too, find it easier to see which identifier is referred to.</p>
<p>In a decade, that project grew to have several million lines of code. Since these discussions come up again and again, I once was curious how often the (allowed) function-scope <code>using</code> actually was used in the project. I grep’d the sources for it and only found one or two dozen places where it was used. To me this indicates that, once tried, developers don’t find <code>std::</code> painful enough to employ using directives even once every 100 kLoC even where it was allowed to be used.</p>
<hr>
<p>Bottom line: Explicitly prefixing everything doesn’t do any harm, takes very little getting used to, and has objective advantages. In particular, it makes the code easier to interpret by the compiler and by human readers — and that should probably be the main goal when writing code.</p>
</section>
<section id="answer-3-score-383" class="level4">
<h4>Answer 3 (score 383)</h4>
<p>The problem with putting <code>using namespace</code> in the header files of your classes is that it forces anyone who wants to use your classes (by including your header files) to also be ‘using’ (i.e. seeing everything in) those other namespaces.</p>
<p>However, you may feel free to put a using statement in your (private) *.cpp files.</p>
<hr>
<p>Beware that some people disagree with my saying “feel free” like this – because although a using statement in a cpp file is <em>better</em> than in a header (because it doesn’t affect people who include your header file), they think it’s still not <em>good</em> (because depending on the code it could make the implementation of the class more difficult to maintain). <a href="https://isocpp.org/wiki/faq/coding-standards
#using-namespace-std" rel="noreferrer">This FAQ topic</a> says,</p>
<blockquote>
The using-directive exists for legacy C++ code and to ease the transition to namespaces, but you probably shouldn’t use it on a regular basis, at least not in your new C++ code.
</blockquote>
<p>The FAQ suggests two alternatives:</p>
<ul>
<li>
<p>
A using-declaration:
</p>
<div class="sourceCode" id="cb197"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true"></a><span class="kw">using</span> <span class="bu">std::</span>cout; <span class="co">// a using-declaration lets you use cout without qualification</span></span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true"></a>cout &lt;&lt; <span class="st">&quot;Values:&quot;</span>;</span>
<span id="cb197-3"><a href="#cb197-3" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb197-4"><a href="#cb197-4" aria-hidden="true"></a>&lt;li&gt;&lt;p&gt;Just typing <span class="bu">std::</span>&lt;/p&gt;</span>
<span id="cb197-5"><a href="#cb197-5" aria-hidden="true"></a></span>
<span id="cb197-6"><a href="#cb197-6" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb197-7"><a href="#cb197-7" aria-hidden="true"></a><span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Values:&quot;</span>;</span>
<span id="cb197-8"><a href="#cb197-8" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb197-9"><a href="#cb197-9" aria-hidden="true"></a>&lt;/ul&gt;</span>
<span id="cb197-10"><a href="#cb197-10" aria-hidden="true"></a></span>
<span id="cb197-11"><a href="#cb197-11" aria-hidden="true"></a>&lt;/b&gt; &lt;/em&gt; &lt;/i&gt; &lt;/small&gt; &lt;/strong&gt; &lt;/sub&gt; &lt;/sup&gt;</span>
<span id="cb197-12"><a href="#cb197-12" aria-hidden="true"></a></span>
<span id="cb197-13"><a href="#cb197-13" aria-hidden="true"></a></span>
<span id="cb197-14"><a href="#cb197-14" aria-hidden="true"></a><span class="pp">#</span><span class="er">## 32: std::string formatting like sprintf (score [756090](https://stackoverflow.com/q/2342162.html) in 2015)</span></span>
<span id="cb197-15"><a href="#cb197-15" aria-hidden="true"></a></span>
<span id="cb197-16"><a href="#cb197-16" aria-hidden="true"></a></span>
<span id="cb197-17"><a href="#cb197-17" aria-hidden="true"></a><span class="pp">#</span><span class="er">### Question</span></span>
<span id="cb197-18"><a href="#cb197-18" aria-hidden="true"></a>I have to format &lt;a href=<span class="st">&quot;http://en.cppreference.com/w/cpp/string/basic_string&quot;</span>&gt;<span class="er">`</span><span class="bu">std::</span>string<span class="bu">`</span>&lt;/a&gt; with &lt;a href=<span class="st">&quot;http://en.cppreference.com/w/cpp/io/c/fprintf&quot;</span>&gt;<span class="er">`</span>sprintf<span class="er">`</span>&lt;/a&gt; <span class="kw">and</span> send it into file stream. How can I <span class="cf">do</span> <span class="kw">this</span>?  </span>
<span id="cb197-19"><a href="#cb197-19" aria-hidden="true"></a></span>
<span id="cb197-20"><a href="#cb197-20" aria-hidden="true"></a></span>
<span id="cb197-21"><a href="#cb197-21" aria-hidden="true"></a><span class="pp">#</span><span class="er">### Answer accepted (score 300)</span></span>
<span id="cb197-22"><a href="#cb197-22" aria-hidden="true"></a>You can<span class="ch">&#39;t</span><span class="er"> do it directly, because you don</span><span class="ch">&#39;</span>t have write access to the underlying buffer (until C++<span class="dv">11</span>; see Dietrich Epp<span class="ch">&#39;s</span><span class="er"> &lt;a href=&quot;https://stackoverflow.com/questions/2342162/stdstring-formatting-like-sprintf</span></span>
<span id="cb197-23"><a href="#cb197-23" aria-hidden="true"></a><span class="pp">#</span><span class="er">comment61134428_2342176&quot;&gt;comment&lt;/a&gt;). You&#39;ll have to do it first in a c-string, then copy it into a std::string:  </span></span>
<span id="cb197-24"><a href="#cb197-24" aria-hidden="true"></a></span>
<span id="cb197-25"><a href="#cb197-25" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb197-26"><a href="#cb197-26" aria-hidden="true"></a>  <span class="dt">char</span> buff[<span class="dv">100</span>];</span>
<span id="cb197-27"><a href="#cb197-27" aria-hidden="true"></a>  snprintf(buff, <span class="kw">sizeof</span>(buff), <span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>, <span class="st">&quot;Hello&quot;</span>);</span>
<span id="cb197-28"><a href="#cb197-28" aria-hidden="true"></a>  <span class="bu">std::</span>string buffAsStdStr = buff;</span></code></pre></div>
<p>But I’m not sure why you wouldn’t just use a string stream? I’m assuming you have specific reasons to not just do this:</p>
<div class="sourceCode" id="cb198"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true"></a>  <span class="bu">std::</span>ostringstream stringStream;</span>
<span id="cb198-2"><a href="#cb198-2" aria-hidden="true"></a>  stringStream &lt;&lt; <span class="st">&quot;Hello&quot;</span>;</span>
<span id="cb198-3"><a href="#cb198-3" aria-hidden="true"></a>  <span class="bu">std::</span>string copyOfStr = stringStream.str();</span></code></pre></div>
</section>
<section id="answer-2-score-239" class="level4">
<h4>Answer 2 (score 239)</h4>
<p>C++11 solution that uses <code>vsnprintf()</code> internally:</p>
<div class="sourceCode" id="cb199"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true"></a></span>
<span id="cb199-2"><a href="#cb199-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdarg.h&gt;</span><span class="pp">  </span><span class="co">// For va_start, etc.</span></span>
<span id="cb199-3"><a href="#cb199-3" aria-hidden="true"></a></span>
<span id="cb199-4"><a href="#cb199-4" aria-hidden="true"></a><span class="bu">std::</span>string string_format(<span class="at">const</span> <span class="bu">std::</span>string fmt, ...) {</span>
<span id="cb199-5"><a href="#cb199-5" aria-hidden="true"></a>    <span class="dt">int</span> size = ((<span class="dt">int</span>)fmt.size()) * <span class="dv">2</span> + <span class="dv">50</span>;   <span class="co">// Use a rubric appropriate for your code</span></span>
<span id="cb199-6"><a href="#cb199-6" aria-hidden="true"></a>    <span class="bu">std::</span>string str;</span>
<span id="cb199-7"><a href="#cb199-7" aria-hidden="true"></a>    <span class="dt">va_list</span> ap;</span>
<span id="cb199-8"><a href="#cb199-8" aria-hidden="true"></a>    <span class="cf">while</span> (<span class="dv">1</span>) {     <span class="co">// Maximum two passes on a POSIX system...</span></span>
<span id="cb199-9"><a href="#cb199-9" aria-hidden="true"></a>        str.resize(size);</span>
<span id="cb199-10"><a href="#cb199-10" aria-hidden="true"></a>        va_start(ap, fmt);</span>
<span id="cb199-11"><a href="#cb199-11" aria-hidden="true"></a>        <span class="dt">int</span> n = vsnprintf((<span class="dt">char</span> *)str.data(), size, fmt.c_str(), ap);</span>
<span id="cb199-12"><a href="#cb199-12" aria-hidden="true"></a>        va_end(ap);</span>
<span id="cb199-13"><a href="#cb199-13" aria-hidden="true"></a>        <span class="cf">if</span> (n &gt; -<span class="dv">1</span> &amp;&amp; n &lt; size) {  <span class="co">// Everything worked</span></span>
<span id="cb199-14"><a href="#cb199-14" aria-hidden="true"></a>            str.resize(n);</span>
<span id="cb199-15"><a href="#cb199-15" aria-hidden="true"></a>            <span class="cf">return</span> str;</span>
<span id="cb199-16"><a href="#cb199-16" aria-hidden="true"></a>        }</span>
<span id="cb199-17"><a href="#cb199-17" aria-hidden="true"></a>        <span class="cf">if</span> (n &gt; -<span class="dv">1</span>)  <span class="co">// Needed size returned</span></span>
<span id="cb199-18"><a href="#cb199-18" aria-hidden="true"></a>            size = n + <span class="dv">1</span>;   <span class="co">// For null char</span></span>
<span id="cb199-19"><a href="#cb199-19" aria-hidden="true"></a>        <span class="cf">else</span></span>
<span id="cb199-20"><a href="#cb199-20" aria-hidden="true"></a>            size *= <span class="dv">2</span>;      <span class="co">// Guess at a larger size (OS specific)</span></span>
<span id="cb199-21"><a href="#cb199-21" aria-hidden="true"></a>    }</span>
<span id="cb199-22"><a href="#cb199-22" aria-hidden="true"></a>    <span class="cf">return</span> str;</span>
<span id="cb199-23"><a href="#cb199-23" aria-hidden="true"></a>}</span></code></pre></div>
<p>A safer and more efficient (I tested it, and it is faster) approach:</p>
<div class="sourceCode" id="cb200"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true"></a></span>
<span id="cb200-2"><a href="#cb200-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdarg.h&gt;</span><span class="pp">  </span><span class="co">// For va_start, etc.</span></span>
<span id="cb200-3"><a href="#cb200-3" aria-hidden="true"></a></span>
<span id="cb200-4"><a href="#cb200-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span><span class="pp">    </span><span class="co">// For std::unique_ptr</span></span>
<span id="cb200-5"><a href="#cb200-5" aria-hidden="true"></a></span>
<span id="cb200-6"><a href="#cb200-6" aria-hidden="true"></a><span class="bu">std::</span>string string_format(<span class="at">const</span> <span class="bu">std::</span>string fmt_str, ...) {</span>
<span id="cb200-7"><a href="#cb200-7" aria-hidden="true"></a>    <span class="dt">int</span> final_n, n = ((<span class="dt">int</span>)fmt_str.size()) * <span class="dv">2</span>; <span class="co">/* Reserve two times as much as the length of the fmt_str */</span></span>
<span id="cb200-8"><a href="#cb200-8" aria-hidden="true"></a>    <span class="bu">std::</span>unique_ptr&lt;<span class="dt">char</span>[]&gt; formatted;</span>
<span id="cb200-9"><a href="#cb200-9" aria-hidden="true"></a>    <span class="dt">va_list</span> ap;</span>
<span id="cb200-10"><a href="#cb200-10" aria-hidden="true"></a>    <span class="cf">while</span>(<span class="dv">1</span>) {</span>
<span id="cb200-11"><a href="#cb200-11" aria-hidden="true"></a>        formatted.reset(<span class="kw">new</span> <span class="dt">char</span>[n]); <span class="co">/* Wrap the plain char array into the unique_ptr */</span></span>
<span id="cb200-12"><a href="#cb200-12" aria-hidden="true"></a>        strcpy(&amp;formatted[<span class="dv">0</span>], fmt_str.c_str());</span>
<span id="cb200-13"><a href="#cb200-13" aria-hidden="true"></a>        va_start(ap, fmt_str);</span>
<span id="cb200-14"><a href="#cb200-14" aria-hidden="true"></a>        final_n = vsnprintf(&amp;formatted[<span class="dv">0</span>], n, fmt_str.c_str(), ap);</span>
<span id="cb200-15"><a href="#cb200-15" aria-hidden="true"></a>        va_end(ap);</span>
<span id="cb200-16"><a href="#cb200-16" aria-hidden="true"></a>        <span class="cf">if</span> (final_n &lt; <span class="dv">0</span> || final_n &gt;= n)</span>
<span id="cb200-17"><a href="#cb200-17" aria-hidden="true"></a>            n += abs(final_n - n + <span class="dv">1</span>);</span>
<span id="cb200-18"><a href="#cb200-18" aria-hidden="true"></a>        <span class="cf">else</span></span>
<span id="cb200-19"><a href="#cb200-19" aria-hidden="true"></a>            <span class="cf">break</span>;</span>
<span id="cb200-20"><a href="#cb200-20" aria-hidden="true"></a>    }</span>
<span id="cb200-21"><a href="#cb200-21" aria-hidden="true"></a>    <span class="cf">return</span> <span class="bu">std::</span>string(formatted.get());</span>
<span id="cb200-22"><a href="#cb200-22" aria-hidden="true"></a>}</span></code></pre></div>
<p>The <code>fmt_str</code> is passed by value to conform with the requirements of <code>va_start</code>.</p>
<p>NOTE: The “safer” and “faster” version doesn’t work on some systems. Hence both are still listed. Also, “faster” depends entirely on the preallocation step being correct, otherwise the <code>strcpy</code> renders it slower.</p>
</section>
<section id="answer-3-score-208" class="level4">
<h4>Answer 3 (score 208)</h4>
<p>Utilising <a href="http://en.wikipedia.org/wiki/C%2B%2B11" rel="noreferrer">C++11</a> <a href="http://en.cppreference.com/w/cpp/io/c/fprintf" rel="noreferrer"><code>std::snprintf</code></a>, this becomes a pretty easy and safe task. I see a lot of answers on this question that were apparently written before the time of C++11 which use fixed buffer lengths and vargs, something I would not recommend for safety, efficiency and clarity reasons.</p>
<div class="sourceCode" id="cb201"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true"></a></span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true"></a></span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb201-5"><a href="#cb201-5" aria-hidden="true"></a></span>
<span id="cb201-6"><a href="#cb201-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb201-7"><a href="#cb201-7" aria-hidden="true"></a></span>
<span id="cb201-8"><a href="#cb201-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb201-9"><a href="#cb201-9" aria-hidden="true"></a></span>
<span id="cb201-10"><a href="#cb201-10" aria-hidden="true"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> ... Args&gt;</span>
<span id="cb201-11"><a href="#cb201-11" aria-hidden="true"></a><span class="bu">std::</span>string string_format( <span class="at">const</span> <span class="bu">std::</span>string&amp; format, Args ... args )</span>
<span id="cb201-12"><a href="#cb201-12" aria-hidden="true"></a>{</span>
<span id="cb201-13"><a href="#cb201-13" aria-hidden="true"></a>    <span class="dt">size_t</span> size = snprintf( <span class="kw">nullptr</span>, <span class="dv">0</span>, format.c_str(), args ... ) + <span class="dv">1</span>; <span class="co">// Extra space for &#39;\0&#39;</span></span>
<span id="cb201-14"><a href="#cb201-14" aria-hidden="true"></a>    <span class="bu">std::</span>unique_ptr&lt;<span class="dt">char</span>[]&gt; buf( <span class="kw">new</span> <span class="dt">char</span>[ size ] ); </span>
<span id="cb201-15"><a href="#cb201-15" aria-hidden="true"></a>    snprintf( buf.get(), size, format.c_str(), args ... );</span>
<span id="cb201-16"><a href="#cb201-16" aria-hidden="true"></a>    <span class="cf">return</span> <span class="bu">std::</span>string( buf.get(), buf.get() + size - <span class="dv">1</span> ); <span class="co">// We don&#39;t want the &#39;\0&#39; inside</span></span>
<span id="cb201-17"><a href="#cb201-17" aria-hidden="true"></a>}</span></code></pre></div>
<p><em>The code snippet above is licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/" rel="noreferrer">CC0 1.0</a>.</em></p>
<h5>
Line by line explanation:
</h2>
<p><strong><em>Aim:</em></strong> Write to a <code>char*</code> by using <code>std::snprintf</code> and then convert that to a <code>std::string</code>.</p>
<p>First, we determine the desired length of the char array.</p>
<p>From <a href="http://en.cppreference.com/w/cpp/io/c/fprintf" rel="noreferrer">cppreference.com</a>:</p>
<blockquote>
<p><strong>Return value</strong></p>
<p>
[…] If the resulting string gets truncated due to buf_size limit, function returns the total number of characters (not including the terminating null-byte) which would have been written, if the limit was not imposed.
</p>
</blockquote>
<p>This means that the desired size is the number of characters <strong>plus one</strong>, so that the null-terminator will sit after all other characters and that it can be cut off by the string constructor again. This issue was explained by <span class="citation" data-cites="alexk7">@alexk7</span> in the comments.</p>
<p>Then, we allocate a new character array and assign it to a <code>std::unique_ptr</code>. This is generally advised, as you won’t have to manually <code>delete</code> it again.</p>
<p><em>Note that this is not a safe way to allocate a <code>unique_ptr</code> with user-defined types as you can not deallocate the memory if the constructor throws an exception!</em></p>
<p>After that, we can of course just use <code>snprintf</code> for its intended use and write the formatted string to the <code>char[]</code> and afterwards create and return a new <code>std::string</code> from that.</p>
<hr>
<p>You can see an example in action <a href="http://ideone.com/av9b8p" rel="noreferrer">here</a>.</p>
<hr>
<p>If you also want to use <code>std::string</code> in the argument list, take a look at <a href="http://gist.github.com/Zitrax/a2e0040d301bf4b8ef8101c0b1e3f1d5" rel="noreferrer">this gist</a>.</p>
<hr>
<p>Additional information for <a href="http://en.wikipedia.org/wiki/Microsoft_Visual_Studio" rel="noreferrer">Visual Studio</a> users:</p>
<p>
As explained in <a href="https://stackoverflow.com/a/9052232/2533467">this answer</a>, Microsoft renamed <code>std::snprintf</code> to <code>_snprintf</code> (yes, without <code>std::</code>). MS further set it as deprecated and advises to use <a href="http://msdn.microsoft.com/en-US/library/f30dzcf6(v=vs.80).aspx" rel="noreferrer"><code>_snprintf_s</code></a> instead, however <code>_snprintf_s</code> won’t accept the buffer to be zero or smaller than the formatted output and will not calculate the outputs length if that occurs. So in order to get rid of the deprecation warnings during compilation, you can insert <a href="http://msdn.microsoft.com/en-us/library/vstudio/2c8f766e(v=vs.120).aspx" rel="noreferrer">the following line</a> at the top of the file which contains the use of <code>_snprintf</code>:
</p>
<div class="sourceCode" id="cb202"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true"></a></span>
<span id="cb202-2"><a href="#cb202-2" aria-hidden="true"></a><span class="pp">#pragma warning(disable : 4996)</span></span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="what-are-the-rules-for-calling-the-superclass-constructor-score-750052-in-2017" class="level3">
<h3>33: What are the rules for calling the superclass constructor? (score <a href="https://stackoverflow.com/q/120876.html">750052</a> in 2017)</h3>
<section id="question-31" class="level4">
<h4>Question</h4>
<p>What are the C++ rules for calling the superclass constructor from a subclass one?</p>
<p>For example, I know in Java, you must do it as the first line of the subclass constructor (and if you don’t, an implicit call to a no-arg super constructor is assumed - giving you a compile error if that’s missing).</p>
</section>
<section id="answer-accepted-score-878" class="level4">
<h4>Answer accepted (score 878)</h4>
<p>Base class constructors are automatically called for you if they have no argument. If you want to call a superclass constructor with an argument, you must use the subclass’s constructor initialization list. Unlike Java, C++ supports multiple inheritance (for better or worse), so the base class must be referred to by name, rather than “super()”.</p>
<div class="sourceCode" id="cb203"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true"></a><span class="kw">class</span> SuperClass</span>
<span id="cb203-2"><a href="#cb203-2" aria-hidden="true"></a>{</span>
<span id="cb203-3"><a href="#cb203-3" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb203-4"><a href="#cb203-4" aria-hidden="true"></a></span>
<span id="cb203-5"><a href="#cb203-5" aria-hidden="true"></a>        SuperClass(<span class="dt">int</span> foo)</span>
<span id="cb203-6"><a href="#cb203-6" aria-hidden="true"></a>        {</span>
<span id="cb203-7"><a href="#cb203-7" aria-hidden="true"></a>            <span class="co">// do something with foo</span></span>
<span id="cb203-8"><a href="#cb203-8" aria-hidden="true"></a>        }</span>
<span id="cb203-9"><a href="#cb203-9" aria-hidden="true"></a>};</span>
<span id="cb203-10"><a href="#cb203-10" aria-hidden="true"></a></span>
<span id="cb203-11"><a href="#cb203-11" aria-hidden="true"></a><span class="kw">class</span> SubClass : <span class="kw">public</span> SuperClass</span>
<span id="cb203-12"><a href="#cb203-12" aria-hidden="true"></a>{</span>
<span id="cb203-13"><a href="#cb203-13" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb203-14"><a href="#cb203-14" aria-hidden="true"></a></span>
<span id="cb203-15"><a href="#cb203-15" aria-hidden="true"></a>        SubClass(<span class="dt">int</span> foo, <span class="dt">int</span> bar)</span>
<span id="cb203-16"><a href="#cb203-16" aria-hidden="true"></a>        : SuperClass(foo)    <span class="co">// Call the superclass constructor in the subclass&#39; initialization list.</span></span>
<span id="cb203-17"><a href="#cb203-17" aria-hidden="true"></a>        {</span>
<span id="cb203-18"><a href="#cb203-18" aria-hidden="true"></a>            <span class="co">// do something with bar</span></span>
<span id="cb203-19"><a href="#cb203-19" aria-hidden="true"></a>        }</span>
<span id="cb203-20"><a href="#cb203-20" aria-hidden="true"></a>};</span></code></pre></div>
<p>More info on the constructor’s initialization list <a href="http://www.cprogramming.com/tutorial/initialization-lists-c++.html" rel="noreferrer">here</a> and <a href="http://www.parashift.com/c++-faq-lite/ctors.html
#faq-10.6" rel="noreferrer">here</a>.</p>
</section>
<section id="answer-2-score-224" class="level4">
<h4>Answer 2 (score 224)</h4>
<p>In C++, the no-argument constructors for all superclasses and member variables are called for you, before entering your constructor. If you want to pass them arguments, there is a separate syntax for this called “constructor chaining”, which looks like this:</p>
<div class="sourceCode" id="cb204"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true"></a><span class="kw">class</span> Sub : <span class="kw">public</span> Base</span>
<span id="cb204-2"><a href="#cb204-2" aria-hidden="true"></a>{</span>
<span id="cb204-3"><a href="#cb204-3" aria-hidden="true"></a>  Sub(<span class="dt">int</span> x, <span class="dt">int</span> y)</span>
<span id="cb204-4"><a href="#cb204-4" aria-hidden="true"></a>  : Base(x), member(y)</span>
<span id="cb204-5"><a href="#cb204-5" aria-hidden="true"></a>  {</span>
<span id="cb204-6"><a href="#cb204-6" aria-hidden="true"></a>  }</span>
<span id="cb204-7"><a href="#cb204-7" aria-hidden="true"></a>  Type member;</span>
<span id="cb204-8"><a href="#cb204-8" aria-hidden="true"></a>};</span></code></pre></div>
<p>If anything run at this point throws, the bases/members which had previously completed construction have their destructors called and the exception is rethrown to to the caller. If you want to catch exceptions during chaining, you must use a function try block:</p>
<div class="sourceCode" id="cb205"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true"></a><span class="kw">class</span> Sub : <span class="kw">public</span> Base</span>
<span id="cb205-2"><a href="#cb205-2" aria-hidden="true"></a>{</span>
<span id="cb205-3"><a href="#cb205-3" aria-hidden="true"></a>  Sub(<span class="dt">int</span> x, <span class="dt">int</span> y)</span>
<span id="cb205-4"><a href="#cb205-4" aria-hidden="true"></a>  <span class="cf">try</span> : Base(x), member(y)</span>
<span id="cb205-5"><a href="#cb205-5" aria-hidden="true"></a>  {</span>
<span id="cb205-6"><a href="#cb205-6" aria-hidden="true"></a>    <span class="co">// function body goes here</span></span>
<span id="cb205-7"><a href="#cb205-7" aria-hidden="true"></a>  } <span class="cf">catch</span>(<span class="at">const</span> ExceptionType &amp;e) {</span>
<span id="cb205-8"><a href="#cb205-8" aria-hidden="true"></a>    <span class="cf">throw</span> kaboom();</span>
<span id="cb205-9"><a href="#cb205-9" aria-hidden="true"></a>  }</span>
<span id="cb205-10"><a href="#cb205-10" aria-hidden="true"></a>  Type member;</span>
<span id="cb205-11"><a href="#cb205-11" aria-hidden="true"></a>};</span></code></pre></div>
<p>In this form, note that the try block <strong>is</strong> the body of the function, rather than being inside the body of the function; this allows it to catch exceptions thrown by implicit or explicit member and base class initializations, as well as during the body of the function. However, if a function catch block does not throw a different exception, the runtime will rethrow the original error; exceptions during initialization <strong>cannot</strong> be ignored.</p>
</section>
<section id="answer-3-score-51" class="level4">
<h4>Answer 3 (score 51)</h4>
<p>In C++ there is a concept of constructor’s initialization list, which is where you can and should call the base class’ constructor and where you should also initialize the data members. The initialization list comes after the constructor signature following a colon, and before the body of the constructor. Let’s say we have a class A:</p>
<div class="sourceCode" id="cb206"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true"></a></span>
<span id="cb206-2"><a href="#cb206-2" aria-hidden="true"></a><span class="kw">class</span> A : <span class="kw">public</span> B</span>
<span id="cb206-3"><a href="#cb206-3" aria-hidden="true"></a>{</span>
<span id="cb206-4"><a href="#cb206-4" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb206-5"><a href="#cb206-5" aria-hidden="true"></a>  A(<span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> c);</span>
<span id="cb206-6"><a href="#cb206-6" aria-hidden="true"></a><span class="kw">private</span>:</span>
<span id="cb206-7"><a href="#cb206-7" aria-hidden="true"></a>  <span class="dt">int</span> <span class="va">b_</span>, <span class="va">c_</span>;</span>
<span id="cb206-8"><a href="#cb206-8" aria-hidden="true"></a>};</span></code></pre></div>
<p>Then, assuming B has a constructor which takes an int, A’s constructor may look like this:</p>
<div class="sourceCode" id="cb207"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true"></a></span>
<span id="cb207-2"><a href="#cb207-2" aria-hidden="true"></a>A::A(<span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> c) </span>
<span id="cb207-3"><a href="#cb207-3" aria-hidden="true"></a>  : B(a), <span class="va">b_</span>(b), <span class="va">c_</span>(c) <span class="co">// initialization list</span></span>
<span id="cb207-4"><a href="#cb207-4" aria-hidden="true"></a>{</span>
<span id="cb207-5"><a href="#cb207-5" aria-hidden="true"></a>  <span class="co">// do something</span></span>
<span id="cb207-6"><a href="#cb207-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>As you can see, the constructor of the base class is called in the initialization list. Initializing the data members in the initialization list, by the way, is preferable to assigning the values for b_, and c_ inside the body of the constructor, because you are saving the extra cost of assignment.</p>
<p>Keep in mind, that data members are always initialized in the order in which they are declared in the class definition, regardless of their order in the initialization list. To avoid strange bugs, which may arise if your data members depend on each other, you should always make sure that the order of the members is the same in the initialization list and the class definition. For the same reason the base class constructor must be the first item in the initialization list. If you omit it altogether, then the default constructor for the base class will be called automatically. In that case, if the base class does not have a default constructor, you will get a compiler error.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="what-is-the-operator-in-c-score-738032-in-2019" class="level3">
<h3>34: What is the “–&gt;” operator in C++? (score <a href="https://stackoverflow.com/q/1642028.html">738032</a> in 2019)</h3>
<section id="question-32" class="level4">
<h4>Question</h4>
<p>After reading <a href="http://groups.google.com/group/comp.lang.c++.moderated/msg/33f173780d58dd20" rel="noreferrer">Hidden Features and Dark Corners of C++/STL</a> on <code>comp.lang.c++.moderated</code>, I was completely surprised that the following snippet compiled and worked in both Visual Studio 2008 and G++ 4.4.</p>
<p>Here’s the code:</p>
<div class="sourceCode" id="cb208"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true"></a></span>
<span id="cb208-2"><a href="#cb208-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb208-3"><a href="#cb208-3" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb208-4"><a href="#cb208-4" aria-hidden="true"></a>{</span>
<span id="cb208-5"><a href="#cb208-5" aria-hidden="true"></a>    <span class="dt">int</span> x = <span class="dv">10</span>;</span>
<span id="cb208-6"><a href="#cb208-6" aria-hidden="true"></a>    <span class="cf">while</span> (x --&gt; <span class="dv">0</span>) <span class="co">// x goes to 0</span></span>
<span id="cb208-7"><a href="#cb208-7" aria-hidden="true"></a>    {</span>
<span id="cb208-8"><a href="#cb208-8" aria-hidden="true"></a>        printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st"> &quot;</span>, x);</span>
<span id="cb208-9"><a href="#cb208-9" aria-hidden="true"></a>    }</span>
<span id="cb208-10"><a href="#cb208-10" aria-hidden="true"></a>}</span></code></pre></div>
<p>I’d assume this is C, since it works in GCC as well. Where is this defined in the standard, and where has it come from?</p>
</section>
<section id="answer-accepted-score-8191" class="level4">
<h4>Answer accepted (score 8191)</h4>
<p><code>--&amp;gt;</code> is not an operator. It is in fact two separate operators, <code>--</code> and <code>&amp;gt;</code>.</p>
<p>The conditional’s code decrements <code>x</code>, while returning <code>x</code>’s original (not decremented) value, and then compares the original value with <code>0</code> using the <code>&amp;gt;</code> operator.</p>
<p><strong>To better understand, the statement could be written as follows:</strong></p>
<div class="sourceCode" id="cb209"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb209-1"><a href="#cb209-1" aria-hidden="true"></a><span class="cf">while</span>( (x--) &gt; <span class="dv">0</span> )</span></code></pre></div>
</section>
<section id="answer-2-score-2868" class="level4">
<h4>Answer 2 (score 2868)</h4>
<p>Or for something completely different… x slides to 0</p>
<div class="sourceCode" id="cb210"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true"></a><span class="cf">while</span> (x --\</span>
<span id="cb210-2"><a href="#cb210-2" aria-hidden="true"></a>            \</span>
<span id="cb210-3"><a href="#cb210-3" aria-hidden="true"></a>             \</span>
<span id="cb210-4"><a href="#cb210-4" aria-hidden="true"></a>              \</span>
<span id="cb210-5"><a href="#cb210-5" aria-hidden="true"></a>               &gt; <span class="dv">0</span>)</span>
<span id="cb210-6"><a href="#cb210-6" aria-hidden="true"></a>     printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st"> &quot;</span>, x);</span></code></pre></div>
<p>Not so mathematical, but… every picture paints a thousand words…</p>
</section>
<section id="answer-3-score-2318" class="level4">
<h4>Answer 3 (score 2318)</h4>
<p>That’s a very complicated operator, so even <a href="https://isocpp.org/std/the-committee" rel="nofollow noreferrer">ISO/IEC JTC1 (Joint Technical Committee 1)</a> placed its description in two different parts of the C++ Standard.</p>
<p>Joking aside, they are two different operators: <code>--</code> and <code>&amp;gt;</code> described respectively in §5.2.6/2 and §5.9 of the C++03 Standard.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="iteration-over-stdvector-unsigned-vs-signed-index-variable-score-737570-in-2016" class="level3">
<h3>35: Iteration over std::vector: unsigned vs signed index variable (score <a href="https://stackoverflow.com/q/409348.html">737570</a> in 2016)</h3>
<section id="question-33" class="level4">
<h4>Question</h4>
<p>What is the correct way of iterating over a vector in C++?</p>
<p>Consider these two code fragments, this one works fine:</p>
<div class="sourceCode" id="cb211"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true"></a><span class="cf">for</span> (<span class="dt">unsigned</span> i=<span class="dv">0</span>; i &lt; polygon.size(); i++) {</span>
<span id="cb211-2"><a href="#cb211-2" aria-hidden="true"></a>    sum += polygon[i];</span>
<span id="cb211-3"><a href="#cb211-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>and this one:</p>
<div class="sourceCode" id="cb212"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true"></a><span class="cf">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; polygon.size(); i++) {</span>
<span id="cb212-2"><a href="#cb212-2" aria-hidden="true"></a>    sum += polygon[i];</span>
<span id="cb212-3"><a href="#cb212-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>which generates <code>warning: comparison between signed and unsigned integer expressions</code>.</p>
<p>I’m new in the world of C++, so the <code>unsigned</code> variable looks a bit frightening to me and I know <code>unsigned</code> variables can be dangerous if not used correctly, so - is this correct?</p>
</section>
<section id="answer-accepted-score-772" class="level4">
<h4>Answer accepted (score 772)</h4>
<h5>
Iterating Backwards
</h1>
<p>See <a href="https://stackoverflow.com/questions/275994/whats-the-best-way-to-do-a-backwards-loop-in-c-c-c
#276053">this answer</a>.</p>
<h5>
Iterating Forwards
</h1>
<p>This is almost identical. Just change the iterators / swap decrement by increment. You should prefer iterators. Some people tell you to use <code>std::size_t</code> as the index variable type. However, that is not portable. Always use the <code>size_type</code> typedef of the container (While you could get away with only a conversion in the forward iterating case, it could actually go wrong all the way in the backward iterating case when using <code>std::size_t</code>, in case <code>std::size_t</code> is wider than what is the typedef of <code>size_type</code>):</p>
<h5>
Using std::vector
</h2>
<h5>
Using iterators
</h3>
<div class="sourceCode" id="cb213"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true"></a><span class="cf">for</span>(<span class="bu">std::</span>vector&lt;T&gt;::iterator it = v.begin(); it != v.end(); ++it) {</span>
<span id="cb213-2"><a href="#cb213-2" aria-hidden="true"></a>    <span class="co">/* std::cout &lt;&lt; *it; ... */</span></span>
<span id="cb213-3"><a href="#cb213-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>Important is, always use the prefix increment form for iterators whose definitions you don’t know. That will ensure your code runs as generic as possible.</p>
<h5>
Using Range C++11
</h3>
<div class="sourceCode" id="cb214"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true"></a><span class="cf">for</span>(<span class="kw">auto</span> <span class="at">const</span>&amp; value: a) {</span>
<span id="cb214-2"><a href="#cb214-2" aria-hidden="true"></a>     <span class="co">/* std::cout &lt;&lt; value; ... */</span></span></code></pre></div>
<h5>
Using indices
</h3>
<div class="sourceCode" id="cb215"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true"></a><span class="cf">for</span>(<span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;::<span class="dt">size_type</span> i = <span class="dv">0</span>; i != v.size(); i++) {</span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true"></a>    <span class="co">/* std::cout &lt;&lt; v[i]; ... */</span></span>
<span id="cb215-3"><a href="#cb215-3" aria-hidden="true"></a>}</span></code></pre></div>
<h5>
Using arrays
</h2>
<h5>
Using iterators
</h3>
<div class="sourceCode" id="cb216"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true"></a><span class="cf">for</span>(<span class="dt">element_type</span>* it = a; it != (a + (<span class="kw">sizeof</span> a / <span class="kw">sizeof</span> *a)); it++) {</span>
<span id="cb216-2"><a href="#cb216-2" aria-hidden="true"></a>    <span class="co">/* std::cout &lt;&lt; *it; ... */</span></span>
<span id="cb216-3"><a href="#cb216-3" aria-hidden="true"></a>}</span></code></pre></div>
<h5>
Using Range C++11
</h3>
<div class="sourceCode" id="cb217"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true"></a><span class="cf">for</span>(<span class="kw">auto</span> <span class="at">const</span>&amp; value: a) {</span>
<span id="cb217-2"><a href="#cb217-2" aria-hidden="true"></a>     <span class="co">/* std::cout &lt;&lt; value; ... */</span></span></code></pre></div>
<h5>
Using indices
</h3>
<div class="sourceCode" id="cb218"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true"></a><span class="cf">for</span>(<span class="bu">std::</span>size_t i = <span class="dv">0</span>; i != (<span class="kw">sizeof</span> a / <span class="kw">sizeof</span> *a); i++) {</span>
<span id="cb218-2"><a href="#cb218-2" aria-hidden="true"></a>    <span class="co">/* std::cout &lt;&lt; a[i]; ... */</span></span>
<span id="cb218-3"><a href="#cb218-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>Read in the backward iterating answer what problem the <code>sizeof</code> approach can yield to, though.</p>
</section>
<section id="answer-2-score-163" class="level4">
<h4>Answer 2 (score 163)</h4>
<p>Four years passed, <em>Google</em> gave me this answer. With the <a href="http://en.wikipedia.org/wiki/C++11">standard <em>C++11</em></a> (aka <em>C++0x</em>) there is actually a new pleasant way of doing this (at the price of breaking backward compatibility): the new <code>auto</code> keyword. It saves you the pain of having to explicitly specify the type of the iterator to use (repeating the vector type again), when it is obvious (to the compiler), which type to use. With <code>v</code> being your <code>vector</code>, you can do something like this:</p>
<div class="sourceCode" id="cb219"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true"></a><span class="cf">for</span> ( <span class="kw">auto</span> i = v.begin(); i != v.end(); i++ ) {</span>
<span id="cb219-2"><a href="#cb219-2" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; *i &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb219-3"><a href="#cb219-3" aria-hidden="true"></a>}</span></code></pre></div>
<p><em>C++11</em> goes even further and gives you a special syntax for iterating over collections like vectors. It removes the necessity of writing things that are always the same:</p>
<div class="sourceCode" id="cb220"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb220-1"><a href="#cb220-1" aria-hidden="true"></a><span class="cf">for</span> ( <span class="kw">auto</span> &amp;i : v ) {</span>
<span id="cb220-2"><a href="#cb220-2" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; i &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb220-3"><a href="#cb220-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>To see it in a working program, build a file <code>auto.cpp</code>:</p>
<div class="sourceCode" id="cb221"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb221-1"><a href="#cb221-1" aria-hidden="true"></a></span>
<span id="cb221-2"><a href="#cb221-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb221-3"><a href="#cb221-3" aria-hidden="true"></a></span>
<span id="cb221-4"><a href="#cb221-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb221-5"><a href="#cb221-5" aria-hidden="true"></a></span>
<span id="cb221-6"><a href="#cb221-6" aria-hidden="true"></a><span class="dt">int</span> main(<span class="dt">void</span>) {</span>
<span id="cb221-7"><a href="#cb221-7" aria-hidden="true"></a>    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;();</span>
<span id="cb221-8"><a href="#cb221-8" aria-hidden="true"></a>    v.push_back(<span class="dv">17</span>);</span>
<span id="cb221-9"><a href="#cb221-9" aria-hidden="true"></a>    v.push_back(<span class="dv">12</span>);</span>
<span id="cb221-10"><a href="#cb221-10" aria-hidden="true"></a>    v.push_back(<span class="dv">23</span>);</span>
<span id="cb221-11"><a href="#cb221-11" aria-hidden="true"></a>    v.push_back(<span class="dv">42</span>);</span>
<span id="cb221-12"><a href="#cb221-12" aria-hidden="true"></a>    <span class="cf">for</span> ( <span class="kw">auto</span> &amp;i : v ) {</span>
<span id="cb221-13"><a href="#cb221-13" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; i &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb221-14"><a href="#cb221-14" aria-hidden="true"></a>    }</span>
<span id="cb221-15"><a href="#cb221-15" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb221-16"><a href="#cb221-16" aria-hidden="true"></a>}</span></code></pre></div>
<p>As of writing this, when you compile this with <em>g++</em>, you normally need to set it to work with the new standard by giving an extra flag:</p>
<div class="sourceCode" id="cb222"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb222-1"><a href="#cb222-1" aria-hidden="true"></a>g++ -std=c++<span class="er">0x</span> -o <span class="kw">auto</span> <span class="kw">auto</span>.cpp</span></code></pre></div>
<p>Now you can run the example:</p>
<div class="sourceCode" id="cb223"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb223-1"><a href="#cb223-1" aria-hidden="true"></a><span class="er">$</span> ./<span class="kw">auto</span></span>
<span id="cb223-2"><a href="#cb223-2" aria-hidden="true"></a><span class="dv">17</span></span>
<span id="cb223-3"><a href="#cb223-3" aria-hidden="true"></a><span class="dv">12</span></span>
<span id="cb223-4"><a href="#cb223-4" aria-hidden="true"></a><span class="dv">23</span></span>
<span id="cb223-5"><a href="#cb223-5" aria-hidden="true"></a><span class="dv">42</span></span></code></pre></div>
<p><em>Please note</em> that the instructions on compiling and running are specific to <em>gnu c++</em> compiler on <em>Linux</em>, the program should be platform (and compiler) independent.</p>
</section>
<section id="answer-3-score-44" class="level4">
<h4>Answer 3 (score 44)</h4>
<p>In the specific case in your example, I’d use the STL algorithms to accomplish this.</p>
<div class="sourceCode" id="cb224"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb224-1"><a href="#cb224-1" aria-hidden="true"></a></span>
<span id="cb224-2"><a href="#cb224-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;numeric&gt;</span><span class="pp"> </span></span>
<span id="cb224-3"><a href="#cb224-3" aria-hidden="true"></a></span>
<span id="cb224-4"><a href="#cb224-4" aria-hidden="true"></a>sum = <span class="bu">std::</span>accumulate( polygon.begin(), polygon.end(), <span class="dv">0</span> );</span></code></pre></div>
<p>For a more general, but still fairly simple case, I’d go with:</p>
<div class="sourceCode" id="cb225"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb225-1"><a href="#cb225-1" aria-hidden="true"></a></span>
<span id="cb225-2"><a href="#cb225-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;boost/lambda/lambda.hpp&gt;</span></span>
<span id="cb225-3"><a href="#cb225-3" aria-hidden="true"></a></span>
<span id="cb225-4"><a href="#cb225-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;boost/lambda/bind.hpp&gt;</span></span>
<span id="cb225-5"><a href="#cb225-5" aria-hidden="true"></a></span>
<span id="cb225-6"><a href="#cb225-6" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> <span class="ex">boost::</span>lambda;</span>
<span id="cb225-7"><a href="#cb225-7" aria-hidden="true"></a><span class="bu">std::</span>for_each( polygon.begin(), polygon.end(), sum += _1 );</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="return-array-in-a-function-score-715453-in-2014" class="level3">
<h3>36: Return array in a function (score <a href="https://stackoverflow.com/q/3473438.html">715453</a> in 2014)</h3>
<section id="question-34" class="level4">
<h4>Question</h4>
<p>I have an array <code>int arr[5]</code> that is passed to a function <code>fillarr(int arr[])</code>:</p>
<div class="sourceCode" id="cb226"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb226-1"><a href="#cb226-1" aria-hidden="true"></a><span class="dt">int</span> fillarr(<span class="dt">int</span> arr[])</span>
<span id="cb226-2"><a href="#cb226-2" aria-hidden="true"></a>{</span>
<span id="cb226-3"><a href="#cb226-3" aria-hidden="true"></a>    <span class="cf">for</span>(...);</span>
<span id="cb226-4"><a href="#cb226-4" aria-hidden="true"></a>    <span class="cf">return</span> arr;</span>
<span id="cb226-5"><a href="#cb226-5" aria-hidden="true"></a>}</span></code></pre></div>
<ol>
<li>
How can I return that array?
</li>
<li>
How will I use it, say I returned a pointer how am I going to access it?
</li>
</ol>
</section>
<section id="answer-accepted-score-174" class="level4">
<h4>Answer accepted (score 174)</h4>
<p>In this case, your array variable <code>arr</code> can actually also be treated as a pointer to the beginning of your array’s block in memory, by an implicit conversion. This syntax that you’re using:</p>
<div class="sourceCode" id="cb227"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb227-1"><a href="#cb227-1" aria-hidden="true"></a><span class="dt">int</span> fillarr(<span class="dt">int</span> arr[])</span></code></pre></div>
<p>Is kind of just syntactic sugar. You could really replace it with this and it would still work:</p>
<div class="sourceCode" id="cb228"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb228-1"><a href="#cb228-1" aria-hidden="true"></a><span class="dt">int</span> fillarr(<span class="dt">int</span>* arr)</span></code></pre></div>
<p>So in the same sense, what you want to return from your function is actually a pointer to the first element in the array:</p>
<div class="sourceCode" id="cb229"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb229-1"><a href="#cb229-1" aria-hidden="true"></a><span class="dt">int</span>* fillarr(<span class="dt">int</span> arr[])</span></code></pre></div>
<p>And you’ll still be able to use it just like you would a normal array:</p>
<div class="sourceCode" id="cb230"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb230-1"><a href="#cb230-1" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb230-2"><a href="#cb230-2" aria-hidden="true"></a>{</span>
<span id="cb230-3"><a href="#cb230-3" aria-hidden="true"></a>  <span class="dt">int</span> y[<span class="dv">10</span>];</span>
<span id="cb230-4"><a href="#cb230-4" aria-hidden="true"></a>  <span class="dt">int</span> *a = fillarr(y);</span>
<span id="cb230-5"><a href="#cb230-5" aria-hidden="true"></a>  cout &lt;&lt; a[<span class="dv">0</span>] &lt;&lt; endl;</span>
<span id="cb230-6"><a href="#cb230-6" aria-hidden="true"></a>}</span></code></pre></div>
</section>
<section id="answer-2-score-100" class="level4">
<h4>Answer 2 (score 100)</h4>
<p>C++ functions can’t return C-style arrays by value. The closest thing is to return a pointer. Furthermore, an array type in the argument list is simply converted to a pointer.</p>
<div class="sourceCode" id="cb231"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb231-1"><a href="#cb231-1" aria-hidden="true"></a><span class="dt">int</span> *fillarr( <span class="dt">int</span> arr[] ) { <span class="co">// arr &quot;decays&quot; to type int *</span></span>
<span id="cb231-2"><a href="#cb231-2" aria-hidden="true"></a>    <span class="cf">return</span> arr;</span>
<span id="cb231-3"><a href="#cb231-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>You can improve it by using an array references for the argument and return, which prevents the decay:</p>
<div class="sourceCode" id="cb232"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb232-1"><a href="#cb232-1" aria-hidden="true"></a><span class="dt">int</span> ( &amp;fillarr( <span class="dt">int</span> (&amp;arr)[<span class="dv">5</span>] ) )[<span class="dv">5</span>] { <span class="co">// no decay; argument must be size 5</span></span>
<span id="cb232-2"><a href="#cb232-2" aria-hidden="true"></a>    <span class="cf">return</span> arr;</span>
<span id="cb232-3"><a href="#cb232-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>With Boost or C++11, pass-by-reference is only optional and the syntax is less mind-bending:</p>
<div class="sourceCode" id="cb233"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb233-1"><a href="#cb233-1" aria-hidden="true"></a>array&lt; <span class="dt">int</span>, <span class="dv">5</span> &gt; &amp;fillarr( array&lt; <span class="dt">int</span>, <span class="dv">5</span> &gt; &amp;arr ) {</span>
<span id="cb233-2"><a href="#cb233-2" aria-hidden="true"></a>    <span class="cf">return</span> arr; <span class="co">// &quot;array&quot; being boost::array or std::array</span></span>
<span id="cb233-3"><a href="#cb233-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>The <code>array</code> template simply generates a <code>struct</code> containing a C-style array, so you can apply object-oriented semantics yet retain the array’s original simplicity.</p>
</section>
<section id="answer-3-score-19" class="level4">
<h4>Answer 3 (score 19)</h4>
<p>$8.3.5/8 states-</p>
<p>“Functions shall not have a return type of type array or function, although they may have a return type of type pointer or reference to such things. There shall be no arrays of functions, although there can be arrays of pointers to functions.”</p>
<div class="sourceCode" id="cb234"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb234-1"><a href="#cb234-1" aria-hidden="true"></a><span class="dt">int</span> (&amp;fn1(<span class="dt">int</span> (&amp;arr)[<span class="dv">5</span>]))[<span class="dv">5</span>]{     <span class="co">// declare fn1 as returning refernce to array</span></span>
<span id="cb234-2"><a href="#cb234-2" aria-hidden="true"></a>   <span class="cf">return</span> arr;</span>
<span id="cb234-3"><a href="#cb234-3" aria-hidden="true"></a>}</span>
<span id="cb234-4"><a href="#cb234-4" aria-hidden="true"></a></span>
<span id="cb234-5"><a href="#cb234-5" aria-hidden="true"></a><span class="dt">int</span> *fn2(<span class="dt">int</span> arr[]){              <span class="co">// declare fn2 as returning pointer to array</span></span>
<span id="cb234-6"><a href="#cb234-6" aria-hidden="true"></a>   <span class="cf">return</span> arr;</span>
<span id="cb234-7"><a href="#cb234-7" aria-hidden="true"></a>}</span>
<span id="cb234-8"><a href="#cb234-8" aria-hidden="true"></a></span>
<span id="cb234-9"><a href="#cb234-9" aria-hidden="true"></a></span>
<span id="cb234-10"><a href="#cb234-10" aria-hidden="true"></a><span class="dt">int</span> main(){</span>
<span id="cb234-11"><a href="#cb234-11" aria-hidden="true"></a>   <span class="dt">int</span> buf[<span class="dv">5</span>];</span>
<span id="cb234-12"><a href="#cb234-12" aria-hidden="true"></a>   fn1(buf);</span>
<span id="cb234-13"><a href="#cb234-13" aria-hidden="true"></a>   fn2(buf);</span>
<span id="cb234-14"><a href="#cb234-14" aria-hidden="true"></a>}</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="what-is-the-effect-of-extern-c-in-c-score-709916-in-2018" class="level3">
<h3>37: What is the effect of extern “C” in C++? (score <a href="https://stackoverflow.com/q/1041866.html">709916</a> in 2018)</h3>
<section id="question-35" class="level4">
<h4>Question</h4>
<p>What exactly does putting <code>extern "C"</code> into C++ code do?</p>
<p>For example:</p>
<div class="sourceCode" id="cb235"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb235-1"><a href="#cb235-1" aria-hidden="true"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> {</span>
<span id="cb235-2"><a href="#cb235-2" aria-hidden="true"></a>   <span class="dt">void</span> foo();</span>
<span id="cb235-3"><a href="#cb235-3" aria-hidden="true"></a>}</span></code></pre></div>
</section>
<section id="answer-accepted-score-1442" class="level4">
<h4>Answer accepted (score 1442)</h4>
<p>extern “C” makes a function-name in C++ have ‘C’ linkage (compiler does not mangle the name) so that client C code can link to (i.e use) your function using a ‘C’ compatible header file that contains just the declaration of your function. Your function definition is contained in a binary format (that was compiled by your C++ compiler) that the client ‘C’ linker will then link to using the ‘C’ name.</p>
<p>Since C++ has overloading of function names and C does not, the C++ compiler cannot just use the function name as a unique id to link to, so it mangles the name by adding information about the arguments. A C compiler does not need to mangle the name since you can not overload function names in C. When you state that a function has extern “C” linkage in C++, the C++ compiler does not add argument/parameter type information to the name used for linkage.</p>
<p>Just so you know, you can specify “C” linkage to each individual declaration/definition explicitly or use a block to group a sequence of declarations/definitions to have a certain linkage:</p>
<div class="sourceCode" id="cb236"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb236-1"><a href="#cb236-1" aria-hidden="true"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> <span class="dt">void</span> foo(<span class="dt">int</span>);</span>
<span id="cb236-2"><a href="#cb236-2" aria-hidden="true"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span></span>
<span id="cb236-3"><a href="#cb236-3" aria-hidden="true"></a>{</span>
<span id="cb236-4"><a href="#cb236-4" aria-hidden="true"></a>   <span class="dt">void</span> g(<span class="dt">char</span>);</span>
<span id="cb236-5"><a href="#cb236-5" aria-hidden="true"></a>   <span class="dt">int</span> i;</span>
<span id="cb236-6"><a href="#cb236-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>If you care about the technicalities, they are listed in section 7.5 of the C++03 standard, here is a brief summary (with emphasis on extern “C”):</p>
<ul>
<li>
extern “C” is a linkage-specification
</li>
<li>
Every compiler is <em>required</em> to provide “C” linkage
</li>
<li>
a linkage specification shall occur only in namespace scope
</li>
<li>
<strike> all function types, function names and variable names have a language linkage </strike> <b><a href="https://stackoverflow.com/questions/1041866/in-c-source-what-is-the-effect-of-extern-c
#comment20842899_1041880">See Richard’s Comment:</a></b> Only function names and variable names with external linkage have a language linkage
</li>
<li>
two function types with distinct language linkages are distinct types even if otherwise identical
</li>
<li>
linkage specs nest, inner one determines the final linkage
</li>
<li>
extern “C” is ignored for class members
</li>
<li>
at most one function with a particular name can have “C” linkage (regardless of namespace)
</li>
<li>
<strike> extern “C” forces a function to have external linkage (cannot make it static) </strike> <b> <a href="https://stackoverflow.com/questions/1041866/what-is-the-effect-of-extern-c-in-c?rq=1
#comment20842893_1041880">See Richard’s comment:</a> </b> ‘static’ inside ‘extern “C”’ is valid; an entity so declared has internal linkage, and so does not have a language linkage
</li>
<li>
Linkage from C++ to objects defined in other languages and to objects defined in C++ from other languages is implementation-defined and language-dependent. Only where the object layout strategies of two language implementations are similar enough can such linkage be achieved
</li>
</ul>
</section>
<section id="answer-2-score-295" class="level4">
<h4>Answer 2 (score 295)</h4>
<p>Just wanted to add a bit of info, since I haven’t seen it posted yet.</p>
<p>You’ll very often see code in C headers like so:</p>
<div class="sourceCode" id="cb237"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb237-1"><a href="#cb237-1" aria-hidden="true"></a></span>
<span id="cb237-2"><a href="#cb237-2" aria-hidden="true"></a><span class="pp">#ifdef __cplusplus</span></span>
<span id="cb237-3"><a href="#cb237-3" aria-hidden="true"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> {</span>
<span id="cb237-4"><a href="#cb237-4" aria-hidden="true"></a></span>
<span id="cb237-5"><a href="#cb237-5" aria-hidden="true"></a><span class="pp">#endif</span></span>
<span id="cb237-6"><a href="#cb237-6" aria-hidden="true"></a></span>
<span id="cb237-7"><a href="#cb237-7" aria-hidden="true"></a><span class="co">// all of your legacy C code here</span></span>
<span id="cb237-8"><a href="#cb237-8" aria-hidden="true"></a></span>
<span id="cb237-9"><a href="#cb237-9" aria-hidden="true"></a></span>
<span id="cb237-10"><a href="#cb237-10" aria-hidden="true"></a><span class="pp">#ifdef __cplusplus</span></span>
<span id="cb237-11"><a href="#cb237-11" aria-hidden="true"></a>}</span>
<span id="cb237-12"><a href="#cb237-12" aria-hidden="true"></a></span>
<span id="cb237-13"><a href="#cb237-13" aria-hidden="true"></a><span class="pp">#endif</span></span></code></pre></div>
<p>What this accomplishes is that it allows you to use that C header file with your C++ code, because the macro "__cplusplus" will be defined. But you can <em>also</em> still use it with your legacy C code, where the macro is <em>NOT</em> defined, so it won’t see the uniquely C++ construct.</p>
<p>Although, I have also seen C++ code such as:</p>
<div class="sourceCode" id="cb238"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb238-1"><a href="#cb238-1" aria-hidden="true"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> {</span>
<span id="cb238-2"><a href="#cb238-2" aria-hidden="true"></a></span>
<span id="cb238-3"><a href="#cb238-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;legacy_C_header.h&quot;</span></span>
<span id="cb238-4"><a href="#cb238-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>which I imagine accomplishes much the same thing.</p>
<p>Not sure which way is better, but I have seen both.</p>
</section>
<section id="answer-3-score-210" class="level4">
<h4>Answer 3 (score 210)</h4>
<p><strong>Decompile a <code>g++</code> generated binary to see what is going on</strong></p>
<p>main.cpp</p>
<div class="sourceCode" id="cb239"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb239-1"><a href="#cb239-1" aria-hidden="true"></a><span class="dt">void</span> f() {}</span>
<span id="cb239-2"><a href="#cb239-2" aria-hidden="true"></a><span class="dt">void</span> g();</span>
<span id="cb239-3"><a href="#cb239-3" aria-hidden="true"></a></span>
<span id="cb239-4"><a href="#cb239-4" aria-hidden="true"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> {</span>
<span id="cb239-5"><a href="#cb239-5" aria-hidden="true"></a>    <span class="dt">void</span> ef() {}</span>
<span id="cb239-6"><a href="#cb239-6" aria-hidden="true"></a>    <span class="dt">void</span> eg();</span>
<span id="cb239-7"><a href="#cb239-7" aria-hidden="true"></a>}</span>
<span id="cb239-8"><a href="#cb239-8" aria-hidden="true"></a></span>
<span id="cb239-9"><a href="#cb239-9" aria-hidden="true"></a><span class="co">/* Prevent g and eg from being optimized away. */</span></span>
<span id="cb239-10"><a href="#cb239-10" aria-hidden="true"></a><span class="dt">void</span> h() { g(); eg(); }</span></code></pre></div>
<p>Compile and disassemble the generated <a href="https://stackoverflow.com/questions/26294034/how-to-make-an-executable-elf-file-in-linux-using-a-hex-editor/30648229
#30648229">ELF</a> output:</p>
<div class="sourceCode" id="cb240"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb240-1"><a href="#cb240-1" aria-hidden="true"></a>g++ -c -std=c++<span class="dv">11</span> -Wall -Wextra -pedantic -o main.o main.cpp</span>
<span id="cb240-2"><a href="#cb240-2" aria-hidden="true"></a>readelf -s main.o</span></code></pre></div>
<p>The output contains:</p>
<div class="sourceCode" id="cb241"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb241-1"><a href="#cb241-1" aria-hidden="true"></a>     <span class="dv">8</span>: <span class="bn">0000000000000000</span>     <span class="dv">7</span> FUNC    GLOBAL DEFAULT    <span class="dv">1</span> _Z1fv</span>
<span id="cb241-2"><a href="#cb241-2" aria-hidden="true"></a>     <span class="dv">9</span>: <span class="bn">0000000000000007</span>     <span class="dv">7</span> FUNC    GLOBAL DEFAULT    <span class="dv">1</span> ef</span>
<span id="cb241-3"><a href="#cb241-3" aria-hidden="true"></a>    <span class="dv">10</span>: <span class="bn">000000000000000</span><span class="er">e</span>    <span class="dv">17</span> FUNC    GLOBAL DEFAULT    <span class="dv">1</span> _Z1hv</span>
<span id="cb241-4"><a href="#cb241-4" aria-hidden="true"></a>    <span class="dv">11</span>: <span class="bn">0000000000000000</span>     <span class="dv">0</span> NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_</span>
<span id="cb241-5"><a href="#cb241-5" aria-hidden="true"></a>    <span class="dv">12</span>: <span class="bn">0000000000000000</span>     <span class="dv">0</span> NOTYPE  GLOBAL DEFAULT  UND _Z1gv</span>
<span id="cb241-6"><a href="#cb241-6" aria-hidden="true"></a>    <span class="dv">13</span>: <span class="bn">0000000000000000</span>     <span class="dv">0</span> NOTYPE  GLOBAL DEFAULT  UND eg</span></code></pre></div>
<p><strong>Interpretation</strong></p>
<p>We see that:</p>
<ul>
<li>
<p>
<code>ef</code> and <code>eg</code> were stored in symbols with the same name as in the code
</p>
</li>
<li>
<p>
the other symbols were mangled. Let’s unmangle them:
</p>
<div class="sourceCode" id="cb242"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb242-1"><a href="#cb242-1" aria-hidden="true"></a><span class="er">$</span> c++filt _Z1fv</span>
<span id="cb242-2"><a href="#cb242-2" aria-hidden="true"></a>f()</span>
<span id="cb242-3"><a href="#cb242-3" aria-hidden="true"></a><span class="er">$</span> c++filt _Z1hv</span>
<span id="cb242-4"><a href="#cb242-4" aria-hidden="true"></a>h()</span>
<span id="cb242-5"><a href="#cb242-5" aria-hidden="true"></a><span class="er">$</span> c++filt _Z1gv</span>
<span id="cb242-6"><a href="#cb242-6" aria-hidden="true"></a>g()</span>
<span id="cb242-7"><a href="#cb242-7" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb242-8"><a href="#cb242-8" aria-hidden="true"></a>&lt;/ul&gt;</span>
<span id="cb242-9"><a href="#cb242-9" aria-hidden="true"></a></span>
<span id="cb242-10"><a href="#cb242-10" aria-hidden="true"></a>Conclusion: both of the following symbol types were &lt;em&gt;<span class="kw">not</span>&lt;/em&gt; mangled:  </span>
<span id="cb242-11"><a href="#cb242-11" aria-hidden="true"></a></span>
<span id="cb242-12"><a href="#cb242-12" aria-hidden="true"></a>&lt;ul&gt;</span>
<span id="cb242-13"><a href="#cb242-13" aria-hidden="true"></a>&lt;li&gt;defined&lt;/li&gt;</span>
<span id="cb242-14"><a href="#cb242-14" aria-hidden="true"></a>&lt;li&gt;declared but undefined (<span class="er">`</span>Ndx = UND<span class="er">`</span>), to be provided at link <span class="kw">or</span> run time from another object file&lt;/li&gt;</span>
<span id="cb242-15"><a href="#cb242-15" aria-hidden="true"></a>&lt;/ul&gt;</span>
<span id="cb242-16"><a href="#cb242-16" aria-hidden="true"></a></span>
<span id="cb242-17"><a href="#cb242-17" aria-hidden="true"></a>So you will need <span class="er">`</span>extern <span class="st">&quot;C&quot;</span><span class="er">`</span> both when calling:  </span>
<span id="cb242-18"><a href="#cb242-18" aria-hidden="true"></a></span>
<span id="cb242-19"><a href="#cb242-19" aria-hidden="true"></a>&lt;ul&gt;</span>
<span id="cb242-20"><a href="#cb242-20" aria-hidden="true"></a>&lt;li&gt;C from C++: tell <span class="er">`</span>g++<span class="er">`</span> to expect unmangled symbols produced by <span class="er">`</span>gcc<span class="er">`</span>&lt;/li&gt;</span>
<span id="cb242-21"><a href="#cb242-21" aria-hidden="true"></a>&lt;li&gt;C++ from C: tell <span class="er">`</span>g++<span class="er">`</span> to generate unmangled symbols <span class="cf">for</span> <span class="er">`</span>gcc<span class="er">`</span> to use&lt;/li&gt;</span>
<span id="cb242-22"><a href="#cb242-22" aria-hidden="true"></a>&lt;/ul&gt;</span>
<span id="cb242-23"><a href="#cb242-23" aria-hidden="true"></a></span>
<span id="cb242-24"><a href="#cb242-24" aria-hidden="true"></a>&lt;strong&gt;Things that <span class="cf">do</span> <span class="kw">not</span> work in <span class="at">extern</span> C&lt;/strong&gt;  </span>
<span id="cb242-25"><a href="#cb242-25" aria-hidden="true"></a></span>
<span id="cb242-26"><a href="#cb242-26" aria-hidden="true"></a>It becomes obvious that any C++ feature that <span class="kw">requires</span> name mangling will <span class="kw">not</span> work inside <span class="er">`</span>extern C<span class="er">`</span>:  </span>
<span id="cb242-27"><a href="#cb242-27" aria-hidden="true"></a></span>
<span id="cb242-28"><a href="#cb242-28" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb242-29"><a href="#cb242-29" aria-hidden="true"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> {</span>
<span id="cb242-30"><a href="#cb242-30" aria-hidden="true"></a>    <span class="co">// Overloading.</span></span>
<span id="cb242-31"><a href="#cb242-31" aria-hidden="true"></a>    <span class="co">// error: declaration of C function ‘void f(int)’ conflicts with</span></span>
<span id="cb242-32"><a href="#cb242-32" aria-hidden="true"></a>    <span class="dt">void</span> f();</span>
<span id="cb242-33"><a href="#cb242-33" aria-hidden="true"></a>    <span class="dt">void</span> f(<span class="dt">int</span> i);</span>
<span id="cb242-34"><a href="#cb242-34" aria-hidden="true"></a></span>
<span id="cb242-35"><a href="#cb242-35" aria-hidden="true"></a>    <span class="co">// Templates.</span></span>
<span id="cb242-36"><a href="#cb242-36" aria-hidden="true"></a>    <span class="co">// error: template with C linkage</span></span>
<span id="cb242-37"><a href="#cb242-37" aria-hidden="true"></a>    <span class="kw">template</span> &lt;<span class="kw">class</span> C&gt; <span class="dt">void</span> f(C i) { }</span>
<span id="cb242-38"><a href="#cb242-38" aria-hidden="true"></a>}</span></code></pre></div>
<p><strong>Minimal runnable C from C++ example</strong></p>
<p>For the sake of completeness and for the newbs out there, see also: <a href="https://stackoverflow.com/questions/13694605/how-to-use-c-source-files-in-a-c-project/51912672
#51912672">How to use C source files in a C++ project?</a></p>
<p>Calling C from C++ is pretty easy: each C function only has one possible non-mangled symbol, so no extra work is required.</p>
<p>main.cpp</p>
<div class="sourceCode" id="cb243"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb243-1"><a href="#cb243-1" aria-hidden="true"></a></span>
<span id="cb243-2"><a href="#cb243-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;cassert&gt;</span></span>
<span id="cb243-3"><a href="#cb243-3" aria-hidden="true"></a></span>
<span id="cb243-4"><a href="#cb243-4" aria-hidden="true"></a></span>
<span id="cb243-5"><a href="#cb243-5" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;c.h&quot;</span></span>
<span id="cb243-6"><a href="#cb243-6" aria-hidden="true"></a></span>
<span id="cb243-7"><a href="#cb243-7" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb243-8"><a href="#cb243-8" aria-hidden="true"></a>    <span class="ot">assert</span>(f() == <span class="dv">1</span>);</span>
<span id="cb243-9"><a href="#cb243-9" aria-hidden="true"></a>}</span></code></pre></div>
<p>c.h</p>
<div class="sourceCode" id="cb244"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb244-1"><a href="#cb244-1" aria-hidden="true"></a></span>
<span id="cb244-2"><a href="#cb244-2" aria-hidden="true"></a><span class="pp">#ifndef C_H</span></span>
<span id="cb244-3"><a href="#cb244-3" aria-hidden="true"></a></span>
<span id="cb244-4"><a href="#cb244-4" aria-hidden="true"></a><span class="pp">#define C_H</span></span>
<span id="cb244-5"><a href="#cb244-5" aria-hidden="true"></a></span>
<span id="cb244-6"><a href="#cb244-6" aria-hidden="true"></a><span class="co">/* This ifdef allows the header to be used from both C and C++. */</span></span>
<span id="cb244-7"><a href="#cb244-7" aria-hidden="true"></a></span>
<span id="cb244-8"><a href="#cb244-8" aria-hidden="true"></a><span class="pp">#ifdef __cplusplus</span></span>
<span id="cb244-9"><a href="#cb244-9" aria-hidden="true"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> {</span>
<span id="cb244-10"><a href="#cb244-10" aria-hidden="true"></a></span>
<span id="cb244-11"><a href="#cb244-11" aria-hidden="true"></a><span class="pp">#endif</span></span>
<span id="cb244-12"><a href="#cb244-12" aria-hidden="true"></a><span class="dt">int</span> f();</span>
<span id="cb244-13"><a href="#cb244-13" aria-hidden="true"></a></span>
<span id="cb244-14"><a href="#cb244-14" aria-hidden="true"></a><span class="pp">#ifdef __cplusplus</span></span>
<span id="cb244-15"><a href="#cb244-15" aria-hidden="true"></a>}</span>
<span id="cb244-16"><a href="#cb244-16" aria-hidden="true"></a></span>
<span id="cb244-17"><a href="#cb244-17" aria-hidden="true"></a><span class="pp">#endif</span></span>
<span id="cb244-18"><a href="#cb244-18" aria-hidden="true"></a></span>
<span id="cb244-19"><a href="#cb244-19" aria-hidden="true"></a></span>
<span id="cb244-20"><a href="#cb244-20" aria-hidden="true"></a><span class="pp">#endif</span></span></code></pre></div>
<p>c.c</p>
<div class="sourceCode" id="cb245"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb245-1"><a href="#cb245-1" aria-hidden="true"></a></span>
<span id="cb245-2"><a href="#cb245-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;c.h&quot;</span></span>
<span id="cb245-3"><a href="#cb245-3" aria-hidden="true"></a></span>
<span id="cb245-4"><a href="#cb245-4" aria-hidden="true"></a><span class="dt">int</span> f(<span class="dt">void</span>) { <span class="cf">return</span> <span class="dv">1</span>; }</span></code></pre></div>
<p>Run:</p>
<div class="sourceCode" id="cb246"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb246-1"><a href="#cb246-1" aria-hidden="true"></a>g++ -c -o main.o -std=c++<span class="dv">98</span> main.cpp</span>
<span id="cb246-2"><a href="#cb246-2" aria-hidden="true"></a>gcc -c -o c.o -std=c89 c.c</span>
<span id="cb246-3"><a href="#cb246-3" aria-hidden="true"></a>g++ -o main.out main.o c.o</span>
<span id="cb246-4"><a href="#cb246-4" aria-hidden="true"></a>./main.out</span></code></pre></div>
<p>Without <code>extern "C"</code> the link fails with:</p>
<div class="sourceCode" id="cb247"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb247-1"><a href="#cb247-1" aria-hidden="true"></a>main.cpp:<span class="dv">6</span>: undefined reference to <span class="er">`</span>f()<span class="ch">&#39;</span></span></code></pre></div>
<p>because <code>g++</code> expects to find a mangled <code>f</code>, which <code>gcc</code> did not produce.</p>
<p><a href="https://github.com/cirosantilli/cpp-cheat/tree/bf5f48628d0b01ba6a3fcea6f1162b28539654c9/c-from-cpp" rel="noreferrer">Example on GitHub</a>.</p>
<p><strong>Minimal runnable C++ from C example</strong></p>
<p>Calling C++ from C is a bit harder: we have to manually create non-mangled versions of each function we want to expose.</p>
<p>Here we illustrate how to expose C++ function overloads to C.</p>
<p>main.c</p>
<div class="sourceCode" id="cb248"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb248-1"><a href="#cb248-1" aria-hidden="true"></a></span>
<span id="cb248-2"><a href="#cb248-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></span>
<span id="cb248-3"><a href="#cb248-3" aria-hidden="true"></a></span>
<span id="cb248-4"><a href="#cb248-4" aria-hidden="true"></a></span>
<span id="cb248-5"><a href="#cb248-5" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;cpp.h&quot;</span></span>
<span id="cb248-6"><a href="#cb248-6" aria-hidden="true"></a></span>
<span id="cb248-7"><a href="#cb248-7" aria-hidden="true"></a><span class="dt">int</span> main(<span class="dt">void</span>) {</span>
<span id="cb248-8"><a href="#cb248-8" aria-hidden="true"></a>    <span class="ot">assert</span>(f_int(<span class="dv">1</span>) == <span class="dv">2</span>);</span>
<span id="cb248-9"><a href="#cb248-9" aria-hidden="true"></a>    <span class="ot">assert</span>(f_float(<span class="fl">1.0</span>) == <span class="dv">3</span>);</span>
<span id="cb248-10"><a href="#cb248-10" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb248-11"><a href="#cb248-11" aria-hidden="true"></a>}</span></code></pre></div>
<p>cpp.h</p>
<div class="sourceCode" id="cb249"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb249-1"><a href="#cb249-1" aria-hidden="true"></a></span>
<span id="cb249-2"><a href="#cb249-2" aria-hidden="true"></a><span class="pp">#ifndef CPP_H</span></span>
<span id="cb249-3"><a href="#cb249-3" aria-hidden="true"></a></span>
<span id="cb249-4"><a href="#cb249-4" aria-hidden="true"></a><span class="pp">#define CPP_H</span></span>
<span id="cb249-5"><a href="#cb249-5" aria-hidden="true"></a></span>
<span id="cb249-6"><a href="#cb249-6" aria-hidden="true"></a></span>
<span id="cb249-7"><a href="#cb249-7" aria-hidden="true"></a><span class="pp">#ifdef __cplusplus</span></span>
<span id="cb249-8"><a href="#cb249-8" aria-hidden="true"></a><span class="co">// C cannot see these overloaded prototypes, or else it would get confused.</span></span>
<span id="cb249-9"><a href="#cb249-9" aria-hidden="true"></a><span class="dt">int</span> f(<span class="dt">int</span> i);</span>
<span id="cb249-10"><a href="#cb249-10" aria-hidden="true"></a><span class="dt">int</span> f(<span class="dt">float</span> i);</span>
<span id="cb249-11"><a href="#cb249-11" aria-hidden="true"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> {</span>
<span id="cb249-12"><a href="#cb249-12" aria-hidden="true"></a></span>
<span id="cb249-13"><a href="#cb249-13" aria-hidden="true"></a><span class="pp">#endif</span></span>
<span id="cb249-14"><a href="#cb249-14" aria-hidden="true"></a><span class="dt">int</span> f_int(<span class="dt">int</span> i);</span>
<span id="cb249-15"><a href="#cb249-15" aria-hidden="true"></a><span class="dt">int</span> f_float(<span class="dt">float</span> i);</span>
<span id="cb249-16"><a href="#cb249-16" aria-hidden="true"></a></span>
<span id="cb249-17"><a href="#cb249-17" aria-hidden="true"></a><span class="pp">#ifdef __cplusplus</span></span>
<span id="cb249-18"><a href="#cb249-18" aria-hidden="true"></a>}</span>
<span id="cb249-19"><a href="#cb249-19" aria-hidden="true"></a></span>
<span id="cb249-20"><a href="#cb249-20" aria-hidden="true"></a><span class="pp">#endif</span></span>
<span id="cb249-21"><a href="#cb249-21" aria-hidden="true"></a></span>
<span id="cb249-22"><a href="#cb249-22" aria-hidden="true"></a></span>
<span id="cb249-23"><a href="#cb249-23" aria-hidden="true"></a><span class="pp">#endif</span></span></code></pre></div>
<p>cpp.cpp</p>
<div class="sourceCode" id="cb250"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb250-1"><a href="#cb250-1" aria-hidden="true"></a></span>
<span id="cb250-2"><a href="#cb250-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;cpp.h&quot;</span></span>
<span id="cb250-3"><a href="#cb250-3" aria-hidden="true"></a></span>
<span id="cb250-4"><a href="#cb250-4" aria-hidden="true"></a><span class="dt">int</span> f(<span class="dt">int</span> i) {</span>
<span id="cb250-5"><a href="#cb250-5" aria-hidden="true"></a>    <span class="cf">return</span> i + <span class="dv">1</span>;</span>
<span id="cb250-6"><a href="#cb250-6" aria-hidden="true"></a>}</span>
<span id="cb250-7"><a href="#cb250-7" aria-hidden="true"></a></span>
<span id="cb250-8"><a href="#cb250-8" aria-hidden="true"></a><span class="dt">int</span> f(<span class="dt">float</span> i) {</span>
<span id="cb250-9"><a href="#cb250-9" aria-hidden="true"></a>    <span class="cf">return</span> i + <span class="dv">2</span>;</span>
<span id="cb250-10"><a href="#cb250-10" aria-hidden="true"></a>}</span>
<span id="cb250-11"><a href="#cb250-11" aria-hidden="true"></a></span>
<span id="cb250-12"><a href="#cb250-12" aria-hidden="true"></a><span class="dt">int</span> f_int(<span class="dt">int</span> i) {</span>
<span id="cb250-13"><a href="#cb250-13" aria-hidden="true"></a>    <span class="cf">return</span> f(i);</span>
<span id="cb250-14"><a href="#cb250-14" aria-hidden="true"></a>}</span>
<span id="cb250-15"><a href="#cb250-15" aria-hidden="true"></a></span>
<span id="cb250-16"><a href="#cb250-16" aria-hidden="true"></a><span class="dt">int</span> f_float(<span class="dt">float</span> i) {</span>
<span id="cb250-17"><a href="#cb250-17" aria-hidden="true"></a>    <span class="cf">return</span> f(i);</span>
<span id="cb250-18"><a href="#cb250-18" aria-hidden="true"></a>}</span></code></pre></div>
<p>Run:</p>
<div class="sourceCode" id="cb251"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb251-1"><a href="#cb251-1" aria-hidden="true"></a>gcc -c -o main.o -std=c89 -Wextra main.c</span>
<span id="cb251-2"><a href="#cb251-2" aria-hidden="true"></a>g++ -c -o cpp.o -std=c++<span class="dv">98</span> cpp.cpp</span>
<span id="cb251-3"><a href="#cb251-3" aria-hidden="true"></a>g++ -o main.out main.o cpp.o</span>
<span id="cb251-4"><a href="#cb251-4" aria-hidden="true"></a>./main.out</span></code></pre></div>
<p>Without <code>extern "C"</code> it fails with:</p>
<div class="sourceCode" id="cb252"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb252-1"><a href="#cb252-1" aria-hidden="true"></a>main.c:<span class="dv">6</span>: undefined reference to <span class="er">`</span>f_int<span class="ch">&#39;</span></span>
<span id="cb252-2"><a href="#cb252-2" aria-hidden="true"></a>main.c:<span class="dv">7</span>: undefined reference to <span class="er">`</span>f_float<span class="ch">&#39;</span></span></code></pre></div>
<p>because <code>g++</code> generated mangled symbols which <code>gcc</code> cannot find.</p>
<p><a href="https://github.com/cirosantilli/cpp-cheat/tree/bf5f48628d0b01ba6a3fcea6f1162b28539654c9/cpp-from-c" rel="noreferrer">Example on GitHub</a>.</p>
<p>Tested in Ubuntu 18.04.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-do-i-erase-an-element-from-stdvector-by-index-score-678605-in-2016" class="level3">
<h3>38: How do I erase an element from std::vector&lt;&gt; by index? (score <a href="https://stackoverflow.com/q/875103.html">678605</a> in 2016)</h3>
<section id="question-36" class="level4">
<h4>Question</h4>
<p>I have a std::vector&lt;int&gt;, and I want to delete the n’th element. How do I do that?</p>
<div class="sourceCode" id="cb253"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb253-1"><a href="#cb253-1" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; vec;</span>
<span id="cb253-2"><a href="#cb253-2" aria-hidden="true"></a></span>
<span id="cb253-3"><a href="#cb253-3" aria-hidden="true"></a>vec.push_back(<span class="dv">6</span>);</span>
<span id="cb253-4"><a href="#cb253-4" aria-hidden="true"></a>vec.push_back(-<span class="dv">17</span>);</span>
<span id="cb253-5"><a href="#cb253-5" aria-hidden="true"></a>vec.push_back(<span class="dv">12</span>);</span>
<span id="cb253-6"><a href="#cb253-6" aria-hidden="true"></a></span>
<span id="cb253-7"><a href="#cb253-7" aria-hidden="true"></a>vec.erase(???);</span></code></pre></div>
</section>
<section id="answer-accepted-score-633" class="level4">
<h4>Answer accepted (score 633)</h4>
<p>To delete a single element, you could do:</p>
<div class="sourceCode" id="cb254"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb254-1"><a href="#cb254-1" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; vec;</span>
<span id="cb254-2"><a href="#cb254-2" aria-hidden="true"></a></span>
<span id="cb254-3"><a href="#cb254-3" aria-hidden="true"></a>vec.push_back(<span class="dv">6</span>);</span>
<span id="cb254-4"><a href="#cb254-4" aria-hidden="true"></a>vec.push_back(-<span class="dv">17</span>);</span>
<span id="cb254-5"><a href="#cb254-5" aria-hidden="true"></a>vec.push_back(<span class="dv">12</span>);</span>
<span id="cb254-6"><a href="#cb254-6" aria-hidden="true"></a></span>
<span id="cb254-7"><a href="#cb254-7" aria-hidden="true"></a><span class="co">// Deletes the second element (vec[1])</span></span>
<span id="cb254-8"><a href="#cb254-8" aria-hidden="true"></a>vec.erase(vec.begin() + <span class="dv">1</span>);</span></code></pre></div>
<p>Or, to delete more than one element at once:</p>
<div class="sourceCode" id="cb255"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb255-1"><a href="#cb255-1" aria-hidden="true"></a><span class="co">// Deletes the second through third elements (vec[1], vec[2])</span></span>
<span id="cb255-2"><a href="#cb255-2" aria-hidden="true"></a>vec.erase(vec.begin() + <span class="dv">1</span>, vec.begin() + <span class="dv">3</span>);</span></code></pre></div>
</section>
<section id="answer-2-score-194" class="level4">
<h4>Answer 2 (score 194)</h4>
<p>The erase method on std::vector is overloaded, so it’s probably clearer to call</p>
<div class="sourceCode" id="cb256"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb256-1"><a href="#cb256-1" aria-hidden="true"></a>vec.erase(vec.begin() + index);</span></code></pre></div>
<p>when you only want to erase a single element.</p>
</section>
<section id="answer-3-score-51-1" class="level4">
<h4>Answer 3 (score 51)</h4>
<div class="sourceCode" id="cb257"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb257-1"><a href="#cb257-1" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb257-2"><a href="#cb257-2" aria-hidden="true"></a><span class="dt">void</span> remove(<span class="bu">std::</span>vector&lt;T&gt;&amp; vec, <span class="dt">size_t</span> pos)</span>
<span id="cb257-3"><a href="#cb257-3" aria-hidden="true"></a>{</span>
<span id="cb257-4"><a href="#cb257-4" aria-hidden="true"></a>    <span class="bu">std::</span>vector&lt;T&gt;::iterator it = vec.begin();</span>
<span id="cb257-5"><a href="#cb257-5" aria-hidden="true"></a>    <span class="bu">std::</span>advance(it, pos);</span>
<span id="cb257-6"><a href="#cb257-6" aria-hidden="true"></a>    vec.erase(it);</span>
<span id="cb257-7"><a href="#cb257-7" aria-hidden="true"></a>}</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="compiling-c11-with-g-score-675811-in-2018" class="level3">
<h3>39: Compiling C++11 with g++ (score <a href="https://stackoverflow.com/q/10363646.html">675811</a> in 2018)</h3>
<section id="question-37" class="level4">
<h4>Question</h4>
<p>
I’m trying to update my C++ compiler to C++11. I have searched a bit and I have come to the conclusion that I have to use the flag <code>-std=c++0x</code> or <code>-std=gnu++0x</code>, but I don’t know many things about flags. Can anyone help me? (I’m using Ubuntu 12.04.)
</p>
<p>Here is the error that I get from the compiler when I attempt to use a library which is included in C++11 (i.e. array):</p>
<div class="sourceCode" id="cb258"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb258-1"><a href="#cb258-1" aria-hidden="true"></a></span>
<span id="cb258-2"><a href="#cb258-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;array&gt;</span></span>
<span id="cb258-3"><a href="#cb258-3" aria-hidden="true"></a></span>
<span id="cb258-4"><a href="#cb258-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb258-5"><a href="#cb258-5" aria-hidden="true"></a></span>
<span id="cb258-6"><a href="#cb258-6" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb258-7"><a href="#cb258-7" aria-hidden="true"></a>{</span>
<span id="cb258-8"><a href="#cb258-8" aria-hidden="true"></a>    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt; arr = {<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>};</span>
<span id="cb258-9"><a href="#cb258-9" aria-hidden="true"></a>    ...</span>
<span id="cb258-10"><a href="#cb258-10" aria-hidden="true"></a>}</span></code></pre></div>
<blockquote>
This file requires compiler and library support for the upcoming ISO C++ standard, C++0x. This support is currently experimental, and must be enabled with the -std=c++0x or -std=gnu++0x compiler options.
</blockquote>
</section>
<section id="answer-accepted-score-499" class="level4">
<h4>Answer accepted (score 499)</h4>
<p>Flags (or compiler options) are nothing but ordinary command line arguments passed to the compiler executable.</p>
<p>Assuming you are invoking g++ from the command line (terminal):</p>
<p><code>$ g++ -std=c++11 your_file.cpp -o your_program</code></p>
<p>or</p>
<p><code>$ g++ -std=c++0x your_file.cpp -o your_program</code></p>
<p>if the above doesn’t work.</p>
</section>
<section id="answer-2-score-41" class="level4">
<h4>Answer 2 (score 41)</h4>
<p>You can check your <code>g++</code> by command:</p>
<div class="sourceCode" id="cb259"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb259-1"><a href="#cb259-1" aria-hidden="true"></a>which g++</span>
<span id="cb259-2"><a href="#cb259-2" aria-hidden="true"></a>g++ --version</span></code></pre></div>
<p>this will tell you which complier is currently it is pointing.</p>
<p>To switch to <code>g++</code> 4.7 (assuming that you have installed it in your machine),run:</p>
<div class="sourceCode" id="cb260"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb260-1"><a href="#cb260-1" aria-hidden="true"></a>sudo update-alternatives --config gcc</span>
<span id="cb260-2"><a href="#cb260-2" aria-hidden="true"></a></span>
<span id="cb260-3"><a href="#cb260-3" aria-hidden="true"></a>There are <span class="dv">2</span> choices <span class="cf">for</span> the alternative gcc (providing /usr/bin/gcc).</span>
<span id="cb260-4"><a href="#cb260-4" aria-hidden="true"></a></span>
<span id="cb260-5"><a href="#cb260-5" aria-hidden="true"></a>  Selection    Path              Priority   Status</span>
<span id="cb260-6"><a href="#cb260-6" aria-hidden="true"></a>------------------------------------------------------------</span>
<span id="cb260-7"><a href="#cb260-7" aria-hidden="true"></a>  <span class="dv">0</span>            /usr/bin/gcc-<span class="fl">4.6</span>   <span class="dv">60</span>        <span class="kw">auto</span> mode</span>
<span id="cb260-8"><a href="#cb260-8" aria-hidden="true"></a>  <span class="dv">1</span>            /usr/bin/gcc-<span class="fl">4.6</span>   <span class="dv">60</span>        manual mode</span>
<span id="cb260-9"><a href="#cb260-9" aria-hidden="true"></a>* <span class="dv">2</span>            /usr/bin/gcc-<span class="fl">4.7</span>   <span class="dv">40</span>        manual mode</span></code></pre></div>
<p>Then select <code>2</code> as selection(My machine already pointing to <code>g++</code> 4.7,so the *)</p>
<p>Once you switch the complier then again run <code>g++ --version</code> to check the switching has happened correctly.</p>
<p>Now compile your program with</p>
<div class="sourceCode" id="cb261"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb261-1"><a href="#cb261-1" aria-hidden="true"></a>g++ -std=c++<span class="dv">11</span> your_file.cpp -o main</span></code></pre></div>
</section>
<section id="answer-3-score-13" class="level4">
<h4>Answer 3 (score 13)</h4>
<p>Your ubuntu definitely has a sufficiently recent version of g++. The flag to use is <code>-std=c++0x</code>.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="regular-cast-vs.-static_cast-vs.-dynamic_cast-score-667403-in-2014" class="level3">
<h3>40: Regular cast vs. static_cast vs. dynamic_cast (score <a href="https://stackoverflow.com/q/28002.html">667403</a> in 2014)</h3>
<section id="question-38" class="level4">
<h4>Question</h4>
<p>I’ve been writing C and C++ code for almost twenty years, but there’s one aspect of these languages that I’ve never really understood. I’ve obviously used regular casts i.e. </p>
<div class="sourceCode" id="cb262"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb262-1"><a href="#cb262-1" aria-hidden="true"></a>MyClass *m = (MyClass *)ptr;</span></code></pre></div>
<p>all over the place, but there seem to be two other types of casts, and I don’t know the difference. What’s the difference between the following lines of code?</p>
<div class="sourceCode" id="cb263"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb263-1"><a href="#cb263-1" aria-hidden="true"></a>MyClass *m = (MyClass *)ptr;</span>
<span id="cb263-2"><a href="#cb263-2" aria-hidden="true"></a>MyClass *m = <span class="kw">static_cast</span>&lt;MyClass *&gt;(ptr);</span>
<span id="cb263-3"><a href="#cb263-3" aria-hidden="true"></a>MyClass *m = <span class="kw">dynamic_cast</span>&lt;MyClass *&gt;(ptr);</span></code></pre></div>
</section>
<section id="answer-accepted-score-1533" class="level4">
<h4>Answer accepted (score 1533)</h4>
<h5>
static_cast
</h2>
<p><code>static_cast</code> is used for cases where you basically want to reverse an implicit conversion, with a few restrictions and additions. <code>static_cast</code> performs no runtime checks. This should be used if you know that you refer to an object of a specific type, and thus a check would be unnecessary. Example:</p>
<div class="sourceCode" id="cb264"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb264-1"><a href="#cb264-1" aria-hidden="true"></a><span class="dt">void</span> func(<span class="dt">void</span> *data) {</span>
<span id="cb264-2"><a href="#cb264-2" aria-hidden="true"></a>  <span class="co">// Conversion from MyClass* -&gt; void* is implicit</span></span>
<span id="cb264-3"><a href="#cb264-3" aria-hidden="true"></a>  MyClass *c = <span class="kw">static_cast</span>&lt;MyClass*&gt;(data);</span>
<span id="cb264-4"><a href="#cb264-4" aria-hidden="true"></a>  ...</span>
<span id="cb264-5"><a href="#cb264-5" aria-hidden="true"></a>}</span>
<span id="cb264-6"><a href="#cb264-6" aria-hidden="true"></a></span>
<span id="cb264-7"><a href="#cb264-7" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb264-8"><a href="#cb264-8" aria-hidden="true"></a>  MyClass c;</span>
<span id="cb264-9"><a href="#cb264-9" aria-hidden="true"></a>  start_thread(&amp;func, &amp;c)  <span class="co">// func(&amp;c) will be called</span></span>
<span id="cb264-10"><a href="#cb264-10" aria-hidden="true"></a>      .join();</span>
<span id="cb264-11"><a href="#cb264-11" aria-hidden="true"></a>}</span></code></pre></div>
<p>In this example, you know that you passed a <code>MyClass</code> object, and thus there isn’t any need for a runtime check to ensure this.</p>
<h5>
dynamic_cast
</h2>
<p><code>dynamic_cast</code> is useful when you don’t know what the dynamic type of the object is. It returns a null pointer if the object referred to doesn’t contain the type casted to as a base class (when you cast to a reference, a <code>bad_cast</code> exception is thrown in that case).</p>
<div class="sourceCode" id="cb265"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb265-1"><a href="#cb265-1" aria-hidden="true"></a><span class="cf">if</span> (JumpStm *j = <span class="kw">dynamic_cast</span>&lt;JumpStm*&gt;(&amp;stm)) {</span>
<span id="cb265-2"><a href="#cb265-2" aria-hidden="true"></a>  ...</span>
<span id="cb265-3"><a href="#cb265-3" aria-hidden="true"></a>} <span class="cf">else</span> <span class="cf">if</span> (ExprStm *e = <span class="kw">dynamic_cast</span>&lt;ExprStm*&gt;(&amp;stm)) {</span>
<span id="cb265-4"><a href="#cb265-4" aria-hidden="true"></a>  ...</span>
<span id="cb265-5"><a href="#cb265-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>You cannot use <code>dynamic_cast</code> if you downcast (cast to a derived class) and the argument type is not polymorphic. For example, the following code is not valid, because <code>Base</code> doesn’t contain any virtual function:</p>
<div class="sourceCode" id="cb266"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb266-1"><a href="#cb266-1" aria-hidden="true"></a><span class="kw">struct</span> Base { };</span>
<span id="cb266-2"><a href="#cb266-2" aria-hidden="true"></a><span class="kw">struct</span> Derived : Base { };</span>
<span id="cb266-3"><a href="#cb266-3" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb266-4"><a href="#cb266-4" aria-hidden="true"></a>  Derived d; Base *b = &amp;d;</span>
<span id="cb266-5"><a href="#cb266-5" aria-hidden="true"></a>  <span class="kw">dynamic_cast</span>&lt;Derived*&gt;(b); <span class="co">// Invalid</span></span>
<span id="cb266-6"><a href="#cb266-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>An “up-cast” (cast to the base class) is always valid with both <code>static_cast</code> and <code>dynamic_cast</code>, and also without any cast, as an “up-cast” is an implicit conversion.</p>
<h5>
Regular Cast
</h2>
<p>These casts are also called C-style cast. A C-style cast is basically identical to trying out a range of sequences of C++ casts, and taking the first C++ cast that works, without ever considering <code>dynamic_cast</code>. Needless to say, this is much more powerful as it combines all of <code>const_cast</code>, <code>static_cast</code> and <code>reinterpret_cast</code>, but it’s also unsafe, because it does not use <code>dynamic_cast</code>.</p>
<p>In addition, C-style casts not only allow you to do this, but they also allow you to safely cast to a private base-class, while the “equivalent” <code>static_cast</code> sequence would give you a compile-time error for that.</p>
<p>Some people prefer C-style casts because of their brevity. I use them for numeric casts only, and use the appropriate C++ casts when user defined types are involved, as they provide stricter checking.</p>
</section>
<section id="answer-2-score-160" class="level4">
<h4>Answer 2 (score 160)</h4>
<h5>
Static cast
</h2>
<p>The static cast performs conversions between compatible types. It is similar to the C-style cast, but is more restrictive. For example, the C-style cast would allow an integer pointer to point to a char.</p>
<div class="sourceCode" id="cb267"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb267-1"><a href="#cb267-1" aria-hidden="true"></a><span class="dt">char</span> c = <span class="dv">10</span>;       <span class="co">// 1 byte</span></span>
<span id="cb267-2"><a href="#cb267-2" aria-hidden="true"></a><span class="dt">int</span> *p = (<span class="dt">int</span>*)&amp;c; <span class="co">// 4 bytes</span></span></code></pre></div>
<p>Since this results in a 4-byte pointer pointing to 1 byte of allocated memory, writing to this pointer will either cause a run-time error or will overwrite some adjacent memory.</p>
<div class="sourceCode" id="cb268"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb268-1"><a href="#cb268-1" aria-hidden="true"></a>*p = <span class="dv">5</span>; <span class="co">// run-time error: stack corruption</span></span></code></pre></div>
<p>In contrast to the C-style cast, the static cast will allow the compiler to check that the pointer and pointee data types are compatible, which allows the programmer to catch this incorrect pointer assignment during compilation.</p>
<div class="sourceCode" id="cb269"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb269-1"><a href="#cb269-1" aria-hidden="true"></a><span class="dt">int</span> *q = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>*&gt;(&amp;c); <span class="co">// compile-time error</span></span></code></pre></div>
<h5>
Reinterpret cast
</h2>
<p>To force the pointer conversion, in the same way as the C-style cast does in the background, the reinterpret cast would be used instead.</p>
<div class="sourceCode" id="cb270"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb270-1"><a href="#cb270-1" aria-hidden="true"></a><span class="dt">int</span> *r = <span class="kw">reinterpret_cast</span>&lt;<span class="dt">int</span>*&gt;(&amp;c); <span class="co">// forced conversion</span></span></code></pre></div>
<p>This cast handles conversions between certain unrelated types, such as from one pointer type to another incompatible pointer type. It will simply perform a binary copy of the data without altering the underlying bit pattern. Note that the result of such a low-level operation is system-specific and therefore not portable. It should be used with caution if it cannot be avoided altogether.</p>
<h5>
Dynamic cast
</h2>
<p>This one is only used to convert object pointers and object references into other pointer or reference types in the inheritance hierarchy. It is the only cast that makes sure that the object pointed to can be converted, by performing a run-time check that the pointer refers to a complete object of the destination type. For this run-time check to be possible the object must be polymorphic. That is, the class must define or inherit at least one virtual function. This is because the compiler will only generate the needed run-time type information for such objects.</p>
<p><strong>Dynamic cast examples</strong></p>
<p>In the example below, a MyChild pointer is converted into a MyBase pointer using a dynamic cast. This derived-to-base conversion succeeds, because the Child object includes a complete Base object.</p>
<div class="sourceCode" id="cb271"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb271-1"><a href="#cb271-1" aria-hidden="true"></a><span class="kw">class</span> MyBase </span>
<span id="cb271-2"><a href="#cb271-2" aria-hidden="true"></a>{ </span>
<span id="cb271-3"><a href="#cb271-3" aria-hidden="true"></a>  <span class="kw">public</span>:</span>
<span id="cb271-4"><a href="#cb271-4" aria-hidden="true"></a>  <span class="kw">virtual</span> <span class="dt">void</span> test() {}</span>
<span id="cb271-5"><a href="#cb271-5" aria-hidden="true"></a>};</span>
<span id="cb271-6"><a href="#cb271-6" aria-hidden="true"></a><span class="kw">class</span> MyChild : <span class="kw">public</span> MyBase {};</span>
<span id="cb271-7"><a href="#cb271-7" aria-hidden="true"></a></span>
<span id="cb271-8"><a href="#cb271-8" aria-hidden="true"></a></span>
<span id="cb271-9"><a href="#cb271-9" aria-hidden="true"></a></span>
<span id="cb271-10"><a href="#cb271-10" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb271-11"><a href="#cb271-11" aria-hidden="true"></a>{</span>
<span id="cb271-12"><a href="#cb271-12" aria-hidden="true"></a>  MyChild *child = <span class="kw">new</span> MyChild();</span>
<span id="cb271-13"><a href="#cb271-13" aria-hidden="true"></a>  MyBase  *base = <span class="kw">dynamic_cast</span>&lt;MyBase*&gt;(child); <span class="co">// ok</span></span>
<span id="cb271-14"><a href="#cb271-14" aria-hidden="true"></a>}</span></code></pre></div>
<p>The next example attempts to convert a MyBase pointer to a MyChild pointer. Since the Base object does not contain a complete Child object this pointer conversion will fail. To indicate this, the dynamic cast returns a null pointer. This gives a convenient way to check whether or not a conversion has succeeded during run-time.</p>
<div class="sourceCode" id="cb272"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb272-1"><a href="#cb272-1" aria-hidden="true"></a>MyBase  *base = <span class="kw">new</span> MyBase();</span>
<span id="cb272-2"><a href="#cb272-2" aria-hidden="true"></a>MyChild *child = <span class="kw">dynamic_cast</span>&lt;MyChild*&gt;(base);</span>
<span id="cb272-3"><a href="#cb272-3" aria-hidden="true"></a></span>
<span id="cb272-4"><a href="#cb272-4" aria-hidden="true"></a></span>
<span id="cb272-5"><a href="#cb272-5" aria-hidden="true"></a><span class="cf">if</span> (child == <span class="dv">0</span>) </span>
<span id="cb272-6"><a href="#cb272-6" aria-hidden="true"></a><span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Null pointer returned&quot;</span>;</span></code></pre></div>
<p>If a reference is converted instead of a pointer, the dynamic cast will then fail by throwing a bad_cast exception. This needs to be handled using a try-catch statement.</p>
<div class="sourceCode" id="cb273"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb273-1"><a href="#cb273-1" aria-hidden="true"></a></span>
<span id="cb273-2"><a href="#cb273-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;exception&gt;</span></span>
<span id="cb273-3"><a href="#cb273-3" aria-hidden="true"></a><span class="co">// …  </span></span>
<span id="cb273-4"><a href="#cb273-4" aria-hidden="true"></a><span class="cf">try</span></span>
<span id="cb273-5"><a href="#cb273-5" aria-hidden="true"></a>{ </span>
<span id="cb273-6"><a href="#cb273-6" aria-hidden="true"></a>  MyChild &amp;child = <span class="kw">dynamic_cast</span>&lt;MyChild&amp;&gt;(*base);</span>
<span id="cb273-7"><a href="#cb273-7" aria-hidden="true"></a>}</span>
<span id="cb273-8"><a href="#cb273-8" aria-hidden="true"></a><span class="cf">catch</span>(<span class="bu">std::</span>bad_cast &amp;e) </span>
<span id="cb273-9"><a href="#cb273-9" aria-hidden="true"></a>{ </span>
<span id="cb273-10"><a href="#cb273-10" aria-hidden="true"></a>  <span class="bu">std::</span>cout &lt;&lt; e.what(); <span class="co">// bad dynamic_cast</span></span>
<span id="cb273-11"><a href="#cb273-11" aria-hidden="true"></a>}</span></code></pre></div>
<h5>
Dynamic or static cast
</h2>
<p>The advantage of using a dynamic cast is that it allows the programmer to check whether or not a conversion has succeeded during run-time. The disadvantage is that there is a performance overhead associated with doing this check. For this reason using a static cast would have been preferable in the first example, because a derived-to-base conversion will never fail.</p>
<div class="sourceCode" id="cb274"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb274-1"><a href="#cb274-1" aria-hidden="true"></a>MyBase *base = <span class="kw">static_cast</span>&lt;MyBase*&gt;(child); <span class="co">// ok</span></span></code></pre></div>
<p>However, in the second example the conversion may either succeed or fail. It will fail if the MyBase object contains a MyBase instance and it will succeed if it contains a MyChild instance. In some situations this may not be known until run-time. When this is the case dynamic cast is a better choice than static cast.</p>
<div class="sourceCode" id="cb275"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb275-1"><a href="#cb275-1" aria-hidden="true"></a><span class="co">// Succeeds for a MyChild object</span></span>
<span id="cb275-2"><a href="#cb275-2" aria-hidden="true"></a>MyChild *child = <span class="kw">dynamic_cast</span>&lt;MyChild*&gt;(base);</span></code></pre></div>
<p>If the base-to-derived conversion had been performed using a static cast instead of a dynamic cast the conversion would not have failed. It would have returned a pointer that referred to an incomplete object. Dereferencing such a pointer can lead to run-time errors.</p>
<div class="sourceCode" id="cb276"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb276-1"><a href="#cb276-1" aria-hidden="true"></a><span class="co">// Allowed, but invalid</span></span>
<span id="cb276-2"><a href="#cb276-2" aria-hidden="true"></a>MyChild *child = <span class="kw">static_cast</span>&lt;MyChild*&gt;(base);</span>
<span id="cb276-3"><a href="#cb276-3" aria-hidden="true"></a></span>
<span id="cb276-4"><a href="#cb276-4" aria-hidden="true"></a><span class="co">// Incomplete MyChild object dereferenced</span></span>
<span id="cb276-5"><a href="#cb276-5" aria-hidden="true"></a>(*child);</span></code></pre></div>
<h5>
Const cast
</h2>
<p>This one is primarily used to add or remove the const modifier of a variable.</p>
<div class="sourceCode" id="cb277"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb277-1"><a href="#cb277-1" aria-hidden="true"></a><span class="at">const</span> <span class="dt">int</span> myConst = <span class="dv">5</span>;</span>
<span id="cb277-2"><a href="#cb277-2" aria-hidden="true"></a><span class="dt">int</span> *nonConst = <span class="kw">const_cast</span>&lt;<span class="dt">int</span>*&gt;(&amp;myConst); <span class="co">// removes const</span></span></code></pre></div>
<p>Although const cast allows the value of a constant to be changed, doing so is still invalid code that may cause a run-time error. This could occur for example if the constant was located in a section of read-only memory.</p>
<div class="sourceCode" id="cb278"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb278-1"><a href="#cb278-1" aria-hidden="true"></a>*nonConst = <span class="dv">10</span>; <span class="co">// potential run-time error</span></span></code></pre></div>
<p>Const cast is instead used mainly when there is a function that takes a non-constant pointer argument, even though it does not modify the pointee.</p>
<div class="sourceCode" id="cb279"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb279-1"><a href="#cb279-1" aria-hidden="true"></a><span class="dt">void</span> print(<span class="dt">int</span> *p) </span>
<span id="cb279-2"><a href="#cb279-2" aria-hidden="true"></a>{</span>
<span id="cb279-3"><a href="#cb279-3" aria-hidden="true"></a>   <span class="bu">std::</span>cout &lt;&lt; *p;</span>
<span id="cb279-4"><a href="#cb279-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>The function can then be passed a constant variable by using a const cast.</p>
<div class="sourceCode" id="cb280"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb280-1"><a href="#cb280-1" aria-hidden="true"></a>print(&amp;myConst); <span class="co">// error: cannot convert </span></span>
<span id="cb280-2"><a href="#cb280-2" aria-hidden="true"></a>                 <span class="co">// const int* to int*</span></span>
<span id="cb280-3"><a href="#cb280-3" aria-hidden="true"></a></span>
<span id="cb280-4"><a href="#cb280-4" aria-hidden="true"></a>print(nonConst); <span class="co">// allowed</span></span></code></pre></div>
<p><a href="http://www.pvtuts.com/cpp/cpp-type-conversion-i">Source and More Explanations</a></p>
</section>
<section id="answer-3-score-78-1" class="level4">
<h4>Answer 3 (score 78)</h4>
<p>You should look at the article <em><a href="http://en.wikibooks.org/wiki/C%2B%2B_Programming/Programming_Languages/C%2B%2B/Code/Statements/Variables/Type_Casting" rel="noreferrer">C++ Programming/Type Casting</a></em>.</p>
<p>It contains a good description of all of the different cast types. The following taken from the above link:</p>
<blockquote>
<p>const_cast</p>
<p>
const_cast(expression) The const_cast&lt;&gt;() is used to add/remove const(ness) (or volatile-ness) of a variable.
</p>
<p>static_cast</p>
<p>
static_cast(expression) The static_cast&lt;&gt;() is used to cast between the integer types. ‘e.g.’ char-&gt;long, int-&gt;short etc.
</p>
<p>
Static cast is also used to cast pointers to related types, for example casting void* to the appropriate type.
</p>
<p>dynamic_cast</p>
<p>
Dynamic cast is used to convert pointers and references at run-time, generally for the purpose of casting a pointer or reference up or down an inheritance chain (inheritance hierarchy).
</p>
<p>dynamic_cast(expression)</p>
<p>
The target type must be a pointer or reference type, and the expression must evaluate to a pointer or reference. Dynamic cast works only when the type of object to which the expression refers is compatible with the target type and the base class has at least one virtual member function. If not, and the type of expression being cast is a pointer, NULL is returned, if a dynamic cast on a reference fails, a bad_cast exception is thrown. When it doesn’t fail, dynamic cast returns a pointer or reference of the target type to the object to which expression referred.
</p>
<p>reinterpret_cast</p>
<p>
Reinterpret cast simply casts one type bitwise to another. Any pointer or integral type can be casted to any other with reinterpret cast, easily allowing for misuse. For instance, with reinterpret cast one might, unsafely, cast an integer pointer to a string pointer.
</p>
</blockquote>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="remove-secure-warnings-_crt_secure_no_warnings-from-projects-by-default-in-visual-studio-score-653402-in-2017" class="level3">
<h3>41: Remove secure warnings (_CRT_SECURE_NO_WARNINGS) from projects by default in Visual Studio (score <a href="https://stackoverflow.com/q/16883037.html">653402</a> in 2017)</h3>
<section id="question-39" class="level4">
<h4>Question</h4>
<p>Is there a way to set by default for all projects removing the precompiler secure warnings that come up when using functions like scanf(). I found that you can do it by adding a line in the project option or a <code>#define _CRT_SECURE_NO_WARNINGS</code> in the beginning of the code.</p>
<p>I find myself repeatedly creating new projects for solving programming contests and it is really annoying (and takes valuable time) to add:</p>
<div class="sourceCode" id="cb281"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb281-1"><a href="#cb281-1" aria-hidden="true"></a></span>
<span id="cb281-2"><a href="#cb281-2" aria-hidden="true"></a><span class="pp">#ifdef _MSC_VER</span></span>
<span id="cb281-3"><a href="#cb281-3" aria-hidden="true"></a></span>
<span id="cb281-4"><a href="#cb281-4" aria-hidden="true"></a><span class="pp">#define _CRT_SECURE_NO_WARNINGS</span></span>
<span id="cb281-5"><a href="#cb281-5" aria-hidden="true"></a></span>
<span id="cb281-6"><a href="#cb281-6" aria-hidden="true"></a><span class="pp">#endif</span></span></code></pre></div>
<p>In the beginning of the code, or to set it in the precompiler options every time I start a new project.</p>
</section>
<section id="answer-2-score-261" class="level4">
<h4>Answer 2 (score 261)</h4>
<p>Mark all the desired projects in solution explorer.</p>
<p>Press Alt-F7 or right click in solution explorer and select “Properties”</p>
<p>Configurations:All Configurations</p>
<p>
Click on the Preprocessor Definitions line to invoke its editor
</p>
<p>
Choose Edit…
</p>
<p>Copy "_CRT_SECURE_NO_WARNINGS" into the Preprocessor Definitions white box on the top.</p>
<p><img src="https://i.stack.imgur.com/VjogY.png" alt="enter image description here"></p>
</section>
<section id="answer-3-score-79" class="level4">
<h4>Answer 3 (score 79)</h4>
<p>It may have been because I am still new to VS and definitely new to C, but the only thing that allowed me to build was adding</p>
<div class="sourceCode" id="cb282"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb282-1"><a href="#cb282-1" aria-hidden="true"></a></span>
<span id="cb282-2"><a href="#cb282-2" aria-hidden="true"></a><span class="pp">#pragma warning(disable:4996)</span></span></code></pre></div>
<p>At the top of my file, this suppressed the C4996 error I was getting with sprintf</p>
<p>A bit annoying but perfect for my tiny bit of code and by far the easiest.</p>
<p>I read about it here: <a href="https://msdn.microsoft.com/en-us/library/2c8f766e.aspx">https://msdn.microsoft.com/en-us/library/2c8f766e.aspx</a></p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="simple-example-of-threading-in-c-score-652032-in-2019" class="level3">
<h3>42: Simple example of threading in C++ (score <a href="https://stackoverflow.com/q/266168.html">652032</a> in 2019)</h3>
<section id="question-40" class="level4">
<h4>Question</h4>
<p>Can someone post a simple example of starting two (Object Oriented) threads in C++.</p>
<p>I’m looking for actual C++ thread objects that I can extend run methods on (or something similar) as opposed to calling a C-style thread library.</p>
<p>I left out any OS specific requests in the hopes that whoever replied would reply with cross platform libraries to use. I’m just making that explicit now.</p>
</section>
<section id="answer-accepted-score-530" class="level4">
<h4>Answer accepted (score 530)</h4>
<p>Create a function that you want the thread to execute, eg:</p>
<div class="sourceCode" id="cb283"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb283-1"><a href="#cb283-1" aria-hidden="true"></a><span class="dt">void</span> task1(<span class="bu">std::</span>string msg)</span>
<span id="cb283-2"><a href="#cb283-2" aria-hidden="true"></a>{</span>
<span id="cb283-3"><a href="#cb283-3" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;task1 says: &quot;</span> &lt;&lt; msg;</span>
<span id="cb283-4"><a href="#cb283-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>Now create the <code>thread</code> object that will ultimately invoke the function above like so:</p>
<div class="sourceCode" id="cb284"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb284-1"><a href="#cb284-1" aria-hidden="true"></a><span class="bu">std::</span>thread t1(task1, <span class="st">&quot;Hello&quot;</span>);</span></code></pre></div>
<p>(You need to <code>#include &amp;lt;thread&amp;gt;</code> to access the <code>std::thread</code> class)</p>
<p>The constructor’s arguments are the function the thread will execute, followed by the function’s parameters. The thread is automatically started upon construction.</p>
<p>If later on you want to wait for the thread to be done executing the function, call:</p>
<div class="sourceCode" id="cb285"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb285-1"><a href="#cb285-1" aria-hidden="true"></a>t1.join(); </span></code></pre></div>
<p>(Joining means that the thread who invoked the new thread will wait for the new thread to finish execution, before it will continue its own execution).</p>
<hr>
<h5>
The Code
</h2>
<div class="sourceCode" id="cb286"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb286-1"><a href="#cb286-1" aria-hidden="true"></a></span>
<span id="cb286-2"><a href="#cb286-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb286-3"><a href="#cb286-3" aria-hidden="true"></a></span>
<span id="cb286-4"><a href="#cb286-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb286-5"><a href="#cb286-5" aria-hidden="true"></a></span>
<span id="cb286-6"><a href="#cb286-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;thread&gt;</span></span>
<span id="cb286-7"><a href="#cb286-7" aria-hidden="true"></a></span>
<span id="cb286-8"><a href="#cb286-8" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb286-9"><a href="#cb286-9" aria-hidden="true"></a></span>
<span id="cb286-10"><a href="#cb286-10" aria-hidden="true"></a><span class="co">// The function we want to execute on the new thread.</span></span>
<span id="cb286-11"><a href="#cb286-11" aria-hidden="true"></a><span class="dt">void</span> task1(string msg)</span>
<span id="cb286-12"><a href="#cb286-12" aria-hidden="true"></a>{</span>
<span id="cb286-13"><a href="#cb286-13" aria-hidden="true"></a>    cout &lt;&lt; <span class="st">&quot;task1 says: &quot;</span> &lt;&lt; msg;</span>
<span id="cb286-14"><a href="#cb286-14" aria-hidden="true"></a>}</span>
<span id="cb286-15"><a href="#cb286-15" aria-hidden="true"></a></span>
<span id="cb286-16"><a href="#cb286-16" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb286-17"><a href="#cb286-17" aria-hidden="true"></a>{</span>
<span id="cb286-18"><a href="#cb286-18" aria-hidden="true"></a>    <span class="co">// Constructs the new thread and runs it. Does not block execution.</span></span>
<span id="cb286-19"><a href="#cb286-19" aria-hidden="true"></a>    thread t1(task1, <span class="st">&quot;Hello&quot;</span>);</span>
<span id="cb286-20"><a href="#cb286-20" aria-hidden="true"></a></span>
<span id="cb286-21"><a href="#cb286-21" aria-hidden="true"></a>    <span class="co">// Do other things...</span></span>
<span id="cb286-22"><a href="#cb286-22" aria-hidden="true"></a></span>
<span id="cb286-23"><a href="#cb286-23" aria-hidden="true"></a>    <span class="co">// Makes the main thread wait for the new thread to finish execution, therefore blocks its own execution.</span></span>
<span id="cb286-24"><a href="#cb286-24" aria-hidden="true"></a>    t1.join();</span>
<span id="cb286-25"><a href="#cb286-25" aria-hidden="true"></a>}</span></code></pre></div>
<p><a href="http://en.cppreference.com/w/cpp/thread/thread" rel="noreferrer">More information about std::thread here</a></p>
<ul>
<li>
<em>On GCC, compile with <code>-std=c++0x -pthread</code>.</em>
</li>
<li>
<em>This should work for any operating-system, granted your compiler supports this (C++11) feature.</em>
</li>
</ul>
</section>
<section id="answer-2-score-78" class="level4">
<h4>Answer 2 (score 78)</h4>
<p>Well, technically any such object will wind up being built over a C-style thread library because C++ only just specified a stock <a href="http://en.cppreference.com/w/cpp/thread/thread" rel="noreferrer"><code>std::thread</code></a> model in c++0x, which was just nailed down and hasn’t yet been implemented. The problem is somewhat systemic, technically the existing c++ memory model isn’t strict enough to allow for well defined semantics for all of the ‘happens before’ cases. Hans Boehm wrote an paper on the topic a while back and was instrumental in hammering out the c++0x standard on the topic.</p>
<p><a href="http://www.hpl.hp.com/techreports/2004/HPL-2004-209.html" rel="noreferrer">http://www.hpl.hp.com/techreports/2004/HPL-2004-209.html</a></p>
<p>That said there are several cross-platform thread C++ libraries that work just fine in practice. Intel thread building blocks contains a tbb::thread object that closely approximates the c++0x standard and Boost has a boost::thread library that does the same.</p>
<p><a href="http://www.threadingbuildingblocks.org/" rel="noreferrer">http://www.threadingbuildingblocks.org/</a></p>
<p><a href="http://www.boost.org/doc/libs/1_37_0/doc/html/thread.html" rel="noreferrer">http://www.boost.org/doc/libs/1_37_0/doc/html/thread.html</a></p>
<p>Using boost::thread you’d get something like:</p>
<div class="sourceCode" id="cb287"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb287-1"><a href="#cb287-1" aria-hidden="true"></a></span>
<span id="cb287-2"><a href="#cb287-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;boost/thread.hpp&gt;</span></span>
<span id="cb287-3"><a href="#cb287-3" aria-hidden="true"></a></span>
<span id="cb287-4"><a href="#cb287-4" aria-hidden="true"></a><span class="dt">void</span> task1() { </span>
<span id="cb287-5"><a href="#cb287-5" aria-hidden="true"></a>    <span class="co">// do stuff</span></span>
<span id="cb287-6"><a href="#cb287-6" aria-hidden="true"></a>}</span>
<span id="cb287-7"><a href="#cb287-7" aria-hidden="true"></a></span>
<span id="cb287-8"><a href="#cb287-8" aria-hidden="true"></a><span class="dt">void</span> task2() { </span>
<span id="cb287-9"><a href="#cb287-9" aria-hidden="true"></a>    <span class="co">// do stuff</span></span>
<span id="cb287-10"><a href="#cb287-10" aria-hidden="true"></a>}</span>
<span id="cb287-11"><a href="#cb287-11" aria-hidden="true"></a></span>
<span id="cb287-12"><a href="#cb287-12" aria-hidden="true"></a><span class="dt">int</span> main (<span class="dt">int</span> argc, <span class="dt">char</span> ** argv) {</span>
<span id="cb287-13"><a href="#cb287-13" aria-hidden="true"></a>    <span class="kw">using</span> <span class="kw">namespace</span> boost; </span>
<span id="cb287-14"><a href="#cb287-14" aria-hidden="true"></a>    thread thread_1 = thread(task1);</span>
<span id="cb287-15"><a href="#cb287-15" aria-hidden="true"></a>    thread thread_2 = thread(task2);</span>
<span id="cb287-16"><a href="#cb287-16" aria-hidden="true"></a></span>
<span id="cb287-17"><a href="#cb287-17" aria-hidden="true"></a>    <span class="co">// do other stuff</span></span>
<span id="cb287-18"><a href="#cb287-18" aria-hidden="true"></a>    thread_2.join();</span>
<span id="cb287-19"><a href="#cb287-19" aria-hidden="true"></a>    thread_1.join();</span>
<span id="cb287-20"><a href="#cb287-20" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb287-21"><a href="#cb287-21" aria-hidden="true"></a>}</span></code></pre></div>
</section>
<section id="answer-3-score-20" class="level4">
<h4>Answer 3 (score 20)</h4>
<p>
There is also a POSIX library for POSIX operating systems. <a href="http://en.wikipedia.org/wiki/POSIX" rel="nofollow noreferrer">Check</a> for compatability
</p>
<div class="sourceCode" id="cb288"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb288-1"><a href="#cb288-1" aria-hidden="true"></a></span>
<span id="cb288-2"><a href="#cb288-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb288-3"><a href="#cb288-3" aria-hidden="true"></a></span>
<span id="cb288-4"><a href="#cb288-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb288-5"><a href="#cb288-5" aria-hidden="true"></a></span>
<span id="cb288-6"><a href="#cb288-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;pthread.h&gt;</span></span>
<span id="cb288-7"><a href="#cb288-7" aria-hidden="true"></a></span>
<span id="cb288-8"><a href="#cb288-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb288-9"><a href="#cb288-9" aria-hidden="true"></a></span>
<span id="cb288-10"><a href="#cb288-10" aria-hidden="true"></a><span class="dt">void</span> *task(<span class="dt">void</span> *argument){</span>
<span id="cb288-11"><a href="#cb288-11" aria-hidden="true"></a>      <span class="dt">char</span>* msg;</span>
<span id="cb288-12"><a href="#cb288-12" aria-hidden="true"></a>      msg = (<span class="dt">char</span>*)argument;</span>
<span id="cb288-13"><a href="#cb288-13" aria-hidden="true"></a>      <span class="bu">std::</span>cout&lt;&lt;msg&lt;&lt;<span class="bu">std::</span>endl;</span>
<span id="cb288-14"><a href="#cb288-14" aria-hidden="true"></a>}</span>
<span id="cb288-15"><a href="#cb288-15" aria-hidden="true"></a></span>
<span id="cb288-16"><a href="#cb288-16" aria-hidden="true"></a><span class="dt">int</span> main(){</span>
<span id="cb288-17"><a href="#cb288-17" aria-hidden="true"></a>    <span class="dt">pthread_t</span> thread1, thread2;</span>
<span id="cb288-18"><a href="#cb288-18" aria-hidden="true"></a>    <span class="dt">int</span> i1,i2;</span>
<span id="cb288-19"><a href="#cb288-19" aria-hidden="true"></a>    i1 = pthread_create( &amp;thread1, NULL, task, (<span class="dt">void</span>*) <span class="st">&quot;thread 1&quot;</span>);</span>
<span id="cb288-20"><a href="#cb288-20" aria-hidden="true"></a>    i2 = pthread_create( &amp;thread2, NULL, task, (<span class="dt">void</span>*) <span class="st">&quot;thread 2&quot;</span>);</span>
<span id="cb288-21"><a href="#cb288-21" aria-hidden="true"></a></span>
<span id="cb288-22"><a href="#cb288-22" aria-hidden="true"></a>    pthread_join(thread1,NULL);</span>
<span id="cb288-23"><a href="#cb288-23" aria-hidden="true"></a>    pthread_join(thread2,NULL);</span>
<span id="cb288-24"><a href="#cb288-24" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb288-25"><a href="#cb288-25" aria-hidden="true"></a></span>
<span id="cb288-26"><a href="#cb288-26" aria-hidden="true"></a>}</span></code></pre></div>
<p>compile with -lpthread</p>
<p><a href="http://en.wikipedia.org/wiki/POSIX_Threads" rel="nofollow noreferrer">http://en.wikipedia.org/wiki/POSIX_Threads</a></p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="when-to-use-virtual-destructors-score-650734-in-2019" class="level3">
<h3>43: When to use virtual destructors? (score <a href="https://stackoverflow.com/q/461203.html">650734</a> in 2019)</h3>
<section id="question-41" class="level4">
<h4>Question</h4>
<p>I have a solid understanding of most OO theory but the one thing that confuses me a lot is virtual destructors.</p>
<p>I thought that the destructor always gets called no matter what and for every object in the chain.</p>
<p>When are you meant to make them virtual and why?</p>
</section>
<section id="answer-accepted-score-1491" class="level4">
<h4>Answer accepted (score 1491)</h4>
<p>Virtual destructors are useful when you might potentially delete an instance of a derived class through a pointer to base class:</p>
<div class="sourceCode" id="cb289"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb289-1"><a href="#cb289-1" aria-hidden="true"></a><span class="kw">class</span> Base </span>
<span id="cb289-2"><a href="#cb289-2" aria-hidden="true"></a>{</span>
<span id="cb289-3"><a href="#cb289-3" aria-hidden="true"></a>    <span class="co">// some virtual methods</span></span>
<span id="cb289-4"><a href="#cb289-4" aria-hidden="true"></a>};</span>
<span id="cb289-5"><a href="#cb289-5" aria-hidden="true"></a></span>
<span id="cb289-6"><a href="#cb289-6" aria-hidden="true"></a><span class="kw">class</span> Derived : <span class="kw">public</span> Base</span>
<span id="cb289-7"><a href="#cb289-7" aria-hidden="true"></a>{</span>
<span id="cb289-8"><a href="#cb289-8" aria-hidden="true"></a>    ~Derived()</span>
<span id="cb289-9"><a href="#cb289-9" aria-hidden="true"></a>    {</span>
<span id="cb289-10"><a href="#cb289-10" aria-hidden="true"></a>        <span class="co">// Do some important cleanup</span></span>
<span id="cb289-11"><a href="#cb289-11" aria-hidden="true"></a>    }</span>
<span id="cb289-12"><a href="#cb289-12" aria-hidden="true"></a>};</span></code></pre></div>
<p>Here, you’ll notice that I didn’t declare Base’s destructor to be <code>virtual</code>. Now, let’s have a look at the following snippet:</p>
<div class="sourceCode" id="cb290"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb290-1"><a href="#cb290-1" aria-hidden="true"></a>Base *b = <span class="kw">new</span> Derived();</span>
<span id="cb290-2"><a href="#cb290-2" aria-hidden="true"></a><span class="co">// use b</span></span>
<span id="cb290-3"><a href="#cb290-3" aria-hidden="true"></a><span class="kw">delete</span> b; <span class="co">// Here&#39;s the problem!</span></span></code></pre></div>
<p>Since Base’s destructor is not <code>virtual</code> and <code>b</code> is a <code>Base*</code> pointing to a <code>Derived</code> object, <code>delete b</code> has <a href="https://stackoverflow.com/q/2397984/20984">undefined behaviour</a>:</p>
<blockquote>
<p>
[In <code>delete b</code>], if the static type of the object to be deleted is different from its dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and <strong>the static type shall have a virtual destructor or the behavior is undefined</strong>.
</p>
</blockquote>
<p>In most implementations, the call to the destructor will be resolved like any non-virtual code, meaning that the destructor of the base class will be called but not the one of the derived class, resulting in a resources leak.</p>
<p>To sum up, always make base classes’ destructors <code>virtual</code> when they’re meant to be manipulated polymorphically.</p>
<p>If you want to prevent the deletion of an instance through a base class pointer, you can make the base class destructor protected and nonvirtual; by doing so, the compiler won’t let you call <code>delete</code> on a base class pointer.</p>
<p>You can learn more about virtuality and virtual base class destructor in <a href="http://www.gotw.ca/publications/mill18.htm" rel="noreferrer">this article from Herb Sutter</a>.</p>
</section>
<section id="answer-2-score-194-1" class="level4">
<h4>Answer 2 (score 194)</h4>
<p>
A virtual constructor is not possible but virtual destructor is possible. Let us experiment….
</p>
<div class="sourceCode" id="cb291"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb291-1"><a href="#cb291-1" aria-hidden="true"></a></span>
<span id="cb291-2"><a href="#cb291-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb291-3"><a href="#cb291-3" aria-hidden="true"></a></span>
<span id="cb291-4"><a href="#cb291-4" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb291-5"><a href="#cb291-5" aria-hidden="true"></a></span>
<span id="cb291-6"><a href="#cb291-6" aria-hidden="true"></a><span class="kw">class</span> Base</span>
<span id="cb291-7"><a href="#cb291-7" aria-hidden="true"></a>{</span>
<span id="cb291-8"><a href="#cb291-8" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb291-9"><a href="#cb291-9" aria-hidden="true"></a>    Base(){</span>
<span id="cb291-10"><a href="#cb291-10" aria-hidden="true"></a>        cout &lt;&lt; <span class="st">&quot;Base Constructor Called</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb291-11"><a href="#cb291-11" aria-hidden="true"></a>    }</span>
<span id="cb291-12"><a href="#cb291-12" aria-hidden="true"></a>    ~Base(){</span>
<span id="cb291-13"><a href="#cb291-13" aria-hidden="true"></a>        cout &lt;&lt; <span class="st">&quot;Base Destructor called</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb291-14"><a href="#cb291-14" aria-hidden="true"></a>    }</span>
<span id="cb291-15"><a href="#cb291-15" aria-hidden="true"></a>};</span>
<span id="cb291-16"><a href="#cb291-16" aria-hidden="true"></a></span>
<span id="cb291-17"><a href="#cb291-17" aria-hidden="true"></a><span class="kw">class</span> Derived1: <span class="kw">public</span> Base</span>
<span id="cb291-18"><a href="#cb291-18" aria-hidden="true"></a>{</span>
<span id="cb291-19"><a href="#cb291-19" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb291-20"><a href="#cb291-20" aria-hidden="true"></a>    Derived1(){</span>
<span id="cb291-21"><a href="#cb291-21" aria-hidden="true"></a>        cout &lt;&lt; <span class="st">&quot;Derived constructor called</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb291-22"><a href="#cb291-22" aria-hidden="true"></a>    }</span>
<span id="cb291-23"><a href="#cb291-23" aria-hidden="true"></a>    ~Derived1(){</span>
<span id="cb291-24"><a href="#cb291-24" aria-hidden="true"></a>        cout &lt;&lt; <span class="st">&quot;Derived destructor called</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb291-25"><a href="#cb291-25" aria-hidden="true"></a>    }</span>
<span id="cb291-26"><a href="#cb291-26" aria-hidden="true"></a>};</span>
<span id="cb291-27"><a href="#cb291-27" aria-hidden="true"></a></span>
<span id="cb291-28"><a href="#cb291-28" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb291-29"><a href="#cb291-29" aria-hidden="true"></a>{</span>
<span id="cb291-30"><a href="#cb291-30" aria-hidden="true"></a>    Base *b = <span class="kw">new</span> Derived1();</span>
<span id="cb291-31"><a href="#cb291-31" aria-hidden="true"></a>    <span class="kw">delete</span> b;</span>
<span id="cb291-32"><a href="#cb291-32" aria-hidden="true"></a>}</span></code></pre></div>
<p>The above code output the following:</p>
<div class="sourceCode" id="cb292"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb292-1"><a href="#cb292-1" aria-hidden="true"></a>Base Constructor Called</span>
<span id="cb292-2"><a href="#cb292-2" aria-hidden="true"></a>Derived constructor called</span>
<span id="cb292-3"><a href="#cb292-3" aria-hidden="true"></a>Base Destructor called</span></code></pre></div>
<p>
The construction of derived object follow the construction rule but when we delete the “b” pointer(base pointer) we have found that only the base destructor is called. But this must not be happen. To do the appropriate thing, we have to make the base destructor virtual. Now let see what happens in the following:
</p>
<div class="sourceCode" id="cb293"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb293-1"><a href="#cb293-1" aria-hidden="true"></a></span>
<span id="cb293-2"><a href="#cb293-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb293-3"><a href="#cb293-3" aria-hidden="true"></a></span>
<span id="cb293-4"><a href="#cb293-4" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb293-5"><a href="#cb293-5" aria-hidden="true"></a></span>
<span id="cb293-6"><a href="#cb293-6" aria-hidden="true"></a><span class="kw">class</span> Base</span>
<span id="cb293-7"><a href="#cb293-7" aria-hidden="true"></a>{ </span>
<span id="cb293-8"><a href="#cb293-8" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb293-9"><a href="#cb293-9" aria-hidden="true"></a>    Base(){</span>
<span id="cb293-10"><a href="#cb293-10" aria-hidden="true"></a>        cout &lt;&lt; <span class="st">&quot;Base Constructor Called</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb293-11"><a href="#cb293-11" aria-hidden="true"></a>    }</span>
<span id="cb293-12"><a href="#cb293-12" aria-hidden="true"></a>    <span class="kw">virtual</span> ~Base(){</span>
<span id="cb293-13"><a href="#cb293-13" aria-hidden="true"></a>        cout &lt;&lt; <span class="st">&quot;Base Destructor called</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb293-14"><a href="#cb293-14" aria-hidden="true"></a>    }</span>
<span id="cb293-15"><a href="#cb293-15" aria-hidden="true"></a>};</span>
<span id="cb293-16"><a href="#cb293-16" aria-hidden="true"></a></span>
<span id="cb293-17"><a href="#cb293-17" aria-hidden="true"></a><span class="kw">class</span> Derived1: <span class="kw">public</span> Base</span>
<span id="cb293-18"><a href="#cb293-18" aria-hidden="true"></a>{</span>
<span id="cb293-19"><a href="#cb293-19" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb293-20"><a href="#cb293-20" aria-hidden="true"></a>    Derived1(){</span>
<span id="cb293-21"><a href="#cb293-21" aria-hidden="true"></a>        cout &lt;&lt; <span class="st">&quot;Derived constructor called</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb293-22"><a href="#cb293-22" aria-hidden="true"></a>    }</span>
<span id="cb293-23"><a href="#cb293-23" aria-hidden="true"></a>    ~Derived1(){</span>
<span id="cb293-24"><a href="#cb293-24" aria-hidden="true"></a>        cout &lt;&lt; <span class="st">&quot;Derived destructor called</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb293-25"><a href="#cb293-25" aria-hidden="true"></a>    }</span>
<span id="cb293-26"><a href="#cb293-26" aria-hidden="true"></a>};</span>
<span id="cb293-27"><a href="#cb293-27" aria-hidden="true"></a></span>
<span id="cb293-28"><a href="#cb293-28" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb293-29"><a href="#cb293-29" aria-hidden="true"></a>{</span>
<span id="cb293-30"><a href="#cb293-30" aria-hidden="true"></a>    Base *b = <span class="kw">new</span> Derived1();</span>
<span id="cb293-31"><a href="#cb293-31" aria-hidden="true"></a>    <span class="kw">delete</span> b;</span>
<span id="cb293-32"><a href="#cb293-32" aria-hidden="true"></a>}</span></code></pre></div>
<p>The output changed as following:</p>
<div class="sourceCode" id="cb294"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb294-1"><a href="#cb294-1" aria-hidden="true"></a>Base Constructor Called</span>
<span id="cb294-2"><a href="#cb294-2" aria-hidden="true"></a>Derived Constructor called</span>
<span id="cb294-3"><a href="#cb294-3" aria-hidden="true"></a>Derived destructor called</span>
<span id="cb294-4"><a href="#cb294-4" aria-hidden="true"></a>Base destructor called</span></code></pre></div>
<p>
So the destruction of the base pointer (which takes an allocation on derived object!) follows the destruction rule, i.e first the Derived, then the Base. On the other hand, there is nothing like a virtual constructor.
</p>
</section>
<section id="answer-3-score-185" class="level4">
<h4>Answer 3 (score 185)</h4>
<p>Declare destructors virtual in polymorphic base classes. This is Item 7 in Scott Meyers’ <a href="https://rads.stackoverflow.com/amzn/click/com/0201924889" rel="noreferrer" rel="nofollow noreferrer">Effective C++</a>. Meyers goes on to summarize that if a class has <em>any</em> virtual function, it should have a virtual destructor, and that classes not designed to be base classes or not designed to be used polymorphically should <em>not</em> declare virtual destructors.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="difference-between-private-public-and-protected-inheritance-score-643153-in-2018" class="level3">
<h3>44: Difference between private, public, and protected inheritance (score <a href="https://stackoverflow.com/q/860339.html">643153</a> in 2018)</h3>
<section id="question-42" class="level4">
<h4>Question</h4>
<p>What is the difference between <code>public</code>, <code>private</code>, and <code>protected</code> inheritance in C++? All of the questions I’ve found on SO deal with specific cases.</p>
</section>
<section id="answer-accepted-score-1013" class="level4">
<h4>Answer accepted (score 1013)</h4>
<p>To answer that question, I’d like to describe member’s accessors first in my own words. If you already know this, skip to the heading “next:”.</p>
<p>There are three accessors that I’m aware of: <code>public</code>, <code>protected</code> and <code>private</code>.</p>
<p>Let:</p>
<div class="sourceCode" id="cb295"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb295-1"><a href="#cb295-1" aria-hidden="true"></a><span class="kw">class</span> Base {</span>
<span id="cb295-2"><a href="#cb295-2" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb295-3"><a href="#cb295-3" aria-hidden="true"></a>        <span class="dt">int</span> publicMember;</span>
<span id="cb295-4"><a href="#cb295-4" aria-hidden="true"></a>    <span class="kw">protected</span>:</span>
<span id="cb295-5"><a href="#cb295-5" aria-hidden="true"></a>        <span class="dt">int</span> protectedMember;</span>
<span id="cb295-6"><a href="#cb295-6" aria-hidden="true"></a>    <span class="kw">private</span>:</span>
<span id="cb295-7"><a href="#cb295-7" aria-hidden="true"></a>        <span class="dt">int</span> privateMember;</span>
<span id="cb295-8"><a href="#cb295-8" aria-hidden="true"></a>};</span></code></pre></div>
<ul>
<li>
Everything that is aware of <code>Base</code> is also aware that <code>Base</code> contains <code>publicMember</code>.
</li>
<li>
Only the children (and their children) are aware that <code>Base</code> contains <code>protectedMember</code>.
</li>
<li>
No one but <code>Base</code> is aware of <code>privateMember</code>.
</li>
</ul>
<p>By “is aware of”, I mean “acknowledge the existence of, and thus be able to access”.</p>
<h5>
next:
</h2>
<p>The same happens with public, private and protected inheritance. Let’s consider a class <code>Base</code> and a class <code>Child</code> that inherits from <code>Base</code>.</p>
<ul>
<li>
If the inheritance is <code>public</code>, everything that is aware of <code>Base</code> and <code>Child</code> is also aware that <code>Child</code> inherits from <code>Base</code>.
</li>
<li>
If the inheritance is <code>protected</code>, only <code>Child</code>, and its children, are aware that they inherit from <code>Base</code>.
</li>
<li>
If the inheritance is <code>private</code>, no one other than <code>Child</code> is aware of the inheritance.
</li>
</ul>
</section>
<section id="answer-2-score-1385" class="level4">
<h4>Answer 2 (score 1385)</h4>
<div class="sourceCode" id="cb296"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb296-1"><a href="#cb296-1" aria-hidden="true"></a><span class="kw">class</span> A </span>
<span id="cb296-2"><a href="#cb296-2" aria-hidden="true"></a>{</span>
<span id="cb296-3"><a href="#cb296-3" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb296-4"><a href="#cb296-4" aria-hidden="true"></a>    <span class="dt">int</span> x;</span>
<span id="cb296-5"><a href="#cb296-5" aria-hidden="true"></a><span class="kw">protected</span>:</span>
<span id="cb296-6"><a href="#cb296-6" aria-hidden="true"></a>    <span class="dt">int</span> y;</span>
<span id="cb296-7"><a href="#cb296-7" aria-hidden="true"></a><span class="kw">private</span>:</span>
<span id="cb296-8"><a href="#cb296-8" aria-hidden="true"></a>    <span class="dt">int</span> z;</span>
<span id="cb296-9"><a href="#cb296-9" aria-hidden="true"></a>};</span>
<span id="cb296-10"><a href="#cb296-10" aria-hidden="true"></a></span>
<span id="cb296-11"><a href="#cb296-11" aria-hidden="true"></a><span class="kw">class</span> B : <span class="kw">public</span> A</span>
<span id="cb296-12"><a href="#cb296-12" aria-hidden="true"></a>{</span>
<span id="cb296-13"><a href="#cb296-13" aria-hidden="true"></a>    <span class="co">// x is public</span></span>
<span id="cb296-14"><a href="#cb296-14" aria-hidden="true"></a>    <span class="co">// y is protected</span></span>
<span id="cb296-15"><a href="#cb296-15" aria-hidden="true"></a>    <span class="co">// z is not accessible from B</span></span>
<span id="cb296-16"><a href="#cb296-16" aria-hidden="true"></a>};</span>
<span id="cb296-17"><a href="#cb296-17" aria-hidden="true"></a></span>
<span id="cb296-18"><a href="#cb296-18" aria-hidden="true"></a><span class="kw">class</span> C : <span class="kw">protected</span> A</span>
<span id="cb296-19"><a href="#cb296-19" aria-hidden="true"></a>{</span>
<span id="cb296-20"><a href="#cb296-20" aria-hidden="true"></a>    <span class="co">// x is protected</span></span>
<span id="cb296-21"><a href="#cb296-21" aria-hidden="true"></a>    <span class="co">// y is protected</span></span>
<span id="cb296-22"><a href="#cb296-22" aria-hidden="true"></a>    <span class="co">// z is not accessible from C</span></span>
<span id="cb296-23"><a href="#cb296-23" aria-hidden="true"></a>};</span>
<span id="cb296-24"><a href="#cb296-24" aria-hidden="true"></a></span>
<span id="cb296-25"><a href="#cb296-25" aria-hidden="true"></a><span class="kw">class</span> D : <span class="kw">private</span> A    <span class="co">// &#39;private&#39; is default for classes</span></span>
<span id="cb296-26"><a href="#cb296-26" aria-hidden="true"></a>{</span>
<span id="cb296-27"><a href="#cb296-27" aria-hidden="true"></a>    <span class="co">// x is private</span></span>
<span id="cb296-28"><a href="#cb296-28" aria-hidden="true"></a>    <span class="co">// y is private</span></span>
<span id="cb296-29"><a href="#cb296-29" aria-hidden="true"></a>    <span class="co">// z is not accessible from D</span></span>
<span id="cb296-30"><a href="#cb296-30" aria-hidden="true"></a>};</span></code></pre></div>
<p>IMPORTANT NOTE: Classes B, C and D all contain the variables x, y and z. It is just question of access.</p>
<p>About usage of protected and private inheritance you could read <a href="https://stackoverflow.com/questions/374399/private-protected-inheritance/374423">here</a>.</p>
</section>
<section id="answer-3-score-108" class="level4">
<h4>Answer 3 (score 108)</h4>
<p>Limiting the visibility of inheritance will make code not able to see that some class inherits another class: Implicit conversions from the derived to the base won’t work, and <code>static_cast</code> from the base to the derived won’t work either.</p>
<p>Only members/friends of a class can see private inheritance, and only members/friends and derived classes can see protected inheritance.</p>
<p><strong>public</strong> inheritance</p>
<ol>
<li>
<p>
IS-A inheritance. A button is-a window, and anywhere where a window is needed, a button can be passed too.
</p>
<div class="sourceCode" id="cb297"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb297-1"><a href="#cb297-1" aria-hidden="true"></a><span class="kw">class</span> button : <span class="kw">public</span> window { };</span>
<span id="cb297-2"><a href="#cb297-2" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb297-3"><a href="#cb297-3" aria-hidden="true"></a>&lt;/ol&gt;</span>
<span id="cb297-4"><a href="#cb297-4" aria-hidden="true"></a></span>
<span id="cb297-5"><a href="#cb297-5" aria-hidden="true"></a>&lt;strong&gt;<span class="kw">protected</span>&lt;/strong&gt; inheritance  </span>
<span id="cb297-6"><a href="#cb297-6" aria-hidden="true"></a></span>
<span id="cb297-7"><a href="#cb297-7" aria-hidden="true"></a>&lt;ol&gt;</span>
<span id="cb297-8"><a href="#cb297-8" aria-hidden="true"></a>&lt;li&gt;&lt;p&gt;Protected implemented-in-terms-of. Rarely useful. Used in <span class="er">`</span><span class="ex">boost::</span>compressed_pair<span class="ex">`</span> to derive from empty classes <span class="kw">and</span> save memory <span class="kw">using</span> empty base <span class="kw">class</span> optimization (example below doesn<span class="ch">&#39;t</span><span class="er"> use template to keep being at the point):&lt;/p&gt;</span></span>
<span id="cb297-9"><a href="#cb297-9" aria-hidden="true"></a></span>
<span id="cb297-10"><a href="#cb297-10" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb297-11"><a href="#cb297-11" aria-hidden="true"></a><span class="kw">struct</span> empty_pair_impl : <span class="kw">protected</span> empty_class_1 </span>
<span id="cb297-12"><a href="#cb297-12" aria-hidden="true"></a>{ non_empty_class_2 second; };</span>
<span id="cb297-13"><a href="#cb297-13" aria-hidden="true"></a></span>
<span id="cb297-14"><a href="#cb297-14" aria-hidden="true"></a><span class="kw">struct</span> pair : <span class="kw">private</span> empty_pair_impl {</span>
<span id="cb297-15"><a href="#cb297-15" aria-hidden="true"></a>  non_empty_class_2 &amp;second() {</span>
<span id="cb297-16"><a href="#cb297-16" aria-hidden="true"></a>    <span class="cf">return</span> <span class="kw">this</span>-&gt;second;</span>
<span id="cb297-17"><a href="#cb297-17" aria-hidden="true"></a>  }</span>
<span id="cb297-18"><a href="#cb297-18" aria-hidden="true"></a></span>
<span id="cb297-19"><a href="#cb297-19" aria-hidden="true"></a>  empty_class_1 &amp;first() {</span>
<span id="cb297-20"><a href="#cb297-20" aria-hidden="true"></a>    <span class="cf">return</span> *<span class="kw">this</span>; <span class="co">// notice we return *this!</span></span>
<span id="cb297-21"><a href="#cb297-21" aria-hidden="true"></a>  }</span>
<span id="cb297-22"><a href="#cb297-22" aria-hidden="true"></a>};</span>
<span id="cb297-23"><a href="#cb297-23" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb297-24"><a href="#cb297-24" aria-hidden="true"></a>&lt;/ol&gt;</span>
<span id="cb297-25"><a href="#cb297-25" aria-hidden="true"></a></span>
<span id="cb297-26"><a href="#cb297-26" aria-hidden="true"></a>&lt;strong&gt;<span class="kw">private</span>&lt;/strong&gt; inheritance  </span>
<span id="cb297-27"><a href="#cb297-27" aria-hidden="true"></a></span>
<span id="cb297-28"><a href="#cb297-28" aria-hidden="true"></a>&lt;ol&gt;</span>
<span id="cb297-29"><a href="#cb297-29" aria-hidden="true"></a>&lt;li&gt;&lt;p&gt;Implemented-in-terms-of. The usage of the base <span class="kw">class</span> is only <span class="cf">for</span> implementing the derived <span class="kw">class</span>. Useful with traits <span class="kw">and</span> <span class="cf">if</span> size matters (empty traits that only contain functions will make use of the empty base <span class="kw">class</span> optimization). Often &lt;em&gt;containment&lt;/em&gt; is the better solution, though. The size <span class="cf">for</span> strings is critical, so it<span class="ch">&#39;s</span><span class="er"> an often seen usage here&lt;/p&gt;</span></span>
<span id="cb297-30"><a href="#cb297-30" aria-hidden="true"></a></span>
<span id="cb297-31"><a href="#cb297-31" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb297-32"><a href="#cb297-32" aria-hidden="true"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> StorageModel&gt;</span>
<span id="cb297-33"><a href="#cb297-33" aria-hidden="true"></a><span class="kw">struct</span> string : <span class="kw">private</span> StorageModel {</span>
<span id="cb297-34"><a href="#cb297-34" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb297-35"><a href="#cb297-35" aria-hidden="true"></a>  <span class="dt">void</span> realloc() {</span>
<span id="cb297-36"><a href="#cb297-36" aria-hidden="true"></a>    <span class="co">// uses inherited function</span></span>
<span id="cb297-37"><a href="#cb297-37" aria-hidden="true"></a>    StorageModel::realloc();</span>
<span id="cb297-38"><a href="#cb297-38" aria-hidden="true"></a>  }</span>
<span id="cb297-39"><a href="#cb297-39" aria-hidden="true"></a>};</span>
<span id="cb297-40"><a href="#cb297-40" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb297-41"><a href="#cb297-41" aria-hidden="true"></a>&lt;/ol&gt;</span>
<span id="cb297-42"><a href="#cb297-42" aria-hidden="true"></a></span>
<span id="cb297-43"><a href="#cb297-43" aria-hidden="true"></a>&lt;hr&gt;</span>
<span id="cb297-44"><a href="#cb297-44" aria-hidden="true"></a></span>
<span id="cb297-45"><a href="#cb297-45" aria-hidden="true"></a>&lt;strong&gt;<span class="kw">public</span>&lt;/strong&gt; member  </span>
<span id="cb297-46"><a href="#cb297-46" aria-hidden="true"></a></span>
<span id="cb297-47"><a href="#cb297-47" aria-hidden="true"></a>&lt;ol&gt;</span>
<span id="cb297-48"><a href="#cb297-48" aria-hidden="true"></a>&lt;li&gt;&lt;p&gt;Aggregate&lt;/p&gt;</span>
<span id="cb297-49"><a href="#cb297-49" aria-hidden="true"></a></span>
<span id="cb297-50"><a href="#cb297-50" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb297-51"><a href="#cb297-51" aria-hidden="true"></a><span class="kw">class</span> pair {</span>
<span id="cb297-52"><a href="#cb297-52" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb297-53"><a href="#cb297-53" aria-hidden="true"></a>  First first;</span>
<span id="cb297-54"><a href="#cb297-54" aria-hidden="true"></a>  Second second;</span>
<span id="cb297-55"><a href="#cb297-55" aria-hidden="true"></a>};</span>
<span id="cb297-56"><a href="#cb297-56" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb297-57"><a href="#cb297-57" aria-hidden="true"></a>&lt;li&gt;&lt;p&gt;Accessors&lt;/p&gt;</span>
<span id="cb297-58"><a href="#cb297-58" aria-hidden="true"></a></span>
<span id="cb297-59"><a href="#cb297-59" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb297-60"><a href="#cb297-60" aria-hidden="true"></a><span class="kw">class</span> window {</span>
<span id="cb297-61"><a href="#cb297-61" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb297-62"><a href="#cb297-62" aria-hidden="true"></a>    <span class="dt">int</span> getWidth() <span class="at">const</span>;</span>
<span id="cb297-63"><a href="#cb297-63" aria-hidden="true"></a>};</span>
<span id="cb297-64"><a href="#cb297-64" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb297-65"><a href="#cb297-65" aria-hidden="true"></a>&lt;/ol&gt;</span>
<span id="cb297-66"><a href="#cb297-66" aria-hidden="true"></a></span>
<span id="cb297-67"><a href="#cb297-67" aria-hidden="true"></a>&lt;strong&gt;<span class="kw">protected</span>&lt;/strong&gt; member  </span>
<span id="cb297-68"><a href="#cb297-68" aria-hidden="true"></a></span>
<span id="cb297-69"><a href="#cb297-69" aria-hidden="true"></a>&lt;ol&gt;</span>
<span id="cb297-70"><a href="#cb297-70" aria-hidden="true"></a>&lt;li&gt;&lt;p&gt;Providing enhanced access <span class="cf">for</span> derived classes&lt;/p&gt;</span>
<span id="cb297-71"><a href="#cb297-71" aria-hidden="true"></a></span>
<span id="cb297-72"><a href="#cb297-72" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb297-73"><a href="#cb297-73" aria-hidden="true"></a><span class="kw">class</span> stack {</span>
<span id="cb297-74"><a href="#cb297-74" aria-hidden="true"></a><span class="kw">protected</span>:</span>
<span id="cb297-75"><a href="#cb297-75" aria-hidden="true"></a>  vector&lt;element&gt; c;</span>
<span id="cb297-76"><a href="#cb297-76" aria-hidden="true"></a>};</span>
<span id="cb297-77"><a href="#cb297-77" aria-hidden="true"></a></span>
<span id="cb297-78"><a href="#cb297-78" aria-hidden="true"></a><span class="kw">class</span> window {</span>
<span id="cb297-79"><a href="#cb297-79" aria-hidden="true"></a><span class="kw">protected</span>:</span>
<span id="cb297-80"><a href="#cb297-80" aria-hidden="true"></a>  <span class="dt">void</span> registerClass(window_descriptor w);</span>
<span id="cb297-81"><a href="#cb297-81" aria-hidden="true"></a>};</span>
<span id="cb297-82"><a href="#cb297-82" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb297-83"><a href="#cb297-83" aria-hidden="true"></a>&lt;/ol&gt;</span>
<span id="cb297-84"><a href="#cb297-84" aria-hidden="true"></a></span>
<span id="cb297-85"><a href="#cb297-85" aria-hidden="true"></a>&lt;strong&gt;<span class="kw">private</span>&lt;/strong&gt; member  </span>
<span id="cb297-86"><a href="#cb297-86" aria-hidden="true"></a></span>
<span id="cb297-87"><a href="#cb297-87" aria-hidden="true"></a>&lt;ol&gt;</span>
<span id="cb297-88"><a href="#cb297-88" aria-hidden="true"></a>&lt;li&gt;&lt;p&gt;Keep implementation details&lt;/p&gt;</span>
<span id="cb297-89"><a href="#cb297-89" aria-hidden="true"></a></span>
<span id="cb297-90"><a href="#cb297-90" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb297-91"><a href="#cb297-91" aria-hidden="true"></a><span class="kw">class</span> window {</span>
<span id="cb297-92"><a href="#cb297-92" aria-hidden="true"></a><span class="kw">private</span>:</span>
<span id="cb297-93"><a href="#cb297-93" aria-hidden="true"></a>  <span class="dt">int</span> width;</span>
<span id="cb297-94"><a href="#cb297-94" aria-hidden="true"></a>};</span>
<span id="cb297-95"><a href="#cb297-95" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb297-96"><a href="#cb297-96" aria-hidden="true"></a>&lt;/ol&gt;</span>
<span id="cb297-97"><a href="#cb297-97" aria-hidden="true"></a></span>
<span id="cb297-98"><a href="#cb297-98" aria-hidden="true"></a>&lt;hr&gt;</span>
<span id="cb297-99"><a href="#cb297-99" aria-hidden="true"></a></span>
<span id="cb297-100"><a href="#cb297-100" aria-hidden="true"></a>Note that C-style casts purposely allows casting a derived <span class="kw">class</span> to a <span class="kw">protected</span> <span class="kw">or</span> <span class="kw">private</span> base <span class="kw">class</span> in a defined <span class="kw">and</span> safe manner <span class="kw">and</span> to cast into the other direction too. This should be avoided at all costs, because it can make code dependent on implementation details - but <span class="cf">if</span> necessary, you can make use of <span class="kw">this</span> technique.   </span>
<span id="cb297-101"><a href="#cb297-101" aria-hidden="true"></a></span>
<span id="cb297-102"><a href="#cb297-102" aria-hidden="true"></a>&lt;/b&gt; &lt;/em&gt; &lt;/i&gt; &lt;/small&gt; &lt;/strong&gt; &lt;/sub&gt; &lt;/sup&gt;</span>
<span id="cb297-103"><a href="#cb297-103" aria-hidden="true"></a></span>
<span id="cb297-104"><a href="#cb297-104" aria-hidden="true"></a></span>
<span id="cb297-105"><a href="#cb297-105" aria-hidden="true"></a><span class="pp">#</span><span class="er">## 45: What&#39;s the best way to trim std::string? (score [637282](https://stackoverflow.com/q/216823.html) in 2016)</span></span>
<span id="cb297-106"><a href="#cb297-106" aria-hidden="true"></a></span>
<span id="cb297-107"><a href="#cb297-107" aria-hidden="true"></a></span>
<span id="cb297-108"><a href="#cb297-108" aria-hidden="true"></a><span class="pp">#</span><span class="er">### Question</span></span>
<span id="cb297-109"><a href="#cb297-109" aria-hidden="true"></a>I<span class="ch">&#39;m</span><span class="er"> currently using the following code to right-trim all the `std::strings` in my programs:  </span></span>
<span id="cb297-110"><a href="#cb297-110" aria-hidden="true"></a></span>
<span id="cb297-111"><a href="#cb297-111" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb297-112"><a href="#cb297-112" aria-hidden="true"></a><span class="bu">std::</span>string s;</span>
<span id="cb297-113"><a href="#cb297-113" aria-hidden="true"></a>s.erase(s.find_last_not_of(<span class="st">&quot; </span><span class="sc">\n\r\t</span><span class="st">&quot;</span>)+<span class="dv">1</span>);</span></code></pre></div>
<p>It works fine, but I wonder if there are some end-cases where it might fail?</p>
<p>Of course, answers with elegant alternatives and also left-trim solution are welcome.</p>
</section>
<section id="answer-2-score-608" class="level4">
<h4>Answer 2 (score 608)</h4>
<p><strong>EDIT</strong> Since c++17, some parts of the standard library were removed. Fortunately, starting with c++11, we have lambdas which are a superior solution.</p>
<div class="sourceCode" id="cb298"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb298-1"><a href="#cb298-1" aria-hidden="true"></a></span>
<span id="cb298-2"><a href="#cb298-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span><span class="pp"> </span></span>
<span id="cb298-3"><a href="#cb298-3" aria-hidden="true"></a></span>
<span id="cb298-4"><a href="#cb298-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb298-5"><a href="#cb298-5" aria-hidden="true"></a></span>
<span id="cb298-6"><a href="#cb298-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;locale&gt;</span></span>
<span id="cb298-7"><a href="#cb298-7" aria-hidden="true"></a></span>
<span id="cb298-8"><a href="#cb298-8" aria-hidden="true"></a><span class="co">// trim from start (in place)</span></span>
<span id="cb298-9"><a href="#cb298-9" aria-hidden="true"></a><span class="at">static</span> <span class="kw">inline</span> <span class="dt">void</span> ltrim(<span class="bu">std::</span>string &amp;s) {</span>
<span id="cb298-10"><a href="#cb298-10" aria-hidden="true"></a>    s.erase(s.begin(), <span class="bu">std::</span>find_if(s.begin(), s.end(), [](<span class="dt">int</span> ch) {</span>
<span id="cb298-11"><a href="#cb298-11" aria-hidden="true"></a>        <span class="cf">return</span> !<span class="bu">std::</span>isspace(ch);</span>
<span id="cb298-12"><a href="#cb298-12" aria-hidden="true"></a>    }));</span>
<span id="cb298-13"><a href="#cb298-13" aria-hidden="true"></a>}</span>
<span id="cb298-14"><a href="#cb298-14" aria-hidden="true"></a></span>
<span id="cb298-15"><a href="#cb298-15" aria-hidden="true"></a><span class="co">// trim from end (in place)</span></span>
<span id="cb298-16"><a href="#cb298-16" aria-hidden="true"></a><span class="at">static</span> <span class="kw">inline</span> <span class="dt">void</span> rtrim(<span class="bu">std::</span>string &amp;s) {</span>
<span id="cb298-17"><a href="#cb298-17" aria-hidden="true"></a>    s.erase(<span class="bu">std::</span>find_if(s.rbegin(), s.rend(), [](<span class="dt">int</span> ch) {</span>
<span id="cb298-18"><a href="#cb298-18" aria-hidden="true"></a>        <span class="cf">return</span> !<span class="bu">std::</span>isspace(ch);</span>
<span id="cb298-19"><a href="#cb298-19" aria-hidden="true"></a>    }).base(), s.end());</span>
<span id="cb298-20"><a href="#cb298-20" aria-hidden="true"></a>}</span>
<span id="cb298-21"><a href="#cb298-21" aria-hidden="true"></a></span>
<span id="cb298-22"><a href="#cb298-22" aria-hidden="true"></a><span class="co">// trim from both ends (in place)</span></span>
<span id="cb298-23"><a href="#cb298-23" aria-hidden="true"></a><span class="at">static</span> <span class="kw">inline</span> <span class="dt">void</span> trim(<span class="bu">std::</span>string &amp;s) {</span>
<span id="cb298-24"><a href="#cb298-24" aria-hidden="true"></a>    ltrim(s);</span>
<span id="cb298-25"><a href="#cb298-25" aria-hidden="true"></a>    rtrim(s);</span>
<span id="cb298-26"><a href="#cb298-26" aria-hidden="true"></a>}</span>
<span id="cb298-27"><a href="#cb298-27" aria-hidden="true"></a></span>
<span id="cb298-28"><a href="#cb298-28" aria-hidden="true"></a><span class="co">// trim from start (copying)</span></span>
<span id="cb298-29"><a href="#cb298-29" aria-hidden="true"></a><span class="at">static</span> <span class="kw">inline</span> <span class="bu">std::</span>string ltrim_copy(<span class="bu">std::</span>string s) {</span>
<span id="cb298-30"><a href="#cb298-30" aria-hidden="true"></a>    ltrim(s);</span>
<span id="cb298-31"><a href="#cb298-31" aria-hidden="true"></a>    <span class="cf">return</span> s;</span>
<span id="cb298-32"><a href="#cb298-32" aria-hidden="true"></a>}</span>
<span id="cb298-33"><a href="#cb298-33" aria-hidden="true"></a></span>
<span id="cb298-34"><a href="#cb298-34" aria-hidden="true"></a><span class="co">// trim from end (copying)</span></span>
<span id="cb298-35"><a href="#cb298-35" aria-hidden="true"></a><span class="at">static</span> <span class="kw">inline</span> <span class="bu">std::</span>string rtrim_copy(<span class="bu">std::</span>string s) {</span>
<span id="cb298-36"><a href="#cb298-36" aria-hidden="true"></a>    rtrim(s);</span>
<span id="cb298-37"><a href="#cb298-37" aria-hidden="true"></a>    <span class="cf">return</span> s;</span>
<span id="cb298-38"><a href="#cb298-38" aria-hidden="true"></a>}</span>
<span id="cb298-39"><a href="#cb298-39" aria-hidden="true"></a></span>
<span id="cb298-40"><a href="#cb298-40" aria-hidden="true"></a><span class="co">// trim from both ends (copying)</span></span>
<span id="cb298-41"><a href="#cb298-41" aria-hidden="true"></a><span class="at">static</span> <span class="kw">inline</span> <span class="bu">std::</span>string trim_copy(<span class="bu">std::</span>string s) {</span>
<span id="cb298-42"><a href="#cb298-42" aria-hidden="true"></a>    trim(s);</span>
<span id="cb298-43"><a href="#cb298-43" aria-hidden="true"></a>    <span class="cf">return</span> s;</span>
<span id="cb298-44"><a href="#cb298-44" aria-hidden="true"></a>}</span></code></pre></div>
<p>Thanks to <a href="https://stackoverflow.com/a/44973498/524503">https://stackoverflow.com/a/44973498/524503</a> for bringing up the modern solution.</p>
<h5>
Original answer:
</h2>
<p>I tend to use one of these 3 for my trimming needs:</p>
<div class="sourceCode" id="cb299"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb299-1"><a href="#cb299-1" aria-hidden="true"></a></span>
<span id="cb299-2"><a href="#cb299-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span><span class="pp"> </span></span>
<span id="cb299-3"><a href="#cb299-3" aria-hidden="true"></a></span>
<span id="cb299-4"><a href="#cb299-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;functional&gt;</span><span class="pp"> </span></span>
<span id="cb299-5"><a href="#cb299-5" aria-hidden="true"></a></span>
<span id="cb299-6"><a href="#cb299-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb299-7"><a href="#cb299-7" aria-hidden="true"></a></span>
<span id="cb299-8"><a href="#cb299-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;locale&gt;</span></span>
<span id="cb299-9"><a href="#cb299-9" aria-hidden="true"></a></span>
<span id="cb299-10"><a href="#cb299-10" aria-hidden="true"></a><span class="co">// trim from start</span></span>
<span id="cb299-11"><a href="#cb299-11" aria-hidden="true"></a><span class="at">static</span> <span class="kw">inline</span> <span class="bu">std::</span>string &amp;ltrim(<span class="bu">std::</span>string &amp;s) {</span>
<span id="cb299-12"><a href="#cb299-12" aria-hidden="true"></a>    s.erase(s.begin(), <span class="bu">std::</span>find_if(s.begin(), s.end(),</span>
<span id="cb299-13"><a href="#cb299-13" aria-hidden="true"></a>            <span class="bu">std::</span>not1(<span class="bu">std::</span>ptr_fun&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt;(<span class="bu">std::</span>isspace))));</span>
<span id="cb299-14"><a href="#cb299-14" aria-hidden="true"></a>    <span class="cf">return</span> s;</span>
<span id="cb299-15"><a href="#cb299-15" aria-hidden="true"></a>}</span>
<span id="cb299-16"><a href="#cb299-16" aria-hidden="true"></a></span>
<span id="cb299-17"><a href="#cb299-17" aria-hidden="true"></a><span class="co">// trim from end</span></span>
<span id="cb299-18"><a href="#cb299-18" aria-hidden="true"></a><span class="at">static</span> <span class="kw">inline</span> <span class="bu">std::</span>string &amp;rtrim(<span class="bu">std::</span>string &amp;s) {</span>
<span id="cb299-19"><a href="#cb299-19" aria-hidden="true"></a>    s.erase(<span class="bu">std::</span>find_if(s.rbegin(), s.rend(),</span>
<span id="cb299-20"><a href="#cb299-20" aria-hidden="true"></a>            <span class="bu">std::</span>not1(<span class="bu">std::</span>ptr_fun&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt;(<span class="bu">std::</span>isspace))).base(), s.end());</span>
<span id="cb299-21"><a href="#cb299-21" aria-hidden="true"></a>    <span class="cf">return</span> s;</span>
<span id="cb299-22"><a href="#cb299-22" aria-hidden="true"></a>}</span>
<span id="cb299-23"><a href="#cb299-23" aria-hidden="true"></a></span>
<span id="cb299-24"><a href="#cb299-24" aria-hidden="true"></a><span class="co">// trim from both ends</span></span>
<span id="cb299-25"><a href="#cb299-25" aria-hidden="true"></a><span class="at">static</span> <span class="kw">inline</span> <span class="bu">std::</span>string &amp;trim(<span class="bu">std::</span>string &amp;s) {</span>
<span id="cb299-26"><a href="#cb299-26" aria-hidden="true"></a>    <span class="cf">return</span> ltrim(rtrim(s));</span>
<span id="cb299-27"><a href="#cb299-27" aria-hidden="true"></a>}</span></code></pre></div>
<p>They are fairly self explanatory and work very well.</p>
<p><strong>EDIT</strong>: BTW, I have <code>std::ptr_fun</code> in there to help disambiguate <code>std::isspace</code> because there is actually a second definition which supports locales. This could have been a cast just the same, but I tend to like this better.</p>
<p><strong>EDIT</strong>: To address some comments about accepting a parameter by reference, modifying and returning it. I Agree. An implementation that I would likely prefer would be two sets of functions, one for in place and one which makes a copy. A better set of examples would be:</p>
<div class="sourceCode" id="cb300"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb300-1"><a href="#cb300-1" aria-hidden="true"></a></span>
<span id="cb300-2"><a href="#cb300-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span><span class="pp"> </span></span>
<span id="cb300-3"><a href="#cb300-3" aria-hidden="true"></a></span>
<span id="cb300-4"><a href="#cb300-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;functional&gt;</span><span class="pp"> </span></span>
<span id="cb300-5"><a href="#cb300-5" aria-hidden="true"></a></span>
<span id="cb300-6"><a href="#cb300-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb300-7"><a href="#cb300-7" aria-hidden="true"></a></span>
<span id="cb300-8"><a href="#cb300-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;locale&gt;</span></span>
<span id="cb300-9"><a href="#cb300-9" aria-hidden="true"></a></span>
<span id="cb300-10"><a href="#cb300-10" aria-hidden="true"></a><span class="co">// trim from start (in place)</span></span>
<span id="cb300-11"><a href="#cb300-11" aria-hidden="true"></a><span class="at">static</span> <span class="kw">inline</span> <span class="dt">void</span> ltrim(<span class="bu">std::</span>string &amp;s) {</span>
<span id="cb300-12"><a href="#cb300-12" aria-hidden="true"></a>    s.erase(s.begin(), <span class="bu">std::</span>find_if(s.begin(), s.end(),</span>
<span id="cb300-13"><a href="#cb300-13" aria-hidden="true"></a>            <span class="bu">std::</span>not1(<span class="bu">std::</span>ptr_fun&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt;(<span class="bu">std::</span>isspace))));</span>
<span id="cb300-14"><a href="#cb300-14" aria-hidden="true"></a>}</span>
<span id="cb300-15"><a href="#cb300-15" aria-hidden="true"></a></span>
<span id="cb300-16"><a href="#cb300-16" aria-hidden="true"></a><span class="co">// trim from end (in place)</span></span>
<span id="cb300-17"><a href="#cb300-17" aria-hidden="true"></a><span class="at">static</span> <span class="kw">inline</span> <span class="dt">void</span> rtrim(<span class="bu">std::</span>string &amp;s) {</span>
<span id="cb300-18"><a href="#cb300-18" aria-hidden="true"></a>    s.erase(<span class="bu">std::</span>find_if(s.rbegin(), s.rend(),</span>
<span id="cb300-19"><a href="#cb300-19" aria-hidden="true"></a>            <span class="bu">std::</span>not1(<span class="bu">std::</span>ptr_fun&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt;(<span class="bu">std::</span>isspace))).base(), s.end());</span>
<span id="cb300-20"><a href="#cb300-20" aria-hidden="true"></a>}</span>
<span id="cb300-21"><a href="#cb300-21" aria-hidden="true"></a></span>
<span id="cb300-22"><a href="#cb300-22" aria-hidden="true"></a><span class="co">// trim from both ends (in place)</span></span>
<span id="cb300-23"><a href="#cb300-23" aria-hidden="true"></a><span class="at">static</span> <span class="kw">inline</span> <span class="dt">void</span> trim(<span class="bu">std::</span>string &amp;s) {</span>
<span id="cb300-24"><a href="#cb300-24" aria-hidden="true"></a>    ltrim(s);</span>
<span id="cb300-25"><a href="#cb300-25" aria-hidden="true"></a>    rtrim(s);</span>
<span id="cb300-26"><a href="#cb300-26" aria-hidden="true"></a>}</span>
<span id="cb300-27"><a href="#cb300-27" aria-hidden="true"></a></span>
<span id="cb300-28"><a href="#cb300-28" aria-hidden="true"></a><span class="co">// trim from start (copying)</span></span>
<span id="cb300-29"><a href="#cb300-29" aria-hidden="true"></a><span class="at">static</span> <span class="kw">inline</span> <span class="bu">std::</span>string ltrim_copy(<span class="bu">std::</span>string s) {</span>
<span id="cb300-30"><a href="#cb300-30" aria-hidden="true"></a>    ltrim(s);</span>
<span id="cb300-31"><a href="#cb300-31" aria-hidden="true"></a>    <span class="cf">return</span> s;</span>
<span id="cb300-32"><a href="#cb300-32" aria-hidden="true"></a>}</span>
<span id="cb300-33"><a href="#cb300-33" aria-hidden="true"></a></span>
<span id="cb300-34"><a href="#cb300-34" aria-hidden="true"></a><span class="co">// trim from end (copying)</span></span>
<span id="cb300-35"><a href="#cb300-35" aria-hidden="true"></a><span class="at">static</span> <span class="kw">inline</span> <span class="bu">std::</span>string rtrim_copy(<span class="bu">std::</span>string s) {</span>
<span id="cb300-36"><a href="#cb300-36" aria-hidden="true"></a>    rtrim(s);</span>
<span id="cb300-37"><a href="#cb300-37" aria-hidden="true"></a>    <span class="cf">return</span> s;</span>
<span id="cb300-38"><a href="#cb300-38" aria-hidden="true"></a>}</span>
<span id="cb300-39"><a href="#cb300-39" aria-hidden="true"></a></span>
<span id="cb300-40"><a href="#cb300-40" aria-hidden="true"></a><span class="co">// trim from both ends (copying)</span></span>
<span id="cb300-41"><a href="#cb300-41" aria-hidden="true"></a><span class="at">static</span> <span class="kw">inline</span> <span class="bu">std::</span>string trim_copy(<span class="bu">std::</span>string s) {</span>
<span id="cb300-42"><a href="#cb300-42" aria-hidden="true"></a>    trim(s);</span>
<span id="cb300-43"><a href="#cb300-43" aria-hidden="true"></a>    <span class="cf">return</span> s;</span>
<span id="cb300-44"><a href="#cb300-44" aria-hidden="true"></a>}</span></code></pre></div>
<p>I am keeping the original answer above though for context and in the interest of keeping the high voted answer still available.</p>
</section>
<section id="answer-3-score-408" class="level4">
<h4>Answer 3 (score 408)</h4>
<p>Using <a href="http://www.boost.org/doc/libs/1_58_0/doc/html/string_algo/usage.html
#idp424359600" rel="noreferrer">Boost’s string algorithms</a> would be easiest:</p>
<div class="sourceCode" id="cb301"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb301-1"><a href="#cb301-1" aria-hidden="true"></a></span>
<span id="cb301-2"><a href="#cb301-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;boost/algorithm/string.hpp&gt;</span></span>
<span id="cb301-3"><a href="#cb301-3" aria-hidden="true"></a></span>
<span id="cb301-4"><a href="#cb301-4" aria-hidden="true"></a><span class="bu">std::</span>string str(<span class="st">&quot;hello world! &quot;</span>);</span>
<span id="cb301-5"><a href="#cb301-5" aria-hidden="true"></a><span class="ex">boost::</span>trim_right(str);</span></code></pre></div>
<p><code>str</code> is now <code>"hello world!"</code>. There’s also <code>trim_left</code> and <code>trim</code>, which trims both sides.</p>
<hr>
<p>If you add <code>_copy</code> suffix to any of above function names e.g. <code>trim_copy</code>, the function will return a trimmed copy of the string instead of modifying it through a reference.</p>
<p>If you add <code>_if</code> suffix to any of above function names e.g. <code>trim_copy_if</code>, you can trim all characters satisfying your custom predicate, as opposed to just whitespaces.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="c-singleton-design-pattern-score-634664-in-2012" class="level3">
<h3>46: C++ Singleton design pattern (score <a href="https://stackoverflow.com/q/1008019.html">634664</a> in 2012)</h3>
<section id="question-43" class="level4">
<h4>Question</h4>
<p>Recently I’ve bumped into a realization/implementation of the Singleton design pattern for C++. It has looked like this (I have adopted it from the real life example):</p>
<div class="sourceCode" id="cb302"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb302-1"><a href="#cb302-1" aria-hidden="true"></a><span class="co">// a lot of methods are omitted here</span></span>
<span id="cb302-2"><a href="#cb302-2" aria-hidden="true"></a><span class="kw">class</span> Singleton</span>
<span id="cb302-3"><a href="#cb302-3" aria-hidden="true"></a>{</span>
<span id="cb302-4"><a href="#cb302-4" aria-hidden="true"></a>   <span class="kw">public</span>:</span>
<span id="cb302-5"><a href="#cb302-5" aria-hidden="true"></a>       <span class="at">static</span> Singleton* getInstance( );</span>
<span id="cb302-6"><a href="#cb302-6" aria-hidden="true"></a>       ~Singleton( );</span>
<span id="cb302-7"><a href="#cb302-7" aria-hidden="true"></a>   <span class="kw">private</span>:</span>
<span id="cb302-8"><a href="#cb302-8" aria-hidden="true"></a>       Singleton( );</span>
<span id="cb302-9"><a href="#cb302-9" aria-hidden="true"></a>       <span class="at">static</span> Singleton* instance;</span>
<span id="cb302-10"><a href="#cb302-10" aria-hidden="true"></a>};</span></code></pre></div>
<p>From this declaration I can deduce that the instance field is initiated on the heap. That means there is a memory allocation. What is completely unclear for me is when exactly the memory is going to be deallocated? Or is there a bug and memory leak? It seems like there is a problem in the implementation.</p>
<p>My main question is, how do I implement it in the right way?</p>
</section>
<section id="answer-accepted-score-1017" class="level4">
<h4>Answer accepted (score 1017)</h4>
<p>
In 2008 I provided a C++98 implementation of the Singleton design pattern that is lazy-evaluated, guaranteed-destruction, not-technically-thread-safe:<br> <a href="https://stackoverflow.com/questions/270947/can-any-one-provide-me-a-sample-of-singleton-in-c/271104
#271104">Can any one provide me a sample of Singleton in c++?</a>
</p>
<p>Here is an updated C++11 implementation of the Singleton design pattern that is lazy-evaluated, correctly-destroyed, and <a href="https://stackoverflow.com/a/449823/52074">thread-safe</a>.</p>
<div class="sourceCode" id="cb303"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb303-1"><a href="#cb303-1" aria-hidden="true"></a><span class="kw">class</span> S</span>
<span id="cb303-2"><a href="#cb303-2" aria-hidden="true"></a>{</span>
<span id="cb303-3"><a href="#cb303-3" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb303-4"><a href="#cb303-4" aria-hidden="true"></a>        <span class="at">static</span> S&amp; getInstance()</span>
<span id="cb303-5"><a href="#cb303-5" aria-hidden="true"></a>        {</span>
<span id="cb303-6"><a href="#cb303-6" aria-hidden="true"></a>            <span class="at">static</span> S    instance; <span class="co">// Guaranteed to be destroyed.</span></span>
<span id="cb303-7"><a href="#cb303-7" aria-hidden="true"></a>                                  <span class="co">// Instantiated on first use.</span></span>
<span id="cb303-8"><a href="#cb303-8" aria-hidden="true"></a>            <span class="cf">return</span> instance;</span>
<span id="cb303-9"><a href="#cb303-9" aria-hidden="true"></a>        }</span>
<span id="cb303-10"><a href="#cb303-10" aria-hidden="true"></a>    <span class="kw">private</span>:</span>
<span id="cb303-11"><a href="#cb303-11" aria-hidden="true"></a>        S() {}                    <span class="co">// Constructor? (the {} brackets) are needed here.</span></span>
<span id="cb303-12"><a href="#cb303-12" aria-hidden="true"></a></span>
<span id="cb303-13"><a href="#cb303-13" aria-hidden="true"></a>        <span class="co">// C++ 03</span></span>
<span id="cb303-14"><a href="#cb303-14" aria-hidden="true"></a>        <span class="co">// ========</span></span>
<span id="cb303-15"><a href="#cb303-15" aria-hidden="true"></a>        <span class="co">// Don&#39;t forget to declare these two. You want to make sure they</span></span>
<span id="cb303-16"><a href="#cb303-16" aria-hidden="true"></a>        <span class="co">// are unacceptable otherwise you may accidentally get copies of</span></span>
<span id="cb303-17"><a href="#cb303-17" aria-hidden="true"></a>        <span class="co">// your singleton appearing.</span></span>
<span id="cb303-18"><a href="#cb303-18" aria-hidden="true"></a>        S(S <span class="at">const</span>&amp;);              <span class="co">// Don&#39;t Implement</span></span>
<span id="cb303-19"><a href="#cb303-19" aria-hidden="true"></a>        <span class="dt">void</span> <span class="kw">operator</span>=(S <span class="at">const</span>&amp;); <span class="co">// Don&#39;t implement</span></span>
<span id="cb303-20"><a href="#cb303-20" aria-hidden="true"></a></span>
<span id="cb303-21"><a href="#cb303-21" aria-hidden="true"></a>        <span class="co">// C++ 11</span></span>
<span id="cb303-22"><a href="#cb303-22" aria-hidden="true"></a>        <span class="co">// =======</span></span>
<span id="cb303-23"><a href="#cb303-23" aria-hidden="true"></a>        <span class="co">// We can use the better technique of deleting the methods</span></span>
<span id="cb303-24"><a href="#cb303-24" aria-hidden="true"></a>        <span class="co">// we don&#39;t want.</span></span>
<span id="cb303-25"><a href="#cb303-25" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb303-26"><a href="#cb303-26" aria-hidden="true"></a>        S(S <span class="at">const</span>&amp;)               = <span class="kw">delete</span>;</span>
<span id="cb303-27"><a href="#cb303-27" aria-hidden="true"></a>        <span class="dt">void</span> <span class="kw">operator</span>=(S <span class="at">const</span>&amp;)  = <span class="kw">delete</span>;</span>
<span id="cb303-28"><a href="#cb303-28" aria-hidden="true"></a></span>
<span id="cb303-29"><a href="#cb303-29" aria-hidden="true"></a>        <span class="co">// Note: Scott Meyers mentions in his Effective Modern</span></span>
<span id="cb303-30"><a href="#cb303-30" aria-hidden="true"></a>        <span class="co">//       C++ book, that deleted functions should generally</span></span>
<span id="cb303-31"><a href="#cb303-31" aria-hidden="true"></a>        <span class="co">//       be public as it results in better error messages</span></span>
<span id="cb303-32"><a href="#cb303-32" aria-hidden="true"></a>        <span class="co">//       due to the compilers behavior to check accessibility</span></span>
<span id="cb303-33"><a href="#cb303-33" aria-hidden="true"></a>        <span class="co">//       before deleted status</span></span>
<span id="cb303-34"><a href="#cb303-34" aria-hidden="true"></a>};</span></code></pre></div>
<p>
See this article about when to use a singleton: (not often)<br> <a href="https://stackoverflow.com/questions/86582/singleton-how-should-it-be-used">Singleton: How should it be used</a>
</p>
<p>
See this two article about initialization order and how to cope:<br> <a href="https://stackoverflow.com/questions/211237/c-static-variables-initialisation-order/211307
#211307">Static variables initialisation order</a><br> <a href="https://stackoverflow.com/questions/335369/finding-c-static-initialization-order-problems/335746
#335746">Finding C++ static initialization order problems</a>
</p>
<p>
See this article describing lifetimes:<br> <a href="https://stackoverflow.com/questions/246564/what-is-the-lifetime-of-a-static-variable-in-a-c-function">What is the lifetime of a static variable in a C++ function?</a>
</p>
<p>
See this article that discusses some threading implications to singletons:<br> <a href="https://stackoverflow.com/questions/449436/singleton-instance-declared-as-static-variable-of-getinstance-method/449823
#449823">Singleton instance declared as static variable of GetInstance method, is it thread-safe?</a>
</p>
<p>
See this article that explains why double checked locking will not work on C++:<br> <a href="https://stackoverflow.com/questions/367633/what-are-all-the-common-undefined-behaviour-that-c-programmer-should-know-about/367690
#367690">What are all the common undefined behaviours that a C++ programmer should know about?</a><br> <a href="http://www.drdobbs.com/cpp/c-and-the-perils-of-double-checked-locki/184405726" rel="noreferrer">Dr Dobbs: C++ and The Perils of Double-Checked Locking: Part I</a>
</p>
</section>
<section id="answer-2-score-46" class="level4">
<h4>Answer 2 (score 46)</h4>
<p>Being a Singleton, you usually do not want it to be destructed.</p>
<p>It will get torn down and deallocated when the program terminates, which is the normal, desired behavior for a singleton. If you want to be able to explicitly clean it, it’s fairly easy to add a static method to the class that allows you to restore it to a clean state, and have it reallocate next time it’s used, but that’s outside of the scope of a “classic” singleton.</p>
</section>
<section id="answer-3-score-35" class="level4">
<h4>Answer 3 (score 35)</h4>
<p>You could avoid memory allocation. There are many variants, all having problems in case of multithreading environment.</p>
<p>I prefer this kind of implementation (actually, it is not correctly said I prefer, because I avoid singletons as much as possible):</p>
<div class="sourceCode" id="cb304"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb304-1"><a href="#cb304-1" aria-hidden="true"></a><span class="kw">class</span> Singleton</span>
<span id="cb304-2"><a href="#cb304-2" aria-hidden="true"></a>{</span>
<span id="cb304-3"><a href="#cb304-3" aria-hidden="true"></a><span class="kw">private</span>:</span>
<span id="cb304-4"><a href="#cb304-4" aria-hidden="true"></a>   Singleton();</span>
<span id="cb304-5"><a href="#cb304-5" aria-hidden="true"></a></span>
<span id="cb304-6"><a href="#cb304-6" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb304-7"><a href="#cb304-7" aria-hidden="true"></a>   <span class="at">static</span> Singleton&amp; instance()</span>
<span id="cb304-8"><a href="#cb304-8" aria-hidden="true"></a>   {</span>
<span id="cb304-9"><a href="#cb304-9" aria-hidden="true"></a>      <span class="at">static</span> Singleton INSTANCE;</span>
<span id="cb304-10"><a href="#cb304-10" aria-hidden="true"></a>      <span class="cf">return</span> INSTANCE;</span>
<span id="cb304-11"><a href="#cb304-11" aria-hidden="true"></a>   }</span>
<span id="cb304-12"><a href="#cb304-12" aria-hidden="true"></a>};</span></code></pre></div>
<p>It has no dynamic memory allocation.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="check-if-a-string-contains-a-string-in-c-score-622627-in-2019" class="level3">
<h3>47: Check if a string contains a string in C++ (score <a href="https://stackoverflow.com/q/2340281.html">622627</a> in 2019)</h3>
<section id="question-44" class="level4">
<h4>Question</h4>
<p>I have a variable of type <code>std::string</code>. I want to check if it contains a certain <code>std::string</code>. How would I do that?</p>
<p>Is there a function that returns true if the string is found, and false if it isn’t?</p>
</section>
<section id="answer-accepted-score-632" class="level4">
<h4>Answer accepted (score 632)</h4>
<p>Use <a href="http://en.cppreference.com/w/cpp/string/basic_string/find" rel="noreferrer"><code>std::string::find</code></a> as follows:</p>
<div class="sourceCode" id="cb305"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb305-1"><a href="#cb305-1" aria-hidden="true"></a><span class="cf">if</span> (s1.find(s2) != <span class="bu">std::</span>string<span class="bu">::</span>npos) {</span>
<span id="cb305-2"><a href="#cb305-2" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;found!&quot;</span> &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span>
<span id="cb305-3"><a href="#cb305-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>Note: “found!” will be printed if <code>s2</code> is a substring of <code>s1</code>, both <code>s1</code> and <code>s2</code> are of type <code>std::string</code>.</p>
</section>
<section id="answer-2-score-102" class="level4">
<h4>Answer 2 (score 102)</h4>
<p>You can try using the <a href="http://en.cppreference.com/w/cpp/string/basic_string/find" rel="noreferrer"><code>find</code></a> function:</p>
<div class="sourceCode" id="cb306"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb306-1"><a href="#cb306-1" aria-hidden="true"></a>string str (<span class="st">&quot;There are two needles in this haystack.&quot;</span>);</span>
<span id="cb306-2"><a href="#cb306-2" aria-hidden="true"></a>string str2 (<span class="st">&quot;needle&quot;</span>);</span>
<span id="cb306-3"><a href="#cb306-3" aria-hidden="true"></a></span>
<span id="cb306-4"><a href="#cb306-4" aria-hidden="true"></a><span class="cf">if</span> (str.find(str2) != string::npos) {</span>
<span id="cb306-5"><a href="#cb306-5" aria-hidden="true"></a><span class="co">//.. found.</span></span>
<span id="cb306-6"><a href="#cb306-6" aria-hidden="true"></a>} </span></code></pre></div>
</section>
<section id="answer-3-score-21" class="level4">
<h4>Answer 3 (score 21)</h4>
<p>Actually, you can try to use boost library,I think std::string doesn’t supply enough method to do all the common string operation.In boost,you can just use the <a href="http://www.boost.org/doc/libs/1_55_0/doc/html/string_algo/reference.html
#header.boost.algorithm.string.predicate_hpp" rel="noreferrer"><code>boost::algorithm::contains</code></a>:</p>
<div class="sourceCode" id="cb307"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb307-1"><a href="#cb307-1" aria-hidden="true"></a></span>
<span id="cb307-2"><a href="#cb307-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;string&quot;</span></span>
<span id="cb307-3"><a href="#cb307-3" aria-hidden="true"></a></span>
<span id="cb307-4"><a href="#cb307-4" aria-hidden="true"></a></span>
<span id="cb307-5"><a href="#cb307-5" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;boost/algorithm/string.hpp&quot;</span></span>
<span id="cb307-6"><a href="#cb307-6" aria-hidden="true"></a></span>
<span id="cb307-7"><a href="#cb307-7" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb307-8"><a href="#cb307-8" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> boost;</span>
<span id="cb307-9"><a href="#cb307-9" aria-hidden="true"></a><span class="dt">int</span> main(){</span>
<span id="cb307-10"><a href="#cb307-10" aria-hidden="true"></a>    string s(<span class="st">&quot;gengjiawen&quot;</span>);</span>
<span id="cb307-11"><a href="#cb307-11" aria-hidden="true"></a>    string t(<span class="st">&quot;geng&quot;</span>);</span>
<span id="cb307-12"><a href="#cb307-12" aria-hidden="true"></a>    <span class="dt">bool</span> b = contains(s, t);</span>
<span id="cb307-13"><a href="#cb307-13" aria-hidden="true"></a>    cout &lt;&lt; b &lt;&lt; endl;</span>
<span id="cb307-14"><a href="#cb307-14" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb307-15"><a href="#cb307-15" aria-hidden="true"></a>}</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-to-initialize-a-vector-in-c-score-621092-in-2017" class="level3">
<h3>48: How to initialize a vector in C++ (score <a href="https://stackoverflow.com/q/8906545.html">621092</a> in 2017)</h3>
<section id="question-45" class="level4">
<h4>Question</h4>
<blockquote>
<p>
<strong>Possible Duplicate:</strong> <br/> <a href="https://stackoverflow.com/questions/2236197/c-easiest-way-to-initialize-an-stl-vector-with-hardcoded-elements">C++: Easiest way to initialize an STL vector with hardcoded elements</a>
</p>
</blockquote>
<p>I want to initialize a vector like we do in case of an array.</p>
<p>Example</p>
<div class="sourceCode" id="cb308"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb308-1"><a href="#cb308-1" aria-hidden="true"></a><span class="dt">int</span> vv[<span class="dv">2</span>] = {<span class="dv">12</span>, <span class="dv">43</span>};</span></code></pre></div>
<p>But when I do it like this,</p>
<div class="sourceCode" id="cb309"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb309-1"><a href="#cb309-1" aria-hidden="true"></a>vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">2</span>) = {<span class="dv">34</span>, <span class="dv">23</span>};</span></code></pre></div>
<p>OR</p>
<div class="sourceCode" id="cb310"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb310-1"><a href="#cb310-1" aria-hidden="true"></a>vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">2</span>);</span>
<span id="cb310-2"><a href="#cb310-2" aria-hidden="true"></a>v = {<span class="dv">0</span>, <span class="dv">9</span>};</span></code></pre></div>
<p>it gives an error:</p>
<blockquote>
expected primary-expression before ‘{’ token
</blockquote>
<p>AND</p>
<blockquote>
error: expected ‘,’ or ‘;’ before ‘=’ token
</blockquote>
<p>respectively.</p>
</section>
<section id="answer-accepted-score-259" class="level4">
<h4>Answer accepted (score 259)</h4>
<p>With the new C++ standard (may need special flags to be enabled on your compiler) you can simply do:</p>
<div class="sourceCode" id="cb311"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb311-1"><a href="#cb311-1" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v { <span class="dv">34</span>,<span class="dv">23</span> };</span>
<span id="cb311-2"><a href="#cb311-2" aria-hidden="true"></a><span class="co">// or</span></span>
<span id="cb311-3"><a href="#cb311-3" aria-hidden="true"></a><span class="co">// std::vector&lt;int&gt; v = { 34,23 };</span></span></code></pre></div>
<p>Or even:</p>
<div class="sourceCode" id="cb312"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb312-1"><a href="#cb312-1" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">2</span>);</span>
<span id="cb312-2"><a href="#cb312-2" aria-hidden="true"></a>v = { <span class="dv">34</span>,<span class="dv">23</span> };</span></code></pre></div>
<p>On compilers that don’t support this feature (initializer lists) yet you can emulate this with an array:</p>
<div class="sourceCode" id="cb313"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb313-1"><a href="#cb313-1" aria-hidden="true"></a><span class="dt">int</span> vv[<span class="dv">2</span>] = { <span class="dv">12</span>,<span class="dv">43</span> };</span>
<span id="cb313-2"><a href="#cb313-2" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v(&amp;vv[<span class="dv">0</span>], &amp;vv[<span class="dv">0</span>]+<span class="dv">2</span>);</span></code></pre></div>
<p>Or, for the case of assignment to an existing vector:</p>
<div class="sourceCode" id="cb314"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb314-1"><a href="#cb314-1" aria-hidden="true"></a><span class="dt">int</span> vv[<span class="dv">2</span>] = { <span class="dv">12</span>,<span class="dv">43</span> };</span>
<span id="cb314-2"><a href="#cb314-2" aria-hidden="true"></a>v.assign(&amp;vv[<span class="dv">0</span>], &amp;vv[<span class="dv">0</span>]+<span class="dv">2</span>);</span></code></pre></div>
<p>Like James Kanze suggested, it’s more robust to have functions that give you the beginning and end of an array:</p>
<div class="sourceCode" id="cb315"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb315-1"><a href="#cb315-1" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T, <span class="dt">size_t</span> N&gt;</span>
<span id="cb315-2"><a href="#cb315-2" aria-hidden="true"></a>T* begin(T(&amp;arr)[N]) { <span class="cf">return</span> &amp;arr[<span class="dv">0</span>]; }</span>
<span id="cb315-3"><a href="#cb315-3" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T, <span class="dt">size_t</span> N&gt;</span>
<span id="cb315-4"><a href="#cb315-4" aria-hidden="true"></a>T* end(T(&amp;arr)[N]) { <span class="cf">return</span> &amp;arr[<span class="dv">0</span>]+N; }</span></code></pre></div>
<p>And then you can do this without having to repeat the size all over:</p>
<div class="sourceCode" id="cb316"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb316-1"><a href="#cb316-1" aria-hidden="true"></a><span class="dt">int</span> vv[] = { <span class="dv">12</span>,<span class="dv">43</span> };</span>
<span id="cb316-2"><a href="#cb316-2" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v(begin(vv), end(vv));</span></code></pre></div>
</section>
<section id="answer-2-score-29" class="level4">
<h4>Answer 2 (score 29)</h4>
<p>You can also do like this:</p>
<div class="sourceCode" id="cb317"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb317-1"><a href="#cb317-1" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb317-2"><a href="#cb317-2" aria-hidden="true"></a><span class="kw">class</span> make_vector {</span>
<span id="cb317-3"><a href="#cb317-3" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb317-4"><a href="#cb317-4" aria-hidden="true"></a>  <span class="kw">typedef</span> make_vector&lt;T&gt; <span class="dt">my_type</span>;</span>
<span id="cb317-5"><a href="#cb317-5" aria-hidden="true"></a>  <span class="dt">my_type</span>&amp; <span class="kw">operator</span>&lt;&lt; (<span class="at">const</span> T&amp; val) {</span>
<span id="cb317-6"><a href="#cb317-6" aria-hidden="true"></a>    <span class="va">data_</span>.push_back(val);</span>
<span id="cb317-7"><a href="#cb317-7" aria-hidden="true"></a>    <span class="cf">return</span> *<span class="kw">this</span>;</span>
<span id="cb317-8"><a href="#cb317-8" aria-hidden="true"></a>  }</span>
<span id="cb317-9"><a href="#cb317-9" aria-hidden="true"></a>  <span class="kw">operator</span> <span class="bu">std::</span>vector&lt;T&gt;() <span class="at">const</span> {</span>
<span id="cb317-10"><a href="#cb317-10" aria-hidden="true"></a>    <span class="cf">return</span> <span class="va">data_</span>;</span>
<span id="cb317-11"><a href="#cb317-11" aria-hidden="true"></a>  }</span>
<span id="cb317-12"><a href="#cb317-12" aria-hidden="true"></a><span class="kw">private</span>:</span>
<span id="cb317-13"><a href="#cb317-13" aria-hidden="true"></a>  <span class="bu">std::</span>vector&lt;T&gt; <span class="va">data_</span>;</span>
<span id="cb317-14"><a href="#cb317-14" aria-hidden="true"></a>};</span></code></pre></div>
<p>And use it like this:</p>
<div class="sourceCode" id="cb318"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb318-1"><a href="#cb318-1" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = make_vector&lt;<span class="dt">int</span>&gt;() &lt;&lt; <span class="dv">1</span> &lt;&lt; <span class="dv">2</span> &lt;&lt; <span class="dv">3</span>;</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-to-print-out-the-contents-of-a-vector-score-618189-in-2018" class="level3">
<h3>49: How to print out the contents of a vector? (score <a href="https://stackoverflow.com/q/10750057.html">618189</a> in 2018)</h3>
<section id="question-46" class="level4">
<h4>Question</h4>
<p>I want to print out the contents of a vector in C++, here is what I have:</p>
<div class="sourceCode" id="cb319"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb319-1"><a href="#cb319-1" aria-hidden="true"></a></span>
<span id="cb319-2"><a href="#cb319-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb319-3"><a href="#cb319-3" aria-hidden="true"></a></span>
<span id="cb319-4"><a href="#cb319-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;fstream&gt;</span></span>
<span id="cb319-5"><a href="#cb319-5" aria-hidden="true"></a></span>
<span id="cb319-6"><a href="#cb319-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb319-7"><a href="#cb319-7" aria-hidden="true"></a></span>
<span id="cb319-8"><a href="#cb319-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb319-9"><a href="#cb319-9" aria-hidden="true"></a></span>
<span id="cb319-10"><a href="#cb319-10" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb319-11"><a href="#cb319-11" aria-hidden="true"></a></span>
<span id="cb319-12"><a href="#cb319-12" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sstream&gt;</span></span>
<span id="cb319-13"><a href="#cb319-13" aria-hidden="true"></a></span>
<span id="cb319-14"><a href="#cb319-14" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb319-15"><a href="#cb319-15" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb319-16"><a href="#cb319-16" aria-hidden="true"></a></span>
<span id="cb319-17"><a href="#cb319-17" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb319-18"><a href="#cb319-18" aria-hidden="true"></a>{</span>
<span id="cb319-19"><a href="#cb319-19" aria-hidden="true"></a>    ifstream file(<span class="st">&quot;maze.txt&quot;</span>);</span>
<span id="cb319-20"><a href="#cb319-20" aria-hidden="true"></a>    <span class="cf">if</span> (file) {</span>
<span id="cb319-21"><a href="#cb319-21" aria-hidden="true"></a>        vector&lt;<span class="dt">char</span>&gt; vec(istreambuf_iterator&lt;<span class="dt">char</span>&gt;(file), (istreambuf_iterator&lt;<span class="dt">char</span>&gt;()));</span>
<span id="cb319-22"><a href="#cb319-22" aria-hidden="true"></a>        vector&lt;<span class="dt">char</span>&gt; path;</span>
<span id="cb319-23"><a href="#cb319-23" aria-hidden="true"></a>        <span class="dt">int</span> x = <span class="dv">17</span>;</span>
<span id="cb319-24"><a href="#cb319-24" aria-hidden="true"></a>        <span class="dt">char</span> entrance = vec.at(<span class="dv">16</span>);</span>
<span id="cb319-25"><a href="#cb319-25" aria-hidden="true"></a>        <span class="dt">char</span> firstsquare = vec.at(x);</span>
<span id="cb319-26"><a href="#cb319-26" aria-hidden="true"></a>        <span class="cf">if</span> (entrance == <span class="ch">&#39;S&#39;</span>) { </span>
<span id="cb319-27"><a href="#cb319-27" aria-hidden="true"></a>            path.push_back(entrance); </span>
<span id="cb319-28"><a href="#cb319-28" aria-hidden="true"></a>        }</span>
<span id="cb319-29"><a href="#cb319-29" aria-hidden="true"></a>        <span class="cf">for</span> (x = <span class="dv">17</span>; isalpha(firstsquare); x++) {</span>
<span id="cb319-30"><a href="#cb319-30" aria-hidden="true"></a>            path.push_back(firstsquare);</span>
<span id="cb319-31"><a href="#cb319-31" aria-hidden="true"></a>        }</span>
<span id="cb319-32"><a href="#cb319-32" aria-hidden="true"></a>        <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; path.size(); i++) {</span>
<span id="cb319-33"><a href="#cb319-33" aria-hidden="true"></a>            cout &lt;&lt; path[i] &lt;&lt; <span class="st">&quot; &quot;</span>;</span>
<span id="cb319-34"><a href="#cb319-34" aria-hidden="true"></a>        }</span>
<span id="cb319-35"><a href="#cb319-35" aria-hidden="true"></a>        cout &lt;&lt; endl;</span>
<span id="cb319-36"><a href="#cb319-36" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb319-37"><a href="#cb319-37" aria-hidden="true"></a>    }</span>
<span id="cb319-38"><a href="#cb319-38" aria-hidden="true"></a>}</span></code></pre></div>
<p>How do I print the contents of the vector to the screen?</p>
</section>
<section id="answer-accepted-score-348" class="level4">
<h4>Answer accepted (score 348)</h4>
<p>Purely to answer your question, you can use an iterator:</p>
<div class="sourceCode" id="cb320"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb320-1"><a href="#cb320-1" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="dt">char</span>&gt; path;</span>
<span id="cb320-2"><a href="#cb320-2" aria-hidden="true"></a><span class="co">// ...</span></span>
<span id="cb320-3"><a href="#cb320-3" aria-hidden="true"></a><span class="cf">for</span> (<span class="bu">std::</span>vector&lt;<span class="dt">char</span>&gt;::const_iterator i = path.begin(); i != path.end(); ++i)</span>
<span id="cb320-4"><a href="#cb320-4" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; *i &lt;&lt; <span class="ch">&#39; &#39;</span>;</span></code></pre></div>
<p>If you want to modify the vector’s contents in the for loop, then use <code>iterator</code> rather than <code>const_iterator</code>.</p>
<p>But there’s lots more that can be said about this. If you just want an answer you can use, then you can stop here; otherwise, read on.</p>
<h5>
auto (C++11)/typedef
</h2>
<p>This is not another solution, but a supplement to the above <code>iterator</code> solution. If you are using the C++11 standard (or later), then you can use the <code>auto</code> keyword to help the readability:</p>
<div class="sourceCode" id="cb321"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb321-1"><a href="#cb321-1" aria-hidden="true"></a><span class="cf">for</span> (<span class="kw">auto</span> i = path.begin(); i != path.end(); ++i)</span>
<span id="cb321-2"><a href="#cb321-2" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; *i &lt;&lt; <span class="ch">&#39; &#39;</span>;</span></code></pre></div>
<p>But the type of <code>i</code> will be non-const (i.e., the compiler will use <code>std::vector&amp;lt;char&amp;gt;::iterator</code> as the type of <code>i</code>).</p>
<p>In this case, you might as well just use a <code>typedef</code> (not restricted to C++11, and <strong>very</strong> useful to use anyway):</p>
<div class="sourceCode" id="cb322"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb322-1"><a href="#cb322-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="bu">std::</span>vector&lt;<span class="dt">char</span>&gt; Path;</span>
<span id="cb322-2"><a href="#cb322-2" aria-hidden="true"></a>Path path;</span>
<span id="cb322-3"><a href="#cb322-3" aria-hidden="true"></a><span class="co">// ...</span></span>
<span id="cb322-4"><a href="#cb322-4" aria-hidden="true"></a><span class="cf">for</span> (Path::const_iterator i = path.begin(); i != path.end(); ++i)</span>
<span id="cb322-5"><a href="#cb322-5" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; *i &lt;&lt; <span class="ch">&#39; &#39;</span>;</span></code></pre></div>
<h5>
counter
</h2>
<p>You can, of course, use a integer type to record your position in the <code>for</code> loop:</p>
<div class="sourceCode" id="cb323"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb323-1"><a href="#cb323-1" aria-hidden="true"></a><span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;path.size(); ++i)</span>
<span id="cb323-2"><a href="#cb323-2" aria-hidden="true"></a>  <span class="bu">std::</span>cout &lt;&lt; path[i] &lt;&lt; <span class="ch">&#39; &#39;</span>;</span></code></pre></div>
<p>If you are going to do this, it’s better to use the container’s member types, if they are available and appropriate. <code>std::vector</code> has a member type called <code>size_type</code> for this job: it is the type returned by the <code>size</code> method.</p>
<div class="sourceCode" id="cb324"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb324-1"><a href="#cb324-1" aria-hidden="true"></a><span class="co">// Path typedef&#39;d to std::vector&lt;char&gt;</span></span>
<span id="cb324-2"><a href="#cb324-2" aria-hidden="true"></a><span class="cf">for</span>( Path::<span class="dt">size_type</span> i=<span class="dv">0</span>; i&lt;path.size(); ++i)</span>
<span id="cb324-3"><a href="#cb324-3" aria-hidden="true"></a>  <span class="bu">std::</span>cout &lt;&lt; path[i] &lt;&lt; <span class="ch">&#39; &#39;</span>;</span></code></pre></div>
<p>Why not just use this over the <code>iterator</code> solution? For simple cases you might as well, but the point is that the <code>iterator</code> class is an object designed to do this job for more complicated objects where this solution is not going to be ideal.</p>
<h5>
range-based for loop (C++11)
</h2>
<p>See <a href="https://stackoverflow.com/a/20507503/498730">Jefffrey’s solution</a>. In C++11 (and later) you can use the new range-based <code>for</code> loop, which looks like this:</p>
<div class="sourceCode" id="cb325"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb325-1"><a href="#cb325-1" aria-hidden="true"></a><span class="cf">for</span> (<span class="kw">auto</span> i: path)</span>
<span id="cb325-2"><a href="#cb325-2" aria-hidden="true"></a>  <span class="bu">std::</span>cout &lt;&lt; i &lt;&lt; <span class="ch">&#39; &#39;</span>;</span></code></pre></div>
<p>Since <code>path</code> is a vector of items (explicitly <code>std::vector&amp;lt;char&amp;gt;</code>), the object <code>i</code> is of type of the item of the vector (i.e., explicitly, it is of type <code>char</code>). The object <code>i</code> has a value that is a copy of the actual item in the <code>path</code> object. Thus, all changes to <code>i</code> in the loop are not preserved in <code>path</code> itself. Additionally, if you would like to enforce the fact that you don’t want to be able to change the copied value of <code>i</code> in the loop, you can force the type of <code>i</code> to be <code>const char</code> like this:</p>
<div class="sourceCode" id="cb326"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb326-1"><a href="#cb326-1" aria-hidden="true"></a><span class="cf">for</span> (<span class="at">const</span> <span class="kw">auto</span> i: path)</span>
<span id="cb326-2"><a href="#cb326-2" aria-hidden="true"></a>  <span class="bu">std::</span>cout &lt;&lt; i &lt;&lt; <span class="ch">&#39; &#39;</span>;</span></code></pre></div>
<p>If you would like to modify the items in <code>path</code>, you can use a reference:</p>
<div class="sourceCode" id="cb327"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb327-1"><a href="#cb327-1" aria-hidden="true"></a><span class="cf">for</span> (<span class="kw">auto</span>&amp; i: path)</span>
<span id="cb327-2"><a href="#cb327-2" aria-hidden="true"></a>  <span class="bu">std::</span>cout &lt;&lt; i &lt;&lt; <span class="ch">&#39; &#39;</span>;</span></code></pre></div>
<p>and even if you don’t want to modify <code>path</code>, if the copying of objects is expensive you should use a const reference instead of copying by value:</p>
<div class="sourceCode" id="cb328"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb328-1"><a href="#cb328-1" aria-hidden="true"></a><span class="cf">for</span> (<span class="at">const</span> <span class="kw">auto</span>&amp; i: path)</span>
<span id="cb328-2"><a href="#cb328-2" aria-hidden="true"></a>  <span class="bu">std::</span>cout &lt;&lt; i &lt;&lt; <span class="ch">&#39; &#39;</span>;</span></code></pre></div>
<h5>
std::copy
</h2>
<p>See <a href="https://stackoverflow.com/a/11335634/498730">Joshua’s answer</a>. You can use the STL algorithm <code>std::copy</code> to copy the vector contents onto the output stream. This is an elegant solution if you are comfortable with it (and besides, it is <strong>very</strong> useful, not just in this case of printing the contents of a vector).</p>
<h5>
std::for_each
</h2>
<p>See <a href="https://stackoverflow.com/a/26363773/498730">Max’s solution</a>. Using <code>std::for_each</code> is overkill for this simple scenario, but it is a very useful solution if you wanted to do more than just printing to screen: using <code>std::for_each</code> allows you to do <em>any</em> (sensible) operation on the vector contents.</p>
<h5>
overload ostream::operator&lt;&lt;
</h2>
<p>See <a href="https://stackoverflow.com/a/23397700/498730">Chris’s answer</a>, this is more a complement to the other answers since you will still need to implement one of the solutions above in the overloading. In his example he used a counter in a <code>for</code> loop. For example, this is how you could quickly use <a href="https://stackoverflow.com/a/11335634/498730">Joshua’s solution</a>:</p>
<div class="sourceCode" id="cb329"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb329-1"><a href="#cb329-1" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb329-2"><a href="#cb329-2" aria-hidden="true"></a><span class="bu">std::</span>ostream&amp; <span class="kw">operator</span>&lt;&lt; (<span class="bu">std::</span>ostream&amp; out, <span class="at">const</span> <span class="bu">std::</span>vector&lt;T&gt;&amp; v) {</span>
<span id="cb329-3"><a href="#cb329-3" aria-hidden="true"></a>  <span class="cf">if</span> ( !v.empty() ) {</span>
<span id="cb329-4"><a href="#cb329-4" aria-hidden="true"></a>    out &lt;&lt; <span class="ch">&#39;[&#39;</span>;</span>
<span id="cb329-5"><a href="#cb329-5" aria-hidden="true"></a>    <span class="bu">std::</span>copy (v.begin(), v.end(), <span class="bu">std::</span>ostream_iterator&lt;T&gt;(out, <span class="st">&quot;, &quot;</span>));</span>
<span id="cb329-6"><a href="#cb329-6" aria-hidden="true"></a>    out &lt;&lt; <span class="st">&quot;</span><span class="sc">\b\b</span><span class="st">]&quot;</span>;</span>
<span id="cb329-7"><a href="#cb329-7" aria-hidden="true"></a>  }</span>
<span id="cb329-8"><a href="#cb329-8" aria-hidden="true"></a>  <span class="cf">return</span> out;</span>
<span id="cb329-9"><a href="#cb329-9" aria-hidden="true"></a>}</span></code></pre></div>
<p>Usage of any of the other solutions should be straightforward.</p>
<h5>
conclusion
</h2>
<p>Any of the solutions presented here will work. It’s up to you and the code on which one is the “best”. Anything more detailed than this is probably best left for another question where the pros/cons can be properly evaluated; but as always user preference will always play a part: none of the solutions presented are wrong, but some will look nicer to each individual coder.</p>
<h5>
addendum
</h2>
<p>This is an expanded solution of an earlier one I posted. Since that post kept getting attention, I decided to expand on it and refer to the other excellent solutions that were posted here. My original post had a remark that mentioned that if you <em>were</em> intending on modifying your vector inside a <code>for</code> loop then there are two methods provided by <code>std::vector</code> to access elements: <code>std::vector::operator[]</code> which does not do bounds checking, and <code>std::vector::at</code> which does perform bounds checking. In other words, <code>at</code> will throw if you try to access an element outside the vector and <code>operator[]</code> wouldn’t. I only added this comment, originally, for the sake of mentioning something that it might be useful to know of if anyone already didn’t. And I see no difference now. Hence this addendum.</p>
</section>
<section id="answer-2-score-203" class="level4">
<h4>Answer 2 (score 203)</h4>
<p>A much easier way to do this is with the standard <a href="http://en.cppreference.com/w/cpp/algorithm/copy">copy algorithm</a>:</p>
<div class="sourceCode" id="cb330"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb330-1"><a href="#cb330-1" aria-hidden="true"></a></span>
<span id="cb330-2"><a href="#cb330-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb330-3"><a href="#cb330-3" aria-hidden="true"></a></span>
<span id="cb330-4"><a href="#cb330-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span><span class="pp"> </span><span class="co">// for copy</span></span>
<span id="cb330-5"><a href="#cb330-5" aria-hidden="true"></a></span>
<span id="cb330-6"><a href="#cb330-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iterator&gt;</span><span class="pp"> </span><span class="co">// for ostream_iterator</span></span>
<span id="cb330-7"><a href="#cb330-7" aria-hidden="true"></a></span>
<span id="cb330-8"><a href="#cb330-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb330-9"><a href="#cb330-9" aria-hidden="true"></a></span>
<span id="cb330-10"><a href="#cb330-10" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb330-11"><a href="#cb330-11" aria-hidden="true"></a>    <span class="co">/* Set up vector to hold chars a-z */</span></span>
<span id="cb330-12"><a href="#cb330-12" aria-hidden="true"></a>    <span class="bu">std::</span>vector&lt;<span class="dt">char</span>&gt; path;</span>
<span id="cb330-13"><a href="#cb330-13" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">int</span> ch = <span class="ch">&#39;a&#39;</span>; ch &lt;= <span class="ch">&#39;z&#39;</span>; ++ch)</span>
<span id="cb330-14"><a href="#cb330-14" aria-hidden="true"></a>        path.push_back(ch);</span>
<span id="cb330-15"><a href="#cb330-15" aria-hidden="true"></a></span>
<span id="cb330-16"><a href="#cb330-16" aria-hidden="true"></a>    <span class="co">/* Print path vector to console */</span></span>
<span id="cb330-17"><a href="#cb330-17" aria-hidden="true"></a>    <span class="bu">std::</span>copy(path.begin(), path.end(), <span class="bu">std::</span>ostream_iterator&lt;<span class="dt">char</span>&gt;(<span class="bu">std::</span>cout, <span class="st">&quot; &quot;</span>));</span>
<span id="cb330-18"><a href="#cb330-18" aria-hidden="true"></a></span>
<span id="cb330-19"><a href="#cb330-19" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb330-20"><a href="#cb330-20" aria-hidden="true"></a>}</span></code></pre></div>
<p>The ostream_iterator is what’s called an <em>iterator adaptor</em>. It is templatized over the type to print out to the stream (in this case, <code>char</code>). <code>cout</code> (aka console output) is the stream we want to write to, and the space character (<code>" "</code>) is what we want printed between each element stored in the vector.</p>
<p>This standard algorithm is powerful and so are many others. The power and flexibility the standard library gives you are what make it so great. Just imagine: you can print a vector to the console with just <strong>one</strong> line of code. You don’t have to deal with special cases with the separator character. You don’t need to worry about for-loops. The standard library does it all for you.</p>
</section>
<section id="answer-3-score-64" class="level4">
<h4>Answer 3 (score 64)</h4>
<p>In C++11 you can now use a <a href="http://en.cppreference.com/w/cpp/language/range-for">range-based for loop</a>:</p>
<div class="sourceCode" id="cb331"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb331-1"><a href="#cb331-1" aria-hidden="true"></a><span class="cf">for</span> (<span class="kw">auto</span> <span class="at">const</span>&amp; c : path)</span>
<span id="cb331-2"><a href="#cb331-2" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; c &lt;&lt; <span class="ch">&#39; &#39;</span>;</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-to-concatenate-a-stdstring-and-an-int-score-601901-in-2017" class="level3">
<h3>50: How to concatenate a std::string and an int? (score <a href="https://stackoverflow.com/q/191757.html">601901</a> in 2017)</h3>
<section id="question-47" class="level4">
<h4>Question</h4>
<p>I thought this would be really simple but it’s presenting some difficulties. If I have</p>
<div class="sourceCode" id="cb332"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb332-1"><a href="#cb332-1" aria-hidden="true"></a><span class="bu">std::</span>string name = <span class="st">&quot;John&quot;</span>;</span>
<span id="cb332-2"><a href="#cb332-2" aria-hidden="true"></a><span class="dt">int</span> age = <span class="dv">21</span>;</span></code></pre></div>
<p>How do I combine them to get a single string <code>"John21"</code>?</p>
</section>
<section id="answer-2-score-1062" class="level4">
<h4>Answer 2 (score 1062)</h4>
<p>In alphabetical order:</p>
<div class="sourceCode" id="cb333"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb333-1"><a href="#cb333-1" aria-hidden="true"></a><span class="bu">std::</span>string name = <span class="st">&quot;John&quot;</span>;</span>
<span id="cb333-2"><a href="#cb333-2" aria-hidden="true"></a><span class="dt">int</span> age = <span class="dv">21</span>;</span>
<span id="cb333-3"><a href="#cb333-3" aria-hidden="true"></a><span class="bu">std::</span>string result;</span>
<span id="cb333-4"><a href="#cb333-4" aria-hidden="true"></a></span>
<span id="cb333-5"><a href="#cb333-5" aria-hidden="true"></a><span class="co">// 1. with Boost</span></span>
<span id="cb333-6"><a href="#cb333-6" aria-hidden="true"></a>result = name + <span class="ex">boost::</span>lexical_cast&lt;<span class="bu">std::</span>string&gt;(age);</span>
<span id="cb333-7"><a href="#cb333-7" aria-hidden="true"></a></span>
<span id="cb333-8"><a href="#cb333-8" aria-hidden="true"></a><span class="co">// 2. with C++11</span></span>
<span id="cb333-9"><a href="#cb333-9" aria-hidden="true"></a>result = name + <span class="bu">std::</span>to_string(age);</span>
<span id="cb333-10"><a href="#cb333-10" aria-hidden="true"></a></span>
<span id="cb333-11"><a href="#cb333-11" aria-hidden="true"></a><span class="co">// 3. with FastFormat.Format</span></span>
<span id="cb333-12"><a href="#cb333-12" aria-hidden="true"></a>fastformat::fmt(result, <span class="st">&quot;</span><span class="sc">{0}{1}</span><span class="st">&quot;</span>, name, age);</span>
<span id="cb333-13"><a href="#cb333-13" aria-hidden="true"></a></span>
<span id="cb333-14"><a href="#cb333-14" aria-hidden="true"></a><span class="co">// 4. with FastFormat.Write</span></span>
<span id="cb333-15"><a href="#cb333-15" aria-hidden="true"></a>fastformat::write(result, name, age);</span>
<span id="cb333-16"><a href="#cb333-16" aria-hidden="true"></a></span>
<span id="cb333-17"><a href="#cb333-17" aria-hidden="true"></a><span class="co">// 5. with the {fmt} library</span></span>
<span id="cb333-18"><a href="#cb333-18" aria-hidden="true"></a>result = fmt::format(<span class="st">&quot;</span><span class="sc">{}{}</span><span class="st">&quot;</span>, name, age);</span>
<span id="cb333-19"><a href="#cb333-19" aria-hidden="true"></a></span>
<span id="cb333-20"><a href="#cb333-20" aria-hidden="true"></a><span class="co">// 6. with IOStreams</span></span>
<span id="cb333-21"><a href="#cb333-21" aria-hidden="true"></a><span class="bu">std::</span>stringstream sstm;</span>
<span id="cb333-22"><a href="#cb333-22" aria-hidden="true"></a>sstm &lt;&lt; name &lt;&lt; age;</span>
<span id="cb333-23"><a href="#cb333-23" aria-hidden="true"></a>result = sstm.str();</span>
<span id="cb333-24"><a href="#cb333-24" aria-hidden="true"></a></span>
<span id="cb333-25"><a href="#cb333-25" aria-hidden="true"></a><span class="co">// 7. with itoa</span></span>
<span id="cb333-26"><a href="#cb333-26" aria-hidden="true"></a><span class="dt">char</span> numstr[<span class="dv">21</span>]; <span class="co">// enough to hold all numbers up to 64-bits</span></span>
<span id="cb333-27"><a href="#cb333-27" aria-hidden="true"></a>result = name + itoa(age, numstr, <span class="dv">10</span>);</span>
<span id="cb333-28"><a href="#cb333-28" aria-hidden="true"></a></span>
<span id="cb333-29"><a href="#cb333-29" aria-hidden="true"></a><span class="co">// 8. with sprintf</span></span>
<span id="cb333-30"><a href="#cb333-30" aria-hidden="true"></a><span class="dt">char</span> numstr[<span class="dv">21</span>]; <span class="co">// enough to hold all numbers up to 64-bits</span></span>
<span id="cb333-31"><a href="#cb333-31" aria-hidden="true"></a>sprintf(numstr, <span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>, age);</span>
<span id="cb333-32"><a href="#cb333-32" aria-hidden="true"></a>result = name + numstr;</span>
<span id="cb333-33"><a href="#cb333-33" aria-hidden="true"></a></span>
<span id="cb333-34"><a href="#cb333-34" aria-hidden="true"></a><span class="co">// 9. with STLSoft&#39;s integer_to_string</span></span>
<span id="cb333-35"><a href="#cb333-35" aria-hidden="true"></a><span class="dt">char</span> numstr[<span class="dv">21</span>]; <span class="co">// enough to hold all numbers up to 64-bits</span></span>
<span id="cb333-36"><a href="#cb333-36" aria-hidden="true"></a>result = name + stlsoft::integer_to_string(numstr, <span class="dv">21</span>, age);</span>
<span id="cb333-37"><a href="#cb333-37" aria-hidden="true"></a></span>
<span id="cb333-38"><a href="#cb333-38" aria-hidden="true"></a><span class="co">// 10. with STLSoft&#39;s winstl::int_to_string()</span></span>
<span id="cb333-39"><a href="#cb333-39" aria-hidden="true"></a>result = name + winstl::int_to_string(age);</span>
<span id="cb333-40"><a href="#cb333-40" aria-hidden="true"></a></span>
<span id="cb333-41"><a href="#cb333-41" aria-hidden="true"></a><span class="co">// 11. With Poco NumberFormatter</span></span>
<span id="cb333-42"><a href="#cb333-42" aria-hidden="true"></a>result = name + Poco::NumberFormatter().format(age);</span></code></pre></div>
<ol>
<li>
is safe, but slow; requires <a href="http://www.boost.org/" rel="noreferrer">Boost</a> (header-only); most/all platforms
</li>
<li>
is safe, requires C++11 (<a href="http://www.cplusplus.com/reference/string/to_string/" rel="noreferrer">to_string()</a> is already included in <code>#include &amp;lt;string&amp;gt;</code>)
</li>
<li>
is safe, and fast; requires <a href="http://fastformat.sourceforge.net/" rel="noreferrer">FastFormat</a>, which must be compiled; most/all platforms
</li>
<li>
(<em>ditto</em>)
</li>
<li>
is safe, and fast; requires <a href="https://github.com/fmtlib/fmt" rel="noreferrer">the {fmt} library</a>, which can either be compiled or used in a header-only mode; most/all platforms
</li>
<li>
safe, slow, and verbose; requires <code>#include &amp;lt;sstream&amp;gt;</code> (from standard C++)
</li>
<li>
is brittle (you must supply a large enough buffer), fast, and verbose; itoa() is a non-standard extension, and not guaranteed to be available for all platforms
</li>
<li>
is brittle (you must supply a large enough buffer), fast, and verbose; requires nothing (is standard C++); all platforms
</li>
<li>
is brittle (you must supply a large enough buffer), <a href="http://www.ddj.com/cpp/184401596" rel="noreferrer">probably the fastest-possible conversion</a>, verbose; requires <a href="http://www.stlsoft.org/" rel="noreferrer">STLSoft</a> (header-only); most/all platforms
</li>
<li>
safe-ish (you don’t use more than one <a href="http://www.stlsoft.org/doc-1.9/int%5F%5Fto%5F%5Fstring%5F8hpp.html" rel="noreferrer">int_to_string()</a> call in a single statement), fast; requires <a href="http://www.stlsoft.org/" rel="noreferrer">STLSoft</a> (header-only); Windows-only
</li>
<li>
is safe, but slow; requires <a href="http://www.boost.org/" rel="noreferrer">Poco C++</a> ; most/all platforms
</li>
</ol>
</section>
<section id="answer-3-score-251" class="level4">
<h4>Answer 3 (score 251)</h4>
<p>In C++11, you can use <code>std::to_string</code>, e.g.:</p>
<div class="sourceCode" id="cb334"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb334-1"><a href="#cb334-1" aria-hidden="true"></a><span class="kw">auto</span> result = name + <span class="bu">std::</span>to_string( age );</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-do-i-build-a-graphical-user-interface-in-c-score-587542-in-2019" class="level3">
<h3>51: How do I build a graphical user interface in C++? (score <a href="https://stackoverflow.com/q/1186017.html">587542</a> in 2019)</h3>
<section id="question-48" class="level4">
<h4>Question</h4>
<p>All of my C++ programs so far have been using the command line interface and the only other language I have experience with is PHP which doesn’t support GUIs.</p>
<p>Where do I start with graphical user interface programming in C++? How do I create one?</p>
</section>
<section id="answer-accepted-score-143" class="level4">
<h4>Answer accepted (score 143)</h4>
<p>Essentially an operating system’s windowing system exposes some API calls that you can perform to do jobs like create a window, or put a button on the window. Basically you get a suite of header files and you can call functions in those imported libraries, just like you’d do with stdlib and <code>printf</code>.</p>
<p>Each operating system comes with it’s own GUI toolkit, suite of header files, and API calls, and their own way of doing things. There are also cross platform toolkits like gtk, qt, and wx widgets that help you build programs that work anywhere. They achieve this by having the same API calls on each platform, but a different implementation for those API functions that call down to the native OS API calls.</p>
<p>One thing they’ll all have in common, which will be different from a CLI program, is something called an event loop. The basic idea there is somewhat complicated, and difficult to compress, but in essence it means that not a hell of a lot is going in in your main class/main function, except:</p>
<ul>
<li>
check the event queue if there’s any new events
</li>
<li>
if there is, dispatch those events to appropriate handlers
</li>
<li>
when you’re done, yield control back to the operating system (usually with some kind of special “sleep” or “select” or “yield” function call)
</li>
<li>
then the yield function will return when the operating system is done, and you have another go around the loop.
</li>
</ul>
<p>There are plenty of resources about event based programming. If you have any experience with javascript, it’s the same basic idea, except that you, the scripter have no access or control over the event loop itself, or what events there are, your only job is to write and register handlers.</p>
<p>You should keep in mind that GUI programming is incredibly complicated and difficult, in general. If you have the option, it’s actually much easier to just integrate an embedded webserver into your program and have an html/web based interface. The one exception that I’ve encountered is Apple’s cocoa+xcode+interface builder + tutorials that make it easily the most approachable environment for people new to GUI programming that I’ve seen.</p>
</section>
<section id="answer-2-score-156" class="level4">
<h4>Answer 2 (score 156)</h4>
<p>There are plenty of <b>free portable GUI libraries</b>, each with its own strengths and weaknesses:</p>
<ul>
<li>
<a href="https://www.qt.io/" rel="noreferrer">Qt</a>
<li>
<a href="http://www.gtkmm.org/" rel="noreferrer">GTKmm</a> (based on <a href="http://www.gtk.org/" rel="noreferrer">GTK+</a>)
<li>
<a href="http://www.wxwidgets.org/" rel="noreferrer">wxWidgets</a>
<li>
<a href="http://www.fltk.org/" rel="noreferrer">FLTK</a>
<li>
<a href="http://www.ultimatepp.org/" rel="noreferrer">Ultimate++</a>
<li>
<a href="https://www.juce.com/" rel="noreferrer">JUCE</a>
<li>
<p>…</p>
</ul>
<p>Especially <a href="http://doc.qt.io/qt-5/qtexamplesandtutorials.html" rel="noreferrer">Qt has nice tutorials</a> and tools which help you getting started. Enjoy!</p>
<p>Note, however, that you should <b>avoid platform specific</b> functionality such as the Win32 API or MFC. That ties you unnecessarily on a specific platform with almost no benefits.</p>
</section>
<section id="answer-3-score-72" class="level4">
<h4>Answer 3 (score 72)</h4>
<p>OS independent algorithm “<em>Creating GUI applications in C++ in three steps</em>”:</p>
<ol>
<li>
<p>
Install <a href="https://www.qt.io/download-open-source/" rel="noreferrer">Qt Creator</a>
</p>
<a href="https://i.stack.imgur.com/F87hl.png" rel="noreferrer"><img src="https://i.stack.imgur.com/F87hl.png" alt="enter image description here"></a>
</li>
<li>
<p>
Create new project (Qt Widgets Application)
</p>
<a href="https://i.stack.imgur.com/VXVsJ.png" rel="noreferrer"><img src="https://i.stack.imgur.com/VXVsJ.png" alt="enter image description here"></a>
</li>
<li>
<p>
Build it.
</p>
</li>
</ol>
<p>Congratulations, you’ve got your first GUI in C++.</p>
<p>Now you’re ready to read a lot of <a href="http://doc.qt.io/" rel="noreferrer">documentation</a> to create something more complicate than “Hello world” GUI application.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-to-call-a-parent-class-function-from-derived-class-function-score-577074-in-2014" class="level3">
<h3>52: How to call a parent class function from derived class function? (score <a href="https://stackoverflow.com/q/357307.html">577074</a> in 2014)</h3>
<section id="question-49" class="level4">
<h4>Question</h4>
<p>
How do I call the parent function from a derived class using C++? For example, I have a class called <code>parent</code>, and a class called <code>child</code> which is derived from parent. Within each class there is a <code>print</code> function. In the definition of the child’s print function I would like to make a call to the parents print function. How would I go about doing this?
</p>
</section>
<section id="answer-accepted-score-701-1" class="level4">
<h4>Answer accepted (score 701)</h4>
<p>I’ll take the risk of stating the obvious: You call the function, if it’s defined in the base class it’s automatically available in the derived class (unless it’s <code>private</code>).</p>
<p>If there is a function with the same signature in the derived class you can disambiguate it by adding the base class’s name followed by two colons <code>base_class::foo(...)</code>. You should note that unlike Java and C #, C++ does <strong>not</strong> have a keyword for “the base class” (<code>super</code> or <code>base</code>) since C++ supports <a href="http://en.wikipedia.org/wiki/Multiple_inheritance" rel="noreferrer">multiple inheritance</a> which may lead to ambiguity.</p>
<div class="sourceCode" id="cb335"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb335-1"><a href="#cb335-1" aria-hidden="true"></a><span class="kw">class</span> left {</span>
<span id="cb335-2"><a href="#cb335-2" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb335-3"><a href="#cb335-3" aria-hidden="true"></a>    <span class="dt">void</span> foo();</span>
<span id="cb335-4"><a href="#cb335-4" aria-hidden="true"></a>};</span>
<span id="cb335-5"><a href="#cb335-5" aria-hidden="true"></a></span>
<span id="cb335-6"><a href="#cb335-6" aria-hidden="true"></a><span class="kw">class</span> right {</span>
<span id="cb335-7"><a href="#cb335-7" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb335-8"><a href="#cb335-8" aria-hidden="true"></a>    <span class="dt">void</span> foo();</span>
<span id="cb335-9"><a href="#cb335-9" aria-hidden="true"></a>};</span>
<span id="cb335-10"><a href="#cb335-10" aria-hidden="true"></a></span>
<span id="cb335-11"><a href="#cb335-11" aria-hidden="true"></a><span class="kw">class</span> bottom : <span class="kw">public</span> left, <span class="kw">public</span> right {</span>
<span id="cb335-12"><a href="#cb335-12" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb335-13"><a href="#cb335-13" aria-hidden="true"></a>    <span class="dt">void</span> foo()</span>
<span id="cb335-14"><a href="#cb335-14" aria-hidden="true"></a>    {</span>
<span id="cb335-15"><a href="#cb335-15" aria-hidden="true"></a>        <span class="co">//base::foo();// ambiguous</span></span>
<span id="cb335-16"><a href="#cb335-16" aria-hidden="true"></a>        left::foo();</span>
<span id="cb335-17"><a href="#cb335-17" aria-hidden="true"></a>        right::foo();</span>
<span id="cb335-18"><a href="#cb335-18" aria-hidden="true"></a></span>
<span id="cb335-19"><a href="#cb335-19" aria-hidden="true"></a>        <span class="co">// and when foo() is not called for &#39;this&#39;:</span></span>
<span id="cb335-20"><a href="#cb335-20" aria-hidden="true"></a>        bottom b;</span>
<span id="cb335-21"><a href="#cb335-21" aria-hidden="true"></a>        b.left::foo();  <span class="co">// calls b.foo() from &#39;left&#39;</span></span>
<span id="cb335-22"><a href="#cb335-22" aria-hidden="true"></a>        b.right::foo();  <span class="co">// call b.foo() from &#39;right&#39;</span></span>
<span id="cb335-23"><a href="#cb335-23" aria-hidden="true"></a>    }</span>
<span id="cb335-24"><a href="#cb335-24" aria-hidden="true"></a>};</span></code></pre></div>
<p>Incidentally, you can’t derive directly from the same class twice since there will be no way to refer to one of the base classes over the other.</p>
<div class="sourceCode" id="cb336"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb336-1"><a href="#cb336-1" aria-hidden="true"></a><span class="kw">class</span> bottom : <span class="kw">public</span> left, <span class="kw">public</span> left { <span class="co">// Illegal</span></span>
<span id="cb336-2"><a href="#cb336-2" aria-hidden="true"></a>};</span></code></pre></div>
</section>
<section id="answer-2-score-182" class="level4">
<h4>Answer 2 (score 182)</h4>
<p>Given parent class named <code>Parent</code> and child class named <code>Child</code>, you can do something like this:</p>
<div class="sourceCode" id="cb337"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb337-1"><a href="#cb337-1" aria-hidden="true"></a><span class="kw">class</span> Parent {</span>
<span id="cb337-2"><a href="#cb337-2" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb337-3"><a href="#cb337-3" aria-hidden="true"></a>    <span class="kw">virtual</span> <span class="dt">void</span> print(<span class="dt">int</span> x);</span>
<span id="cb337-4"><a href="#cb337-4" aria-hidden="true"></a>}</span>
<span id="cb337-5"><a href="#cb337-5" aria-hidden="true"></a></span>
<span id="cb337-6"><a href="#cb337-6" aria-hidden="true"></a><span class="kw">class</span> Child : <span class="kw">public</span> Parent {</span>
<span id="cb337-7"><a href="#cb337-7" aria-hidden="true"></a>    <span class="dt">void</span> print(<span class="dt">int</span> x) <span class="kw">override</span>;</span>
<span id="cb337-8"><a href="#cb337-8" aria-hidden="true"></a>}</span>
<span id="cb337-9"><a href="#cb337-9" aria-hidden="true"></a></span>
<span id="cb337-10"><a href="#cb337-10" aria-hidden="true"></a><span class="dt">void</span> Parent::print(<span class="dt">int</span> x) {</span>
<span id="cb337-11"><a href="#cb337-11" aria-hidden="true"></a>    <span class="co">// some default behavior</span></span>
<span id="cb337-12"><a href="#cb337-12" aria-hidden="true"></a>}</span>
<span id="cb337-13"><a href="#cb337-13" aria-hidden="true"></a></span>
<span id="cb337-14"><a href="#cb337-14" aria-hidden="true"></a><span class="dt">void</span> Child::print(<span class="dt">int</span> x) {</span>
<span id="cb337-15"><a href="#cb337-15" aria-hidden="true"></a>    <span class="co">// use Parent&#39;s print method; implicitly passes &#39;this&#39; to Parent::print</span></span>
<span id="cb337-16"><a href="#cb337-16" aria-hidden="true"></a>    Parent::print(x);</span>
<span id="cb337-17"><a href="#cb337-17" aria-hidden="true"></a>}</span></code></pre></div>
<p>Note that <code>Parent</code> is the class’s actual name and not a keyword.</p>
</section>
<section id="answer-3-score-30-1" class="level4">
<h4>Answer 3 (score 30)</h4>
<p>If your base class is called <code>Base</code>, and your function is called <code>FooBar()</code> you can call it directly using <code>Base::FooBar()</code></p>
<div class="sourceCode" id="cb338"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb338-1"><a href="#cb338-1" aria-hidden="true"></a><span class="dt">void</span> Base::FooBar()</span>
<span id="cb338-2"><a href="#cb338-2" aria-hidden="true"></a>{</span>
<span id="cb338-3"><a href="#cb338-3" aria-hidden="true"></a>   printf(<span class="st">&quot;in Base</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb338-4"><a href="#cb338-4" aria-hidden="true"></a>}</span>
<span id="cb338-5"><a href="#cb338-5" aria-hidden="true"></a></span>
<span id="cb338-6"><a href="#cb338-6" aria-hidden="true"></a><span class="dt">void</span> ChildOfBase::FooBar()</span>
<span id="cb338-7"><a href="#cb338-7" aria-hidden="true"></a>{</span>
<span id="cb338-8"><a href="#cb338-8" aria-hidden="true"></a>  Base::FooBar();</span>
<span id="cb338-9"><a href="#cb338-9" aria-hidden="true"></a>}</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="passing-a-2d-array-to-a-c-function-score-576831-in-2015" class="level3">
<h3>53: Passing a 2D array to a C++ function (score <a href="https://stackoverflow.com/q/8767166.html">576831</a> in 2015)</h3>
<section id="question-50" class="level4">
<h4>Question</h4>
<p>I have a function which I want to take, as a parameter, a 2D array of variable size.</p>
<p>So far I have this:</p>
<div class="sourceCode" id="cb339"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb339-1"><a href="#cb339-1" aria-hidden="true"></a><span class="dt">void</span> myFunction(<span class="dt">double</span>** myArray){</span>
<span id="cb339-2"><a href="#cb339-2" aria-hidden="true"></a>     myArray[x][y] = <span class="dv">5</span>;</span>
<span id="cb339-3"><a href="#cb339-3" aria-hidden="true"></a>     etc...</span>
<span id="cb339-4"><a href="#cb339-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>And I have declared an array elsewhere in my code:</p>
<div class="sourceCode" id="cb340"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb340-1"><a href="#cb340-1" aria-hidden="true"></a><span class="dt">double</span> anArray[<span class="dv">10</span>][<span class="dv">10</span>];</span></code></pre></div>
<p>However, calling <code>myFunction(anArray)</code> gives me an error.</p>
<p>I do not want to copy the array when I pass it in. Any changes made in <code>myFunction</code> should alter the state of <code>anArray</code>. If I understand correctly, I only want to pass in as an argument a pointer to a 2D array. The function needs to accept arrays of different sizes also. So for example, <code>[10][10]</code> and <code>[5][5]</code>. How can I do this?</p>
</section>
<section id="answer-accepted-score-389" class="level4">
<h4>Answer accepted (score 389)</h4>
<p>There are three ways to pass a 2D array to a function:</p>
<ol>
<li>
<p>
The parameter is a 2D array
</p>
<div class="sourceCode" id="cb341"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb341-1"><a href="#cb341-1" aria-hidden="true"></a><span class="dt">int</span> array[<span class="dv">10</span>][<span class="dv">10</span>];</span>
<span id="cb341-2"><a href="#cb341-2" aria-hidden="true"></a><span class="dt">void</span> passFunc(<span class="dt">int</span> a[][<span class="dv">10</span>])</span>
<span id="cb341-3"><a href="#cb341-3" aria-hidden="true"></a>{</span>
<span id="cb341-4"><a href="#cb341-4" aria-hidden="true"></a>    <span class="co">// ...</span></span>
<span id="cb341-5"><a href="#cb341-5" aria-hidden="true"></a>}</span>
<span id="cb341-6"><a href="#cb341-6" aria-hidden="true"></a>passFunc(array);</span>
<span id="cb341-7"><a href="#cb341-7" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb341-8"><a href="#cb341-8" aria-hidden="true"></a>&lt;li&gt;&lt;p&gt;The parameter is an array containing pointers&lt;/p&gt;</span>
<span id="cb341-9"><a href="#cb341-9" aria-hidden="true"></a></span>
<span id="cb341-10"><a href="#cb341-10" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb341-11"><a href="#cb341-11" aria-hidden="true"></a><span class="dt">int</span> *array[<span class="dv">10</span>];</span>
<span id="cb341-12"><a href="#cb341-12" aria-hidden="true"></a><span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">10</span>; i++)</span>
<span id="cb341-13"><a href="#cb341-13" aria-hidden="true"></a>    array[i] = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">10</span>];</span>
<span id="cb341-14"><a href="#cb341-14" aria-hidden="true"></a><span class="dt">void</span> passFunc(<span class="dt">int</span> *a[<span class="dv">10</span>]) <span class="co">//Array containing pointers</span></span>
<span id="cb341-15"><a href="#cb341-15" aria-hidden="true"></a>{</span>
<span id="cb341-16"><a href="#cb341-16" aria-hidden="true"></a>    <span class="co">// ...</span></span>
<span id="cb341-17"><a href="#cb341-17" aria-hidden="true"></a>}</span>
<span id="cb341-18"><a href="#cb341-18" aria-hidden="true"></a>passFunc(array);</span>
<span id="cb341-19"><a href="#cb341-19" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb341-20"><a href="#cb341-20" aria-hidden="true"></a>&lt;li&gt;&lt;p&gt;The parameter is a pointer to a pointer&lt;/p&gt;</span>
<span id="cb341-21"><a href="#cb341-21" aria-hidden="true"></a></span>
<span id="cb341-22"><a href="#cb341-22" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb341-23"><a href="#cb341-23" aria-hidden="true"></a><span class="dt">int</span> **array;</span>
<span id="cb341-24"><a href="#cb341-24" aria-hidden="true"></a>array = <span class="kw">new</span> <span class="dt">int</span> *[<span class="dv">10</span>];</span>
<span id="cb341-25"><a href="#cb341-25" aria-hidden="true"></a><span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;<span class="dv">10</span>; i++)</span>
<span id="cb341-26"><a href="#cb341-26" aria-hidden="true"></a>    array[i] = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">10</span>];</span>
<span id="cb341-27"><a href="#cb341-27" aria-hidden="true"></a><span class="dt">void</span> passFunc(<span class="dt">int</span> **a)</span>
<span id="cb341-28"><a href="#cb341-28" aria-hidden="true"></a>{</span>
<span id="cb341-29"><a href="#cb341-29" aria-hidden="true"></a>    <span class="co">// ...</span></span>
<span id="cb341-30"><a href="#cb341-30" aria-hidden="true"></a>}</span>
<span id="cb341-31"><a href="#cb341-31" aria-hidden="true"></a>passFunc(array);</span>
<span id="cb341-32"><a href="#cb341-32" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb341-33"><a href="#cb341-33" aria-hidden="true"></a>&lt;/ol&gt;</span>
<span id="cb341-34"><a href="#cb341-34" aria-hidden="true"></a></span>
<span id="cb341-35"><a href="#cb341-35" aria-hidden="true"></a></span>
<span id="cb341-36"><a href="#cb341-36" aria-hidden="true"></a><span class="pp">#</span><span class="er">### Answer 2 (score 160)</span></span>
<span id="cb341-37"><a href="#cb341-37" aria-hidden="true"></a>&lt;h5&gt;Fixed Size&lt;/h2&gt;</span>
<span id="cb341-38"><a href="#cb341-38" aria-hidden="true"></a></span>
<span id="cb341-39"><a href="#cb341-39" aria-hidden="true"></a>&lt;strong&gt;<span class="fl">1.</span> Pass by reference&lt;/strong&gt;  </span>
<span id="cb341-40"><a href="#cb341-40" aria-hidden="true"></a></span>
<span id="cb341-41"><a href="#cb341-41" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb341-42"><a href="#cb341-42" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="dt">size_t</span> rows, <span class="dt">size_t</span> cols&gt;</span>
<span id="cb341-43"><a href="#cb341-43" aria-hidden="true"></a><span class="dt">void</span> process_2d_array_template(<span class="dt">int</span> (&amp;array)[rows][cols])</span>
<span id="cb341-44"><a href="#cb341-44" aria-hidden="true"></a>{</span>
<span id="cb341-45"><a href="#cb341-45" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="ot">__func__</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb341-46"><a href="#cb341-46" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; rows; ++i)</span>
<span id="cb341-47"><a href="#cb341-47" aria-hidden="true"></a>    {</span>
<span id="cb341-48"><a href="#cb341-48" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; i &lt;&lt; <span class="st">&quot;: &quot;</span>;</span>
<span id="cb341-49"><a href="#cb341-49" aria-hidden="true"></a>        <span class="cf">for</span> (<span class="dt">size_t</span> j = <span class="dv">0</span>; j &lt; cols; ++j)</span>
<span id="cb341-50"><a href="#cb341-50" aria-hidden="true"></a>            <span class="bu">std::</span>cout &lt;&lt; array[i][j] &lt;&lt; <span class="ch">&#39;</span><span class="sc">\t</span><span class="ch">&#39;</span>;</span>
<span id="cb341-51"><a href="#cb341-51" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb341-52"><a href="#cb341-52" aria-hidden="true"></a>    }</span>
<span id="cb341-53"><a href="#cb341-53" aria-hidden="true"></a>}</span></code></pre></div>
<p>In C++ passing the array by reference without losing the dimension information is probably the safest, since one needn’t worry about the caller passing an incorrect dimension (compiler flags when mismatching). However, this isn’t possible with dynamic (freestore) arrays; it works for automatic (<a href="https://stackoverflow.com/a/6500497/183120">usually stack-living</a>) arrays only i.e. the dimensionality should be known at compile time.</p>
<p><strong>2. Pass by pointer</strong></p>
<div class="sourceCode" id="cb342"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb342-1"><a href="#cb342-1" aria-hidden="true"></a><span class="dt">void</span> process_2d_array_pointer(<span class="dt">int</span> (*array)[<span class="dv">5</span>][<span class="dv">10</span>])</span>
<span id="cb342-2"><a href="#cb342-2" aria-hidden="true"></a>{</span>
<span id="cb342-3"><a href="#cb342-3" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="ot">__func__</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb342-4"><a href="#cb342-4" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; <span class="dv">5</span>; ++i)</span>
<span id="cb342-5"><a href="#cb342-5" aria-hidden="true"></a>    {</span>
<span id="cb342-6"><a href="#cb342-6" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; i &lt;&lt; <span class="st">&quot;: &quot;</span>;</span>
<span id="cb342-7"><a href="#cb342-7" aria-hidden="true"></a>        <span class="cf">for</span> (<span class="dt">size_t</span> j = <span class="dv">0</span>; j &lt; <span class="dv">10</span>; ++j)</span>
<span id="cb342-8"><a href="#cb342-8" aria-hidden="true"></a>            <span class="bu">std::</span>cout &lt;&lt; (*array)[i][j] &lt;&lt; <span class="ch">&#39;</span><span class="sc">\t</span><span class="ch">&#39;</span>;</span>
<span id="cb342-9"><a href="#cb342-9" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb342-10"><a href="#cb342-10" aria-hidden="true"></a>    }    </span>
<span id="cb342-11"><a href="#cb342-11" aria-hidden="true"></a>}</span></code></pre></div>
<p>The C equivalent of the previous method is passing the array by pointer. This should not be confused with passing by the array’s decayed pointer type <strong>(3)</strong>, which is the common, popular method, albeit less safe than this one but more flexible. Like <strong>(1)</strong>, use this method when all the dimensions of the array is fixed and known at compile-time. Note that when calling the function the array’s address should be passed <code>process_2d_array_pointer(&amp;amp;a)</code> and not the address of the first element by decay <code>process_2d_array_pointer(a)</code>.</p>
<h5>
Variable Size
</h2>
<p>These are inherited from C but are less safe, the compiler has no way of checking, guaranteeing that the caller is passing the required dimensions. The function only banks on what the caller passes in as the dimension(s). These are more flexible than the above ones since arrays of different lengths can be passed to them invariably.</p>
<p>It is to be remembered that there’s no such thing as passing an array directly to a function in C [while in C++ they can be passed as a reference <strong>(1)</strong>]; <strong>(2)</strong> is passing a pointer to the array and not the array itself. Always passing an array as-is becomes a pointer-copy operation which is facilitated by <a href="https://stackoverflow.com/questions/4810664/how-do-i-use-arrays-in-c">array’s nature of decaying into a pointer</a>.</p>
<p><strong>3. Pass by (value) a pointer to the decayed type</strong></p>
<div class="sourceCode" id="cb343"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb343-1"><a href="#cb343-1" aria-hidden="true"></a><span class="co">// int array[][10] is just fancy notation for the same thing</span></span>
<span id="cb343-2"><a href="#cb343-2" aria-hidden="true"></a><span class="dt">void</span> process_2d_array(<span class="dt">int</span> (*array)[<span class="dv">10</span>], <span class="dt">size_t</span> rows)</span>
<span id="cb343-3"><a href="#cb343-3" aria-hidden="true"></a>{</span>
<span id="cb343-4"><a href="#cb343-4" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="ot">__func__</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb343-5"><a href="#cb343-5" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; rows; ++i)</span>
<span id="cb343-6"><a href="#cb343-6" aria-hidden="true"></a>    {</span>
<span id="cb343-7"><a href="#cb343-7" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; i &lt;&lt; <span class="st">&quot;: &quot;</span>;</span>
<span id="cb343-8"><a href="#cb343-8" aria-hidden="true"></a>        <span class="cf">for</span> (<span class="dt">size_t</span> j = <span class="dv">0</span>; j &lt; <span class="dv">10</span>; ++j)</span>
<span id="cb343-9"><a href="#cb343-9" aria-hidden="true"></a>            <span class="bu">std::</span>cout &lt;&lt; array[i][j] &lt;&lt; <span class="ch">&#39;</span><span class="sc">\t</span><span class="ch">&#39;</span>;</span>
<span id="cb343-10"><a href="#cb343-10" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb343-11"><a href="#cb343-11" aria-hidden="true"></a>    }</span>
<span id="cb343-12"><a href="#cb343-12" aria-hidden="true"></a>}</span></code></pre></div>
<p>Although <code>int array[][10]</code> is allowed, I’d not recommend it over the above syntax since the above syntax makes it clear that the identifier <code>array</code> is a single pointer to an array of 10 integers, while this syntax <em>looks</em> like it’s a 2D array but is the same pointer to an array of 10 integers. Here we know the number of elements in a single row (i.e. the column size, 10 here) but the number of rows is unknown and hence to be passed as an argument. In this case there’s some safety since the compiler can flag when a pointer to an array with second dimension not equal to 10 is passed. The first dimension is the varying part and can be omitted. <a href="https://stackoverflow.com/a/8205191/183120">See here for the rationale</a> on why only the first dimension is allowed to be omitted.</p>
<p><strong>4. Pass by pointer to a pointer</strong></p>
<div class="sourceCode" id="cb344"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb344-1"><a href="#cb344-1" aria-hidden="true"></a><span class="co">// int *array[10] is just fancy notation for the same thing</span></span>
<span id="cb344-2"><a href="#cb344-2" aria-hidden="true"></a><span class="dt">void</span> process_pointer_2_pointer(<span class="dt">int</span> **array, <span class="dt">size_t</span> rows, <span class="dt">size_t</span> cols)</span>
<span id="cb344-3"><a href="#cb344-3" aria-hidden="true"></a>{</span>
<span id="cb344-4"><a href="#cb344-4" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="ot">__func__</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb344-5"><a href="#cb344-5" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; rows; ++i)</span>
<span id="cb344-6"><a href="#cb344-6" aria-hidden="true"></a>    {</span>
<span id="cb344-7"><a href="#cb344-7" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; i &lt;&lt; <span class="st">&quot;: &quot;</span>;</span>
<span id="cb344-8"><a href="#cb344-8" aria-hidden="true"></a>        <span class="cf">for</span> (<span class="dt">size_t</span> j = <span class="dv">0</span>; j &lt; cols; ++j)</span>
<span id="cb344-9"><a href="#cb344-9" aria-hidden="true"></a>            <span class="bu">std::</span>cout &lt;&lt; array[i][j] &lt;&lt; <span class="ch">&#39;</span><span class="sc">\t</span><span class="ch">&#39;</span>;</span>
<span id="cb344-10"><a href="#cb344-10" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb344-11"><a href="#cb344-11" aria-hidden="true"></a>    }</span>
<span id="cb344-12"><a href="#cb344-12" aria-hidden="true"></a>}</span></code></pre></div>
<p>Again there’s an alternative syntax of <code>int *array[10]</code> which is the same as <code>int **array</code>. In this syntax the <code>[10]</code> is ignored as it decays into a pointer thereby becoming <code>int **array</code>. Perhaps it is just a cue to the caller that the passed array should have at least 10 columns, even then row count is required. In any case the compiler doesn’t flag for any length/size violations (it only checks if the type passed is a pointer to pointer), hence requiring both row and column counts as parameter makes sense here.</p>
<p><strong>Note:</strong> <em>(4) is the least safest option</em> since it hardly has any type check and the most inconvenient. One cannot legitimately pass a 2D array to this function; <a href="http://c-faq.com/aryptr/pass2dary.html" rel="noreferrer">C-FAQ condemns</a> the usual workaround of doing <code>int x[5][10]; process_pointer_2_pointer((int**)&amp;amp;x[0][0], 5, 10);</code> as it <a href="https://stackoverflow.com/a/7785116/183120">may potentially lead to undefined behaviour</a> due to array flattening. The right way of passing an array in this method brings us to the inconvenient part i.e. we need an additional (surrogate) array of pointers with each of its element pointing to the respective row of the actual, to-be-passed array; this surrogate is then passed to the function (see below); all this for getting the same job done as the above methods which are more safer, cleaner and perhaps faster.</p>
<p>Here’s a driver program to test the above functions:</p>
<div class="sourceCode" id="cb345"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb345-1"><a href="#cb345-1" aria-hidden="true"></a></span>
<span id="cb345-2"><a href="#cb345-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb345-3"><a href="#cb345-3" aria-hidden="true"></a></span>
<span id="cb345-4"><a href="#cb345-4" aria-hidden="true"></a><span class="co">// copy above functions here</span></span>
<span id="cb345-5"><a href="#cb345-5" aria-hidden="true"></a></span>
<span id="cb345-6"><a href="#cb345-6" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb345-7"><a href="#cb345-7" aria-hidden="true"></a>{</span>
<span id="cb345-8"><a href="#cb345-8" aria-hidden="true"></a>    <span class="dt">int</span> a[<span class="dv">5</span>][<span class="dv">10</span>] = { { } };</span>
<span id="cb345-9"><a href="#cb345-9" aria-hidden="true"></a>    process_2d_array_template(a);</span>
<span id="cb345-10"><a href="#cb345-10" aria-hidden="true"></a>    process_2d_array_pointer(&amp;a);    <span class="co">// &lt;-- notice the unusual usage of addressof (&amp;) operator on an array</span></span>
<span id="cb345-11"><a href="#cb345-11" aria-hidden="true"></a>    process_2d_array(a, <span class="dv">5</span>);</span>
<span id="cb345-12"><a href="#cb345-12" aria-hidden="true"></a>    <span class="co">// works since a&#39;s first dimension decays into a pointer thereby becoming int (*)[10]</span></span>
<span id="cb345-13"><a href="#cb345-13" aria-hidden="true"></a></span>
<span id="cb345-14"><a href="#cb345-14" aria-hidden="true"></a>    <span class="dt">int</span> *b[<span class="dv">5</span>];  <span class="co">// surrogate</span></span>
<span id="cb345-15"><a href="#cb345-15" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; <span class="dv">5</span>; ++i)</span>
<span id="cb345-16"><a href="#cb345-16" aria-hidden="true"></a>    {</span>
<span id="cb345-17"><a href="#cb345-17" aria-hidden="true"></a>        b[i] = a[i];</span>
<span id="cb345-18"><a href="#cb345-18" aria-hidden="true"></a>    }</span>
<span id="cb345-19"><a href="#cb345-19" aria-hidden="true"></a>    <span class="co">// another popular way to define b: here the 2D arrays dims may be non-const, runtime var</span></span>
<span id="cb345-20"><a href="#cb345-20" aria-hidden="true"></a>    <span class="co">// int **b = new int*[5];</span></span>
<span id="cb345-21"><a href="#cb345-21" aria-hidden="true"></a>    <span class="co">// for (size_t i = 0; i &lt; 5; ++i) b[i] = new int[10];</span></span>
<span id="cb345-22"><a href="#cb345-22" aria-hidden="true"></a>    process_pointer_2_pointer(b, <span class="dv">5</span>, <span class="dv">10</span>);</span>
<span id="cb345-23"><a href="#cb345-23" aria-hidden="true"></a>    <span class="co">// process_2d_array(b, 5);</span></span>
<span id="cb345-24"><a href="#cb345-24" aria-hidden="true"></a>    <span class="co">// doesn&#39;t work since b&#39;s first dimension decays into a pointer thereby becoming int**</span></span>
<span id="cb345-25"><a href="#cb345-25" aria-hidden="true"></a>}</span></code></pre></div>
</section>
<section id="answer-3-score-40" class="level4">
<h4>Answer 3 (score 40)</h4>
<p>A modification to shengy’s first suggestion, you can use templates to make the function accept a multi-dimensional array variable (instead of storing an array of pointers that have to be managed and deleted):</p>
<div class="sourceCode" id="cb346"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb346-1"><a href="#cb346-1" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="dt">size_t</span> size_x, <span class="dt">size_t</span> size_y&gt;</span>
<span id="cb346-2"><a href="#cb346-2" aria-hidden="true"></a><span class="dt">void</span> func(<span class="dt">double</span> (&amp;arr)[size_x][size_y])</span>
<span id="cb346-3"><a href="#cb346-3" aria-hidden="true"></a>{</span>
<span id="cb346-4"><a href="#cb346-4" aria-hidden="true"></a>    printf(<span class="st">&quot;</span><span class="sc">%p\n</span><span class="st">&quot;</span>, &amp;arr);</span>
<span id="cb346-5"><a href="#cb346-5" aria-hidden="true"></a>}</span>
<span id="cb346-6"><a href="#cb346-6" aria-hidden="true"></a></span>
<span id="cb346-7"><a href="#cb346-7" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb346-8"><a href="#cb346-8" aria-hidden="true"></a>{</span>
<span id="cb346-9"><a href="#cb346-9" aria-hidden="true"></a>    <span class="dt">double</span> a1[<span class="dv">10</span>][<span class="dv">10</span>];</span>
<span id="cb346-10"><a href="#cb346-10" aria-hidden="true"></a>    <span class="dt">double</span> a2[<span class="dv">5</span>][<span class="dv">5</span>];</span>
<span id="cb346-11"><a href="#cb346-11" aria-hidden="true"></a></span>
<span id="cb346-12"><a href="#cb346-12" aria-hidden="true"></a>    printf(<span class="st">&quot;</span><span class="sc">%p\n%p\n\n</span><span class="st">&quot;</span>, &amp;a1, &amp;a2);</span>
<span id="cb346-13"><a href="#cb346-13" aria-hidden="true"></a>    func(a1);</span>
<span id="cb346-14"><a href="#cb346-14" aria-hidden="true"></a>    func(a2);</span>
<span id="cb346-15"><a href="#cb346-15" aria-hidden="true"></a></span>
<span id="cb346-16"><a href="#cb346-16" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb346-17"><a href="#cb346-17" aria-hidden="true"></a>}</span></code></pre></div>
<p>The print statements are there to show that the arrays are getting passed by reference (by displaying the variables’ addresses)</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="fastest-way-to-check-if-a-file-exist-using-standard-cc11c-score-550079-in-2017" class="level3">
<h3>54: Fastest way to check if a file exist using standard C++/C++11/C? (score <a href="https://stackoverflow.com/q/12774207.html">550079</a> in 2017)</h3>
<section id="question-51" class="level4">
<h4>Question</h4>
<p>I would like to find the fastest way to check if a file exist in standard C++11, C++, or C. I have thousands of files and before doing something on them I need to check if all of them exist. What can I write instead of <code>/* SOMETHING */</code> in the following function?</p>
<div class="sourceCode" id="cb347"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb347-1"><a href="#cb347-1" aria-hidden="true"></a><span class="kw">inline</span> <span class="dt">bool</span> exist(<span class="at">const</span> <span class="bu">std::</span>string&amp; name)</span>
<span id="cb347-2"><a href="#cb347-2" aria-hidden="true"></a>{</span>
<span id="cb347-3"><a href="#cb347-3" aria-hidden="true"></a>    <span class="co">/* SOMETHING */</span></span>
<span id="cb347-4"><a href="#cb347-4" aria-hidden="true"></a>}</span></code></pre></div>
</section>
<section id="answer-accepted-score-694" class="level4">
<h4>Answer accepted (score 694)</h4>
<p>Well I threw together a test program that ran each of these methods 100,000 times, half on files that existed and half on files that didn’t.</p>
<div class="sourceCode" id="cb348"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb348-1"><a href="#cb348-1" aria-hidden="true"></a></span>
<span id="cb348-2"><a href="#cb348-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sys/stat.h&gt;</span></span>
<span id="cb348-3"><a href="#cb348-3" aria-hidden="true"></a></span>
<span id="cb348-4"><a href="#cb348-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb348-5"><a href="#cb348-5" aria-hidden="true"></a></span>
<span id="cb348-6"><a href="#cb348-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb348-7"><a href="#cb348-7" aria-hidden="true"></a></span>
<span id="cb348-8"><a href="#cb348-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;fstream&gt;</span></span>
<span id="cb348-9"><a href="#cb348-9" aria-hidden="true"></a></span>
<span id="cb348-10"><a href="#cb348-10" aria-hidden="true"></a><span class="kw">inline</span> <span class="dt">bool</span> exists_test0 (<span class="at">const</span> <span class="bu">std::</span>string&amp; name) {</span>
<span id="cb348-11"><a href="#cb348-11" aria-hidden="true"></a>    ifstream f(name.c_str());</span>
<span id="cb348-12"><a href="#cb348-12" aria-hidden="true"></a>    <span class="cf">return</span> f.good();</span>
<span id="cb348-13"><a href="#cb348-13" aria-hidden="true"></a>}</span>
<span id="cb348-14"><a href="#cb348-14" aria-hidden="true"></a></span>
<span id="cb348-15"><a href="#cb348-15" aria-hidden="true"></a><span class="kw">inline</span> <span class="dt">bool</span> exists_test1 (<span class="at">const</span> <span class="bu">std::</span>string&amp; name) {</span>
<span id="cb348-16"><a href="#cb348-16" aria-hidden="true"></a>    <span class="cf">if</span> (<span class="dt">FILE</span> *file = fopen(name.c_str(), <span class="st">&quot;r&quot;</span>)) {</span>
<span id="cb348-17"><a href="#cb348-17" aria-hidden="true"></a>        fclose(file);</span>
<span id="cb348-18"><a href="#cb348-18" aria-hidden="true"></a>        <span class="cf">return</span> <span class="kw">true</span>;</span>
<span id="cb348-19"><a href="#cb348-19" aria-hidden="true"></a>    } <span class="cf">else</span> {</span>
<span id="cb348-20"><a href="#cb348-20" aria-hidden="true"></a>        <span class="cf">return</span> <span class="kw">false</span>;</span>
<span id="cb348-21"><a href="#cb348-21" aria-hidden="true"></a>    }   </span>
<span id="cb348-22"><a href="#cb348-22" aria-hidden="true"></a>}</span>
<span id="cb348-23"><a href="#cb348-23" aria-hidden="true"></a></span>
<span id="cb348-24"><a href="#cb348-24" aria-hidden="true"></a><span class="kw">inline</span> <span class="dt">bool</span> exists_test2 (<span class="at">const</span> <span class="bu">std::</span>string&amp; name) {</span>
<span id="cb348-25"><a href="#cb348-25" aria-hidden="true"></a>    <span class="cf">return</span> ( access( name.c_str(), F_OK ) != -<span class="dv">1</span> );</span>
<span id="cb348-26"><a href="#cb348-26" aria-hidden="true"></a>}</span>
<span id="cb348-27"><a href="#cb348-27" aria-hidden="true"></a></span>
<span id="cb348-28"><a href="#cb348-28" aria-hidden="true"></a><span class="kw">inline</span> <span class="dt">bool</span> exists_test3 (<span class="at">const</span> <span class="bu">std::</span>string&amp; name) {</span>
<span id="cb348-29"><a href="#cb348-29" aria-hidden="true"></a>  <span class="kw">struct</span> stat buffer;   </span>
<span id="cb348-30"><a href="#cb348-30" aria-hidden="true"></a>  <span class="cf">return</span> (stat (name.c_str(), &amp;buffer) == <span class="dv">0</span>); </span>
<span id="cb348-31"><a href="#cb348-31" aria-hidden="true"></a>}</span></code></pre></div>
<p>Results for total time to run the 100,000 calls averaged over 5 runs,</p>
<div class="sourceCode" id="cb349"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb349-1"><a href="#cb349-1" aria-hidden="true"></a>Method exists_test0 (ifstream): **<span class="fl">0.485</span><span class="bu">s</span>**</span>
<span id="cb349-2"><a href="#cb349-2" aria-hidden="true"></a>Method exists_test1 (<span class="dt">FILE</span> fopen): **<span class="fl">0.302</span><span class="bu">s</span>**</span>
<span id="cb349-3"><a href="#cb349-3" aria-hidden="true"></a>Method exists_test2 (posix access()): **<span class="fl">0.202</span><span class="bu">s</span>**</span>
<span id="cb349-4"><a href="#cb349-4" aria-hidden="true"></a>Method exists_test3 (posix stat()): **<span class="fl">0.134</span><span class="bu">s</span>**</span></code></pre></div>
<p>The <code>stat()</code> function provided the best performance on my system (Linux, compiled with <code>g++</code>), with a standard <code>fopen</code> call being your best bet if you for some reason refuse to use POSIX functions.</p>
</section>
<section id="answer-2-score-118" class="level4">
<h4>Answer 2 (score 118)</h4>
<p>Remark : in C++14 and as soon as the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4099.html" rel="noreferrer">filesystem TS</a> will be finished and adopted, the solution will be to use:</p>
<div class="sourceCode" id="cb350"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb350-1"><a href="#cb350-1" aria-hidden="true"></a><span class="bu">std::</span>experimental<span class="bu">::</span>filesystem<span class="bu">::</span>exists(<span class="st">&quot;helloworld.txt&quot;</span>);</span></code></pre></div>
<p>and since C++17, only:</p>
<div class="sourceCode" id="cb351"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb351-1"><a href="#cb351-1" aria-hidden="true"></a><span class="bu">std::</span>filesystem<span class="bu">::</span>exists(<span class="st">&quot;helloworld.txt&quot;</span>);</span></code></pre></div>
</section>
<section id="answer-3-score-104" class="level4">
<h4>Answer 3 (score 104)</h4>
<p>I use this piece of code, it works OK with me so far. This does not use many fancy features of C++:</p>
<div class="sourceCode" id="cb352"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb352-1"><a href="#cb352-1" aria-hidden="true"></a><span class="dt">bool</span> is_file_exist(<span class="at">const</span> <span class="dt">char</span> *fileName)</span>
<span id="cb352-2"><a href="#cb352-2" aria-hidden="true"></a>{</span>
<span id="cb352-3"><a href="#cb352-3" aria-hidden="true"></a>    <span class="bu">std::</span>ifstream infile(fileName);</span>
<span id="cb352-4"><a href="#cb352-4" aria-hidden="true"></a>    <span class="cf">return</span> infile.good();</span>
<span id="cb352-5"><a href="#cb352-5" aria-hidden="true"></a>}</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="what-is-a-segmentation-fault-score-539500-in-2016" class="level3">
<h3>55: What is a segmentation fault? (score <a href="https://stackoverflow.com/q/2346806.html">539500</a> in 2016)</h3>
<section id="question-52" class="level4">
<h4>Question</h4>
<p>What is a segmentation fault? Is it different in C and C++? How are segmentation faults and dangling pointers related?</p>
</section>
<section id="answer-accepted-score-610" class="level4">
<h4>Answer accepted (score 610)</h4>
<p>Segmentation fault is a specific kind of error caused by accessing memory that “does not belong to you.” It’s a helper mechanism that keeps you from corrupting the memory and introducing hard-to-debug memory bugs. Whenever you get a segfault you know you are doing something wrong with memory – accessing variable that has already been freed, writing to a read-only portion of the memory, etc. Segmentation fault is essentially the same in most languages that let you mess with the memory management, there is no principial difference between segfaults in C and C++.</p>
<p>There are many ways to get a segfault, at least in the lower-level languages such as C(++). A common way to get a segfault is to dereference a null pointer:</p>
<div class="sourceCode" id="cb353"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb353-1"><a href="#cb353-1" aria-hidden="true"></a><span class="dt">int</span> *p = NULL;</span>
<span id="cb353-2"><a href="#cb353-2" aria-hidden="true"></a>*p = <span class="dv">1</span>;</span></code></pre></div>
<p>Another segfault happens when you try to write to a portion of memory that was marked as read-only:</p>
<div class="sourceCode" id="cb354"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb354-1"><a href="#cb354-1" aria-hidden="true"></a><span class="dt">char</span> *str = <span class="st">&quot;Foo&quot;</span>; <span class="co">// Compiler marks the constant string as read-only</span></span>
<span id="cb354-2"><a href="#cb354-2" aria-hidden="true"></a>*str = <span class="ch">&#39;b&#39;</span>; <span class="co">// Which means this is illegal and results in a segfault</span></span></code></pre></div>
<p>Dangling pointer points to a thing that does not exist any more, like here:</p>
<div class="sourceCode" id="cb355"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb355-1"><a href="#cb355-1" aria-hidden="true"></a><span class="dt">char</span> *p = NULL;</span>
<span id="cb355-2"><a href="#cb355-2" aria-hidden="true"></a>{</span>
<span id="cb355-3"><a href="#cb355-3" aria-hidden="true"></a>    <span class="dt">char</span> c;</span>
<span id="cb355-4"><a href="#cb355-4" aria-hidden="true"></a>    p = &amp;c;</span>
<span id="cb355-5"><a href="#cb355-5" aria-hidden="true"></a>}</span>
<span id="cb355-6"><a href="#cb355-6" aria-hidden="true"></a><span class="co">// Now p is dangling</span></span></code></pre></div>
<p>The pointer <code>p</code> dangles because it points to character variable <code>c</code> that ceased to exist after the block ended. And when you try to dereference dangling pointer (like <code>*p='A'</code>), you would probably get a segfault.</p>
</section>
<section id="answer-2-score-106" class="level4">
<h4>Answer 2 (score 106)</h4>
<p>It would be worth noting that segmentation fault isn’t caused by directly accessing another process memory (this is what I’m hearing sometimes), as it is simply not possible. With virtual memory every process has its own virtual address space and there is no way to access another one using any value of pointer. Exception to this can be shared libraries which are same physical address space mapped to (possibly) different virtual addresses and kernel memory which is even mapped in the same way in every process (to avoid TLB flushing on syscall, I think). And things like shmat ;) - these are what I count as ‘indirect’ access. One can, however, check that they are usually located long way from process code and we are usually able to access them (this is why they are there, nevertheless accessing them in a improper way will produce segmentation fault).</p>
<p>Still, segmentation fault can occur in case of accessing our own (process) memory in improper way (for instance trying to write to non-writable space). But the most common reason for it is the access to the part of the virtual address space that is <em>not mapped</em> to physical one at all.</p>
<p>And all of this with respect to virtual memory systems.</p>
</section>
<section id="answer-3-score-33-1" class="level4">
<h4>Answer 3 (score 33)</h4>
<p>A segmentation fault is caused by a request for a page that the process does not have listed in its descriptor table, or an invalid request for a page that it does have listed (e.g. a write request on a read-only page).</p>
<p>A dangling pointer is a pointer that may or may not point to a valid page, but does point to an “unexpected” segment of memory.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="what-is-an-unsigned-char-score-539232-in-2016" class="level3">
<h3>56: What is an unsigned char? (score <a href="https://stackoverflow.com/q/75191.html">539232</a> in 2016)</h3>
<section id="question-53" class="level4">
<h4>Question</h4>
<p>In C/C++, what an <code>unsigned char</code> is used for? How is it different from a regular <code>char</code>?</p>
</section>
<section id="answer-accepted-score-523" class="level4">
<h4>Answer accepted (score 523)</h4>
<p>In C++, there are three <em>distinct</em> character types:</p>
<ul>
<li>
<code>char</code>
</li>
<li>
<code>signed char</code>
</li>
<li>
<code>unsigned char</code>
</li>
</ul>
<p>If you are using character types for <em>text</em>, use the unqualified <code>char</code>:</p>
<ul>
<li>
it is the type of character literals like <code>'a'</code> or <code>'0'</code>.
</li>
<li>
it is the type that makes up C strings like <code>"abcde"</code>
</li>
</ul>
<p>It also works out as a number value, but it is unspecified whether that value is treated as signed or unsigned. Beware character comparisons through inequalities - although if you limit yourself to ASCII (0-127) you’re just about safe.</p>
<p>If you are using character types as <em>numbers</em>, use:</p>
<ul>
<li>
<code>signed char</code>, which gives you <em>at least</em> the -127 to 127 range. (-128 to 127 is common)
</li>
<li>
<code>unsigned char</code>, which gives you <em>at least</em> the 0 to 255 range.
</li>
</ul>
<p>“At least”, because the C++ standard only gives the minimum range of values that each numeric type is required to cover. <code>sizeof (char)</code> is required to be 1 (i.e. one byte), but a byte could in theory be for example 32 bits. <strong><code>sizeof</code> would still be report its size as <code>1</code></strong> - meaning that you <em>could</em> have <code>sizeof (char) == sizeof (long) == 1</code>.</p>
</section>
<section id="answer-2-score-84" class="level4">
<h4>Answer 2 (score 84)</h4>
<p>This is implementation dependent, as the C standard does NOT define the signed-ness of <code>char</code>. Depending on the platform, char may be <code>signed</code> or <code>unsigned</code>, so you need to explicitly ask for <code>signed char</code> or <code>unsigned char</code> if your implementation depends on it. Just use <code>char</code> if you intend to represent characters from strings, as this will match what your platform puts in the string.</p>
<p>The difference between <code>signed char</code> and <code>unsigned char</code> is as you’d expect. On most platforms, <code>signed char</code> will be an 8-bit two’s complement number ranging from <code>-128</code> to <code>127</code>, and <code>unsigned char</code> will be an 8-bit unsigned integer (<code>0</code> to <code>255</code>). Note the standard does NOT require that <code>char</code> types have 8 bits, only that <code>sizeof(char)</code> return <code>1</code>. You can get at the number of bits in a char with <code>CHAR_BIT</code> in <code>limits.h</code>. There are few if any platforms today where this will be something other than <code>8</code>, though.</p>
<p>There is a nice summary of this issue <a href="http://www.arm.linux.org.uk/docs/faqs/signedchar.php" rel="noreferrer">here</a>.</p>
<p>As others have mentioned since I posted this, you’re better off using <code>int8_t</code> and <code>uint8_t</code> if you really want to represent small integers.</p>
</section>
<section id="answer-3-score-34" class="level4">
<h4>Answer 3 (score 34)</h4>
<p>Because i feel it’s really called for, i just want to state some rules of C and C++ (they are the same in this regard). First, <em>all bits</em> of <code>unsigned char</code> participate in determining the value if any unsigned char object. Second, <code>unsigned char</code> is explicitly stated unsigned.</p>
<p>Now, i had a discussion with someone about what happens when you convert the value <code>-1</code> of type int to <code>unsigned char</code>. He refused the idea that the resulting <code>unsigned char</code> has all its bits set to 1, because he was worried about sign representation. But he don’t have to. It’s immediately following out of this rule that the conversion does what is intended:</p>
<blockquote>
<p>
If the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type. (<code>6.3.1.3p2</code> in a C99 draft)
</p>
</blockquote>
<p>That’s a mathematical description. C++ describes it in terms of modulo calculus, which yields to the same rule. Anyway, what is <em>not</em> guaranteed is that all bits in the integer <code>-1</code> are one before the conversion. So, what do we have so we can claim that the resulting <code>unsigned char</code> has all its <code>CHAR_BIT</code> bits turned to 1?</p>
<ol>
<li>
All bits participate in determining its value - that is, no padding bits occur in the object.
</li>
<li>
Adding only one time <code>UCHAR_MAX+1</code> to <code>-1</code> will yield a value in range, namely <code>UCHAR_MAX</code>
</li>
</ol>
<p>That’s enough, actually! So whenever you want to have an <code>unsigned char</code> having all its bits one, you do</p>
<div class="sourceCode" id="cb356"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb356-1"><a href="#cb356-1" aria-hidden="true"></a><span class="dt">unsigned</span> <span class="dt">char</span> c = (<span class="dt">unsigned</span> <span class="dt">char</span>)-<span class="dv">1</span>;</span></code></pre></div>
<p>It also follows that a conversion is <em>not</em> just truncating higher order bits. The fortunate event for <em>two’s complement</em> is that it is just a truncation there, but the same isn’t necessarily true for other sign representations.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="what-is-the-difference-between-include-and-include-filename-score-537618-in-2016" class="level3">
<h3>57: What is the difference between #include <filename> and #include “filename”? (score <a href="https://stackoverflow.com/q/21593.html">537618</a> in 2016)</h3>
<section id="question-54" class="level4">
<h4>Question</h4>
<p>In the C and C++ programming languages, what is the difference between using angle brackets and using quotes in an <code>include</code> statement, as follows?</p>
<ol>
<li>
<code>#include &amp;lt;filename&amp;gt;</code>
</li>
<li>
<code>#include "filename"</code>
</li>
</ol>
</section>
<section id="answer-2-score-1283" class="level4">
<h4>Answer 2 (score 1283)</h4>
<p>In practice, the difference is in the location where the preprocessor searches for the included file.</p>
<p>For <code>#include &amp;lt;filename&amp;gt;</code> the preprocessor searches in an implementation dependent manner, normally in search directories pre-designated by the compiler/IDE. This method is normally used to include standard library header files.</p>
<p>For <code>#include "filename"</code> the preprocessor searches first in the same directory as the file containing the directive, and then follows the search path used for the <code>#include &amp;lt;filename&amp;gt;</code> form. This method is normally used to include programmer-defined header files.</p>
<p>A more complete description is available in the GCC <a href="https://gcc.gnu.org/onlinedocs/cpp/Search-Path.html" rel="noreferrer">documentation on search paths</a>.</p>
</section>
<section id="answer-3-score-674" class="level4">
<h4>Answer 3 (score 674)</h4>
<p>The only way to know is to read your implementation’s documentation.</p>
<p>In <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf
#page=182" rel="noreferrer">the C standard</a>, section 6.10.2, paragraphs 2 to 4 state:</p>
<blockquote>
<ul>
<li>
<p>
A preprocessing directive of the form
</p>
<div class="sourceCode" id="cb357"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb357-1"><a href="#cb357-1" aria-hidden="true"></a></span>
<span id="cb357-2"><a href="#cb357-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;h-char-sequence&gt;</span><span class="pp"> </span><span class="er">new-line</span></span></code></pre></div>
searches a sequence of implementation-defined places for a <strong>header</strong> identified uniquely by the specified sequence between the <code>&amp;lt;</code> and <code>&amp;gt;</code> delimiters, and causes the replacement of that directive by the entire contents of the <strong>header</strong>. How the places are specified or the header identified is implementation-defined.
</li>
<li>
<p>
A preprocessing directive of the form
</p>
<div class="sourceCode" id="cb358"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb358-1"><a href="#cb358-1" aria-hidden="true"></a></span>
<span id="cb358-2"><a href="#cb358-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;q-char-sequence&quot;</span><span class="pp"> </span><span class="er">new-line</span></span></code></pre></div>
<p>causes the replacement of that directive by the entire contents of the <strong>source file</strong> identified by the specified sequence between the <code>"</code> delimiters. The named <strong>source file</strong> is searched for in an implementation-defined manner. If this search is not supported, or if the search fails, the directive is reprocessed as if it read</p>
<div class="sourceCode" id="cb359"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb359-1"><a href="#cb359-1" aria-hidden="true"></a></span>
<span id="cb359-2"><a href="#cb359-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;h-char-sequence&gt;</span><span class="pp"> </span><span class="er">new-line</span></span></code></pre></div>
<p>
with the identical contained sequence (including <code>&amp;gt;</code> characters, if any) from the original directive.
</p>
</li>
<li>
<p>
A preprocessing directive of the form
</p>
<div class="sourceCode" id="cb360"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb360-1"><a href="#cb360-1" aria-hidden="true"></a></span>
<span id="cb360-2"><a href="#cb360-2" aria-hidden="true"></a><span class="pp">#include pp-tokens new-line</span></span></code></pre></div>
(that does not match one of the two previous forms) is permitted. The preprocessing tokens after <code>include</code> in the directive are processed just as in normal text. (Each identifier currently defined as a macro name is replaced by its replacement list of preprocessing tokens.) The directive resulting after all replacements shall match one of the two previous forms. The method by which a sequence of preprocessing tokens between a <code>&amp;lt;</code> and a <code>&amp;gt;</code> preprocessing token pair or a pair of <code>"</code> characters is combined into a single header name preprocessing token is implementation-defined.
</li>
</ul>
<h5>
Definitions:
</h3>
<ul>
<li>
<p>
h-char: any member of the source character set except the new-line character and <code>&amp;gt;</code>
</p>
</li>
<li>
<p>
q-char: any member of the source character set except the new-line character and <code>"</code>
</p>
</li>
</ul>
</blockquote>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="what-is-a-smart-pointer-and-when-should-i-use-one-score-532699-in-2015" class="level3">
<h3>58: What is a smart pointer and when should I use one? (score <a href="https://stackoverflow.com/q/106508.html">532699</a> in 2015)</h3>
<section id="question-55" class="level4">
<h4>Question</h4>
<p>What is a smart pointer and when should I use one?</p>
</section>
<section id="answer-accepted-score-1827" class="level4">
<h4>Answer accepted (score 1827)</h4>
<p><strong>UPDATE</strong></p>
<p>This answer is rather old, and so describes what was ‘good’ at the time, which was smart pointers provided by the Boost library. Since C++11, the standard library has provided sufficient smart pointers types, and so you should favour the use of <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr" rel="noreferrer"><code>std::unique_ptr</code></a>, <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr" rel="noreferrer"><code>std::shared_ptr</code></a> and <a href="http://en.cppreference.com/w/cpp/memory/weak_ptr" rel="noreferrer"><code>std::weak_ptr</code></a>.</p>
<p>
There was also <a href="http://en.cppreference.com/w/cpp/memory/auto_ptr" rel="noreferrer"><code>std::auto_ptr</code></a>. It was very much like a scoped pointer, except that it also had the “special” dangerous ability to be copied — which also unexpectedly transfers ownership.<br> <strong>It was deprecated in C++11 and removed in C++17</strong>, so you shouldn’t use it.
</p>
<div class="sourceCode" id="cb361"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb361-1"><a href="#cb361-1" aria-hidden="true"></a><span class="bu">std::</span>auto_ptr&lt;MyObject&gt; p1 (<span class="kw">new</span> MyObject());</span>
<span id="cb361-2"><a href="#cb361-2" aria-hidden="true"></a><span class="bu">std::</span>auto_ptr&lt;MyObject&gt; p2 = p1; <span class="co">// Copy and transfer ownership. </span></span>
<span id="cb361-3"><a href="#cb361-3" aria-hidden="true"></a>                                 <span class="co">// p1 gets set to empty!</span></span>
<span id="cb361-4"><a href="#cb361-4" aria-hidden="true"></a>p2-&gt;DoSomething(); <span class="co">// Works.</span></span>
<span id="cb361-5"><a href="#cb361-5" aria-hidden="true"></a>p1-&gt;DoSomething(); <span class="co">// Oh oh. Hopefully raises some NULL pointer exception.</span></span></code></pre></div>
<hr>
<p><strong>OLD ANSWER</strong></p>
<p>A smart pointer is a class that wraps a ‘raw’ (or ‘bare’) C++ pointer, to manage the lifetime of the object being pointed to. There is no single smart pointer type, but all of them try to abstract a raw pointer in a practical way.</p>
<p>Smart pointers should be preferred over raw pointers. If you feel you need to use pointers (first consider if you <em>really</em> do), you would normally want to use a smart pointer as this can alleviate many of the problems with raw pointers, mainly forgetting to delete the object and leaking memory.</p>
<p>With raw pointers, the programmer has to explicitly destroy the object when it is no longer useful.</p>
<div class="sourceCode" id="cb362"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb362-1"><a href="#cb362-1" aria-hidden="true"></a><span class="co">// Need to create the object to achieve some goal</span></span>
<span id="cb362-2"><a href="#cb362-2" aria-hidden="true"></a>MyObject* ptr = <span class="kw">new</span> MyObject(); </span>
<span id="cb362-3"><a href="#cb362-3" aria-hidden="true"></a>ptr-&gt;DoSomething(); <span class="co">// Use the object in some way</span></span>
<span id="cb362-4"><a href="#cb362-4" aria-hidden="true"></a><span class="kw">delete</span> ptr; <span class="co">// Destroy the object. Done with it.</span></span>
<span id="cb362-5"><a href="#cb362-5" aria-hidden="true"></a><span class="co">// Wait, what if DoSomething() raises an exception...?</span></span></code></pre></div>
<p>A smart pointer by comparison defines a policy as to when the object is destroyed. You still have to create the object, but you no longer have to worry about destroying it.</p>
<div class="sourceCode" id="cb363"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb363-1"><a href="#cb363-1" aria-hidden="true"></a>SomeSmartPtr&lt;MyObject&gt; ptr(<span class="kw">new</span> MyObject());</span>
<span id="cb363-2"><a href="#cb363-2" aria-hidden="true"></a>ptr-&gt;DoSomething(); <span class="co">// Use the object in some way.</span></span>
<span id="cb363-3"><a href="#cb363-3" aria-hidden="true"></a></span>
<span id="cb363-4"><a href="#cb363-4" aria-hidden="true"></a><span class="co">// Destruction of the object happens, depending </span></span>
<span id="cb363-5"><a href="#cb363-5" aria-hidden="true"></a><span class="co">// on the policy the smart pointer class uses.</span></span>
<span id="cb363-6"><a href="#cb363-6" aria-hidden="true"></a></span>
<span id="cb363-7"><a href="#cb363-7" aria-hidden="true"></a><span class="co">// Destruction would happen even if DoSomething() </span></span>
<span id="cb363-8"><a href="#cb363-8" aria-hidden="true"></a><span class="co">// raises an exception</span></span></code></pre></div>
<p>The simplest policy in use involves the scope of the smart pointer wrapper object, such as implemented by <a href="http://www.boost.org/doc/libs/release/libs/smart_ptr/scoped_ptr.htm" rel="noreferrer"><code>boost::scoped_ptr</code></a> or <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr" rel="noreferrer"><code>std::unique_ptr</code></a>.</p>
<div class="sourceCode" id="cb364"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb364-1"><a href="#cb364-1" aria-hidden="true"></a><span class="dt">void</span> f()</span>
<span id="cb364-2"><a href="#cb364-2" aria-hidden="true"></a>{</span>
<span id="cb364-3"><a href="#cb364-3" aria-hidden="true"></a>    {</span>
<span id="cb364-4"><a href="#cb364-4" aria-hidden="true"></a>       <span class="bu">std::</span>unique_ptr&lt;MyObject&gt; ptr(<span class="kw">new</span> MyObject());</span>
<span id="cb364-5"><a href="#cb364-5" aria-hidden="true"></a>       ptr-&gt;DoSomethingUseful();</span>
<span id="cb364-6"><a href="#cb364-6" aria-hidden="true"></a>    } <span class="co">// ptr goes out of scope -- </span></span>
<span id="cb364-7"><a href="#cb364-7" aria-hidden="true"></a>      <span class="co">// the MyObject is automatically destroyed.</span></span>
<span id="cb364-8"><a href="#cb364-8" aria-hidden="true"></a></span>
<span id="cb364-9"><a href="#cb364-9" aria-hidden="true"></a>    <span class="co">// ptr-&gt;Oops(); // Compile error: &quot;ptr&quot; not defined</span></span>
<span id="cb364-10"><a href="#cb364-10" aria-hidden="true"></a>                    <span class="co">// since it is no longer in scope.</span></span>
<span id="cb364-11"><a href="#cb364-11" aria-hidden="true"></a>}</span></code></pre></div>
<p>Note that <code>std::unique_ptr</code> instances cannot be copied. This prevents the pointer from being deleted multiple times (incorrectly). You can, however, pass references to it around to other functions you call.</p>
<p><code>std::unique_ptr</code>s are useful when you want to tie the lifetime of the object to a particular block of code, or if you embedded it as member data inside another object, the lifetime of that other object. The object exists until the containing block of code is exited, or until the containing object is itself destroyed.</p>
<p>A more complex smart pointer policy involves reference counting the pointer. This does allow the pointer to be copied. When the last “reference” to the object is destroyed, the object is deleted. This policy is implemented by <a href="http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm" rel="noreferrer"><code>boost::shared_ptr</code></a> and <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr" rel="noreferrer"><code>std::shared_ptr</code></a>.</p>
<div class="sourceCode" id="cb365"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb365-1"><a href="#cb365-1" aria-hidden="true"></a><span class="dt">void</span> f()</span>
<span id="cb365-2"><a href="#cb365-2" aria-hidden="true"></a>{</span>
<span id="cb365-3"><a href="#cb365-3" aria-hidden="true"></a>    <span class="kw">typedef</span> <span class="bu">std::</span>shared_ptr&lt;MyObject&gt; MyObjectPtr; <span class="co">// nice short alias</span></span>
<span id="cb365-4"><a href="#cb365-4" aria-hidden="true"></a>    MyObjectPtr p1; <span class="co">// Empty</span></span>
<span id="cb365-5"><a href="#cb365-5" aria-hidden="true"></a></span>
<span id="cb365-6"><a href="#cb365-6" aria-hidden="true"></a>    {</span>
<span id="cb365-7"><a href="#cb365-7" aria-hidden="true"></a>        MyObjectPtr p2(<span class="kw">new</span> MyObject());</span>
<span id="cb365-8"><a href="#cb365-8" aria-hidden="true"></a>        <span class="co">// There is now one &quot;reference&quot; to the created object</span></span>
<span id="cb365-9"><a href="#cb365-9" aria-hidden="true"></a>        p1 = p2; <span class="co">// Copy the pointer.</span></span>
<span id="cb365-10"><a href="#cb365-10" aria-hidden="true"></a>        <span class="co">// There are now two references to the object.</span></span>
<span id="cb365-11"><a href="#cb365-11" aria-hidden="true"></a>    } <span class="co">// p2 is destroyed, leaving one reference to the object.</span></span>
<span id="cb365-12"><a href="#cb365-12" aria-hidden="true"></a>} <span class="co">// p1 is destroyed, leaving a reference count of zero. </span></span>
<span id="cb365-13"><a href="#cb365-13" aria-hidden="true"></a>  <span class="co">// The object is deleted.</span></span></code></pre></div>
<p>Reference counted pointers are very useful when the lifetime of your object is much more complicated, and is not tied directly to a particular section of code or to another object.</p>
<p>There is one drawback to reference counted pointers — the possibility of creating a dangling reference:</p>
<div class="sourceCode" id="cb366"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb366-1"><a href="#cb366-1" aria-hidden="true"></a><span class="co">// Create the smart pointer on the heap</span></span>
<span id="cb366-2"><a href="#cb366-2" aria-hidden="true"></a>MyObjectPtr* pp = <span class="kw">new</span> MyObjectPtr(<span class="kw">new</span> MyObject())</span>
<span id="cb366-3"><a href="#cb366-3" aria-hidden="true"></a><span class="co">// Hmm, we forgot to destroy the smart pointer,</span></span>
<span id="cb366-4"><a href="#cb366-4" aria-hidden="true"></a><span class="co">// because of that, the object is never destroyed!</span></span></code></pre></div>
<p>Another possibility is creating circular references:</p>
<div class="sourceCode" id="cb367"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb367-1"><a href="#cb367-1" aria-hidden="true"></a><span class="kw">struct</span> Owner {</span>
<span id="cb367-2"><a href="#cb367-2" aria-hidden="true"></a>   <span class="bu">std::</span>shared_ptr&lt;Owner&gt; other;</span>
<span id="cb367-3"><a href="#cb367-3" aria-hidden="true"></a>};</span>
<span id="cb367-4"><a href="#cb367-4" aria-hidden="true"></a></span>
<span id="cb367-5"><a href="#cb367-5" aria-hidden="true"></a><span class="bu">std::</span>shared_ptr&lt;Owner&gt; p1 (<span class="kw">new</span> Owner());</span>
<span id="cb367-6"><a href="#cb367-6" aria-hidden="true"></a><span class="bu">std::</span>shared_ptr&lt;Owner&gt; p2 (<span class="kw">new</span> Owner());</span>
<span id="cb367-7"><a href="#cb367-7" aria-hidden="true"></a>p1-&gt;other = p2; <span class="co">// p1 references p2</span></span>
<span id="cb367-8"><a href="#cb367-8" aria-hidden="true"></a>p2-&gt;other = p1; <span class="co">// p2 references p1</span></span>
<span id="cb367-9"><a href="#cb367-9" aria-hidden="true"></a></span>
<span id="cb367-10"><a href="#cb367-10" aria-hidden="true"></a><span class="co">// Oops, the reference count of of p1 and p2 never goes to zero!</span></span>
<span id="cb367-11"><a href="#cb367-11" aria-hidden="true"></a><span class="co">// The objects are never destroyed!</span></span></code></pre></div>
<p>To work around this problem, both Boost and C++11 have defined a <code>weak_ptr</code> to define a weak (uncounted) reference to a <code>shared_ptr</code>.</p>
</section>
<section id="answer-2-score-264" class="level4">
<h4>Answer 2 (score 264)</h4>
<p>Here’s a simple answer for these days of modern C++:</p>
<ul>
<li>
<strong>What is a smart pointer?</strong> <br> It’s a type whose values can be used like pointers, but which provides the additional feature of automatic memory management: When a smart pointer is no longer in use, the memory it points to is deallocated (see also <a href="http://en.wikipedia.org/wiki/Smart_pointer" rel="noreferrer">the more detailed definition on Wikipedia</a>).
</li>
<li>
<strong>When should I use one?</strong> <br> In code which involves tracking the ownership of a piece of memory, allocating or de-allocating; the smart pointer often saves you the need to do these things explicitly.
</li>
<li>
<p><strong>But which smart pointer should I use in which of those cases?</strong></p>
<ul>
<li>
Use <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr" rel="noreferrer"><code>std::unique_ptr</code></a> when you don’t intend to hold multiple references to the same object. For example, use it for a pointer to memory which gets allocated on entering some scope and de-allocated on exiting the scope.
</li>
<li>
Use <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr" rel="noreferrer"><code>std::shared_ptr</code></a> when you do want to refer to your object from multiple places - and do not want your object to be de-allocated until all these references are themselves gone.
</li>
<li>
Use <a href="http://en.cppreference.com/w/cpp/memory/weak_ptr" rel="noreferrer"><code>std::weak_ptr</code></a> when you do want to refer to your object from multiple places - for those references for which it’s ok to ignore and deallocate (so they’ll just note the object is gone when you try to dereference).
</li>
<li>
Don’t use the <code>boost::</code> smart pointers or <code>std::auto_ptr</code> except in special cases which you can read up on if you must.
</li>
</ul>
</li>
<li>
<strong>Hey, I didn’t ask which one to use!</strong> <br> Ah, but you really wanted to, admit it.
</li>
<li>
<strong>So when should I use regular pointers then?</strong> <br> Mostly in code that is oblivious to memory ownership. This would typically be in functions which get a pointer from someplace else and do not allocate nor de-allocate, and do not store a copy of the pointer which outlasts their execution.
</li>
</ul>
</section>
<section id="answer-3-score-108-1" class="level4">
<h4>Answer 3 (score 108)</h4>
<p><a href="http://en.wikipedia.org/wiki/Smart_pointer" rel="noreferrer">Smart pointer</a> is a pointer-like type with some additional functionality, e.g. automatic memory deallocation, reference counting etc.</p>
<p>Small intro is available on page <a href="http://ootips.org/yonat/4dev/smart-pointers.html" rel="noreferrer">Smart Pointers - What, Why, Which?</a>.</p>
<p>One of the simple smart-pointer type is <a href="http://en.cppreference.com/w/cpp/memory/auto_ptr" rel="noreferrer"><code>std::auto_ptr</code></a> (chapter 20.4.5 of C++ standard), which allows to deallocate memory automatically when it out of scope and which is more robust than simple pointer usage when exceptions are thrown, although less flexible.</p>
<p>Another convenient type is <a href="http://www.boost.org/doc/libs/1_36_0/libs/smart_ptr/shared_ptr.htm" rel="noreferrer"><code>boost::shared_ptr</code></a> which implements reference counting and automatically deallocates memory when no references to object remains. This helps avoiding memory leaks and is easy to use to implement <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization" rel="noreferrer">RAII</a>.</p>
<p>
Subject is covered in depth in book <a href="https://rads.stackoverflow.com/amzn/click/com/0201734842" rel="noreferrer" rel="nofollow noreferrer">“C++ Templates: The Complete Guide” by David Vandevoorde, Nicolai M. Josuttis</a>, chapter Chapter 20. Smart Pointers. Some topics covered:
</p>
<ul>
<li>
Protecting Against Exceptions
</li>
<li>
Holders, (note, <a href="http://en.cppreference.com/w/cpp/memory/auto_ptr" rel="noreferrer">std::auto_ptr</a> is implementation of such type of smart pointer)
</li>
<li>
<a href="http://en.wikipedia.org/wiki/Resource_acquisition_is_initialization" rel="noreferrer">Resource Acquisition Is Initialization</a> (This is frequently used for exception-safe resource management in C++)
</li>
<li>
Holder Limitations
</li>
<li>
<a href="http://en.wikipedia.org/wiki/Reference_counting" rel="noreferrer">Reference Counting</a>
</li>
<li>
Concurrent Counter Access
</li>
<li>
Destruction and Deallocation
</li>
</ul>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-do-i-tokenize-a-string-in-c-score-529167-in-2013" class="level3">
<h3>59: How do I tokenize a string in C++? (score <a href="https://stackoverflow.com/q/53849.html">529167</a> in 2013)</h3>
<section id="question-56" class="level4">
<h4>Question</h4>
<p>Java has a convenient split method:</p>
<div class="sourceCode" id="cb368"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb368-1"><a href="#cb368-1" aria-hidden="true"></a>String str = <span class="st">&quot;The quick brown fox&quot;</span>;</span>
<span id="cb368-2"><a href="#cb368-2" aria-hidden="true"></a>String[] results = str.split(<span class="st">&quot; &quot;</span>);</span></code></pre></div>
<p>Is there an easy way to do this in C++?</p>
</section>
<section id="answer-accepted-score-139" class="level4">
<h4>Answer accepted (score 139)</h4>
<p>Your simple case can easily be built using the <a href="http://en.cppreference.com/w/cpp/string/basic_string/find" rel="noreferrer"><code>std::string::find</code></a> method. However, take a look at <a href="https://www.boost.org/doc/libs/1_70_0/libs/tokenizer/doc/tokenizer.htm" rel="noreferrer">Boost.Tokenizer</a>. It’s great. Boost generally has some very cool string tools.</p>
</section>
<section id="answer-2-score-187" class="level4">
<h4>Answer 2 (score 187)</h4>
<p>The <a href="http://www.boost.org/doc/libs/1_36_0/libs/tokenizer/index.html" rel="noreferrer">Boost tokenizer</a> class can make this sort of thing quite simple:</p>
<div class="sourceCode" id="cb369"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb369-1"><a href="#cb369-1" aria-hidden="true"></a></span>
<span id="cb369-2"><a href="#cb369-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb369-3"><a href="#cb369-3" aria-hidden="true"></a></span>
<span id="cb369-4"><a href="#cb369-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb369-5"><a href="#cb369-5" aria-hidden="true"></a></span>
<span id="cb369-6"><a href="#cb369-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;boost/foreach.hpp&gt;</span></span>
<span id="cb369-7"><a href="#cb369-7" aria-hidden="true"></a></span>
<span id="cb369-8"><a href="#cb369-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;boost/tokenizer.hpp&gt;</span></span>
<span id="cb369-9"><a href="#cb369-9" aria-hidden="true"></a></span>
<span id="cb369-10"><a href="#cb369-10" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb369-11"><a href="#cb369-11" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> boost;</span>
<span id="cb369-12"><a href="#cb369-12" aria-hidden="true"></a></span>
<span id="cb369-13"><a href="#cb369-13" aria-hidden="true"></a><span class="dt">int</span> main(<span class="dt">int</span>, <span class="dt">char</span>**)</span>
<span id="cb369-14"><a href="#cb369-14" aria-hidden="true"></a>{</span>
<span id="cb369-15"><a href="#cb369-15" aria-hidden="true"></a>    string text = <span class="st">&quot;token, test   string&quot;</span>;</span>
<span id="cb369-16"><a href="#cb369-16" aria-hidden="true"></a></span>
<span id="cb369-17"><a href="#cb369-17" aria-hidden="true"></a>    char_separator&lt;<span class="dt">char</span>&gt; sep(<span class="st">&quot;, &quot;</span>);</span>
<span id="cb369-18"><a href="#cb369-18" aria-hidden="true"></a>    tokenizer&lt; char_separator&lt;<span class="dt">char</span>&gt; &gt; tokens(text, sep);</span>
<span id="cb369-19"><a href="#cb369-19" aria-hidden="true"></a>    <span class="ex">BOOST_</span>FOREACH (<span class="at">const</span> string&amp; t, tokens) {</span>
<span id="cb369-20"><a href="#cb369-20" aria-hidden="true"></a>        cout &lt;&lt; t &lt;&lt; <span class="st">&quot;.&quot;</span> &lt;&lt; endl;</span>
<span id="cb369-21"><a href="#cb369-21" aria-hidden="true"></a>    }</span>
<span id="cb369-22"><a href="#cb369-22" aria-hidden="true"></a>}</span></code></pre></div>
<p>Updated for C++11:</p>
<div class="sourceCode" id="cb370"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb370-1"><a href="#cb370-1" aria-hidden="true"></a></span>
<span id="cb370-2"><a href="#cb370-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb370-3"><a href="#cb370-3" aria-hidden="true"></a></span>
<span id="cb370-4"><a href="#cb370-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb370-5"><a href="#cb370-5" aria-hidden="true"></a></span>
<span id="cb370-6"><a href="#cb370-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;boost/tokenizer.hpp&gt;</span></span>
<span id="cb370-7"><a href="#cb370-7" aria-hidden="true"></a></span>
<span id="cb370-8"><a href="#cb370-8" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb370-9"><a href="#cb370-9" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> boost;</span>
<span id="cb370-10"><a href="#cb370-10" aria-hidden="true"></a></span>
<span id="cb370-11"><a href="#cb370-11" aria-hidden="true"></a><span class="dt">int</span> main(<span class="dt">int</span>, <span class="dt">char</span>**)</span>
<span id="cb370-12"><a href="#cb370-12" aria-hidden="true"></a>{</span>
<span id="cb370-13"><a href="#cb370-13" aria-hidden="true"></a>    string text = <span class="st">&quot;token, test   string&quot;</span>;</span>
<span id="cb370-14"><a href="#cb370-14" aria-hidden="true"></a></span>
<span id="cb370-15"><a href="#cb370-15" aria-hidden="true"></a>    char_separator&lt;<span class="dt">char</span>&gt; sep(<span class="st">&quot;, &quot;</span>);</span>
<span id="cb370-16"><a href="#cb370-16" aria-hidden="true"></a>    tokenizer&lt;char_separator&lt;<span class="dt">char</span>&gt;&gt; tokens(text, sep);</span>
<span id="cb370-17"><a href="#cb370-17" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="at">const</span> <span class="kw">auto</span>&amp; t : tokens) {</span>
<span id="cb370-18"><a href="#cb370-18" aria-hidden="true"></a>        cout &lt;&lt; t &lt;&lt; <span class="st">&quot;.&quot;</span> &lt;&lt; endl;</span>
<span id="cb370-19"><a href="#cb370-19" aria-hidden="true"></a>    }</span>
<span id="cb370-20"><a href="#cb370-20" aria-hidden="true"></a>}</span></code></pre></div>
</section>
<section id="answer-3-score-168" class="level4">
<h4>Answer 3 (score 168)</h4>
<p>Here’s a real simple one:</p>
<div class="sourceCode" id="cb371"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb371-1"><a href="#cb371-1" aria-hidden="true"></a></span>
<span id="cb371-2"><a href="#cb371-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb371-3"><a href="#cb371-3" aria-hidden="true"></a></span>
<span id="cb371-4"><a href="#cb371-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb371-5"><a href="#cb371-5" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb371-6"><a href="#cb371-6" aria-hidden="true"></a></span>
<span id="cb371-7"><a href="#cb371-7" aria-hidden="true"></a>vector&lt;string&gt; split(<span class="at">const</span> <span class="dt">char</span> *str, <span class="dt">char</span> c = <span class="ch">&#39; &#39;</span>)</span>
<span id="cb371-8"><a href="#cb371-8" aria-hidden="true"></a>{</span>
<span id="cb371-9"><a href="#cb371-9" aria-hidden="true"></a>    vector&lt;string&gt; result;</span>
<span id="cb371-10"><a href="#cb371-10" aria-hidden="true"></a></span>
<span id="cb371-11"><a href="#cb371-11" aria-hidden="true"></a>    <span class="cf">do</span></span>
<span id="cb371-12"><a href="#cb371-12" aria-hidden="true"></a>    {</span>
<span id="cb371-13"><a href="#cb371-13" aria-hidden="true"></a>        <span class="at">const</span> <span class="dt">char</span> *begin = str;</span>
<span id="cb371-14"><a href="#cb371-14" aria-hidden="true"></a></span>
<span id="cb371-15"><a href="#cb371-15" aria-hidden="true"></a>        <span class="cf">while</span>(*str != c &amp;&amp; *str)</span>
<span id="cb371-16"><a href="#cb371-16" aria-hidden="true"></a>            str++;</span>
<span id="cb371-17"><a href="#cb371-17" aria-hidden="true"></a></span>
<span id="cb371-18"><a href="#cb371-18" aria-hidden="true"></a>        result.push_back(string(begin, str));</span>
<span id="cb371-19"><a href="#cb371-19" aria-hidden="true"></a>    } <span class="cf">while</span> (<span class="dv">0</span> != *str++);</span>
<span id="cb371-20"><a href="#cb371-20" aria-hidden="true"></a></span>
<span id="cb371-21"><a href="#cb371-21" aria-hidden="true"></a>    <span class="cf">return</span> result;</span>
<span id="cb371-22"><a href="#cb371-22" aria-hidden="true"></a>}</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="what-does-dereferencing-a-pointer-mean-score-519585-in-2017" class="level3">
<h3>60: What does “dereferencing” a pointer mean? (score <a href="https://stackoverflow.com/q/4955198.html">519585</a> in 2017)</h3>
<section id="question-57" class="level4">
<h4>Question</h4>
<p>Please include an example with the explanation.</p>
</section>
<section id="answer-accepted-score-676" class="level4">
<h4>Answer accepted (score 676)</h4>
<h5>
Reviewing the basic terminology
</h2>
<p>It’s <em>usually</em> good enough - unless you’re programming assembly - to envisage a <strong><em>pointer</em></strong> containing a numeric memory address, with 1 referring to the second byte in the process’s memory, 2 the third, 3 the fourth and so on….</p>
<ul>
<li>
What happened to 0 and the first byte? Well, we’ll get to that later - see <em>null pointers</em> below.
</li>
<li>
For a more accurate definition of what pointers store, and how memory and addresses relate, see <em>“More about memory addresses, and why you probably don’t need to know”</em>.
</li>
</ul>
<p>When you want to access the data/value in the memory that the pointer points to - the contents of the address with that numerical index - then you <strong><em>dereference</em></strong> the pointer.</p>
<p>Different computer languages have different notations to tell the compiler or interpreter that you’re now interested in the pointed-to value - I focus below on C and C++.</p>
<h5>
A pointer scenario
</h2>
<p>Consider in C, given a pointer such as <code>p</code> below…</p>
<div class="sourceCode" id="cb372"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb372-1"><a href="#cb372-1" aria-hidden="true"></a><span class="at">const</span> <span class="dt">char</span>* p = <span class="st">&quot;abc&quot;</span>;</span></code></pre></div>
<p>…four bytes with the numerical values used to encode the letters ‘a’, ‘b’, ‘c’, and a 0 byte to denote the end of the textual data, are stored somewhere in memory and the numerical address of that data is stored in <code>p</code>.</p>
<p>For example, if the string literal happened to be at address 0x1000 and <code>p</code> a 32-bit pointer at 0x2000, the memory content would be:</p>
<div class="sourceCode" id="cb373"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb373-1"><a href="#cb373-1" aria-hidden="true"></a>Memory Address (hex)    Variable name    Contents</span>
<span id="cb373-2"><a href="#cb373-2" aria-hidden="true"></a><span class="dv">1000</span>                                     <span class="ch">&#39;a&#39;</span> == <span class="dv">97</span> (ASCII)</span>
<span id="cb373-3"><a href="#cb373-3" aria-hidden="true"></a><span class="dv">1001</span>                                     <span class="ch">&#39;b&#39;</span> == <span class="dv">98</span></span>
<span id="cb373-4"><a href="#cb373-4" aria-hidden="true"></a><span class="dv">1002</span>                                     <span class="ch">&#39;c&#39;</span> == <span class="dv">99</span></span>
<span id="cb373-5"><a href="#cb373-5" aria-hidden="true"></a><span class="dv">1003</span>                                     <span class="dv">0</span></span>
<span id="cb373-6"><a href="#cb373-6" aria-hidden="true"></a>...</span>
<span id="cb373-7"><a href="#cb373-7" aria-hidden="true"></a><span class="dv">2000</span>-<span class="dv">2003</span>               p                <span class="dv">1000</span> hex</span></code></pre></div>
<p>Note that there is no variable name/identifier for address 0x1000, but we can indirectly refer to the string literal using a pointer storing its address: <code>p</code>.</p>
<h5>
Dereferencing the pointer
</h2>
<p>To refer to the characters <code>p</code> points to, we dereference <code>p</code> using one of these notations (again, for C):</p>
<div class="sourceCode" id="cb374"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb374-1"><a href="#cb374-1" aria-hidden="true"></a><span class="ot">assert</span>(*p == <span class="ch">&#39;a&#39;</span>);  <span class="co">// The first character at address p will be &#39;a&#39;</span></span>
<span id="cb374-2"><a href="#cb374-2" aria-hidden="true"></a><span class="ot">assert</span>(p[<span class="dv">1</span>] == <span class="ch">&#39;b&#39;</span>); <span class="co">// p[1] actually dereferences a pointer created by adding</span></span>
<span id="cb374-3"><a href="#cb374-3" aria-hidden="true"></a>                     <span class="co">// p and 1 times the size of the things to which p points:</span></span>
<span id="cb374-4"><a href="#cb374-4" aria-hidden="true"></a>                     <span class="co">// In this case they&#39;re char which are 1 byte in C...</span></span>
<span id="cb374-5"><a href="#cb374-5" aria-hidden="true"></a><span class="ot">assert</span>(*(p + <span class="dv">1</span>) == <span class="ch">&#39;b&#39;</span>);  <span class="co">// Another notation for p[1]</span></span></code></pre></div>
<p>You can also move pointers through the pointed-to data, dereferencing them as you go:</p>
<div class="sourceCode" id="cb375"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb375-1"><a href="#cb375-1" aria-hidden="true"></a>++p;  <span class="co">// Increment p so it&#39;s now 0x1001</span></span>
<span id="cb375-2"><a href="#cb375-2" aria-hidden="true"></a><span class="ot">assert</span>(*p == <span class="ch">&#39;b&#39;</span>);  <span class="co">// p == 0x1001 which is where the &#39;b&#39; is...</span></span></code></pre></div>
<p>If you have some data that can be written to, then you can do things like this:</p>
<div class="sourceCode" id="cb376"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb376-1"><a href="#cb376-1" aria-hidden="true"></a><span class="dt">int</span> x = <span class="dv">2</span>;</span>
<span id="cb376-2"><a href="#cb376-2" aria-hidden="true"></a><span class="dt">int</span>* p_x = &amp;x;  <span class="co">// Put the address of the x variable into the pointer p_x</span></span>
<span id="cb376-3"><a href="#cb376-3" aria-hidden="true"></a>*p_x = <span class="dv">4</span>;       <span class="co">// Change the memory at the address in p_x to be 4</span></span>
<span id="cb376-4"><a href="#cb376-4" aria-hidden="true"></a><span class="ot">assert</span>(x == <span class="dv">4</span>); <span class="co">// Check x is now 4</span></span></code></pre></div>
<p>Above, you must have known at compile time that you would need a variable called <code>x</code>, and the code asks the compiler to arrange where it should be stored, ensuring the address will be available via <code>&amp;amp;x</code>.</p>
<h5>
Dereferencing and accessing a structure data member
</h2>
<p>In C, if you have a variable that is a pointer to a structure with data members, you can access those members using the <code>-&amp;gt;</code> dereferencing operator:</p>
<div class="sourceCode" id="cb377"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb377-1"><a href="#cb377-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> X { <span class="dt">int</span> <span class="va">i_</span>; <span class="dt">double</span> <span class="va">d_</span>; } X;</span>
<span id="cb377-2"><a href="#cb377-2" aria-hidden="true"></a>X x;</span>
<span id="cb377-3"><a href="#cb377-3" aria-hidden="true"></a>X* p = &amp;x;</span>
<span id="cb377-4"><a href="#cb377-4" aria-hidden="true"></a>p-&gt;<span class="va">d_</span> = <span class="fl">3.14159</span>;  <span class="co">// Dereference and access data member x.d_</span></span>
<span id="cb377-5"><a href="#cb377-5" aria-hidden="true"></a>(*p).<span class="va">d_</span> *= -<span class="dv">1</span>;    <span class="co">// Another equivalent notation for accessing x.d_</span></span></code></pre></div>
<h5>
Multi-byte data types
</h2>
<p>To use a pointer, a computer program also needs some insight into the type of data that is being pointed at - if that data type needs more than one byte to represent, then the pointer normally points to the lowest-numbered byte in the data.</p>
<p>So, looking at a slightly more complex example:</p>
<div class="sourceCode" id="cb378"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb378-1"><a href="#cb378-1" aria-hidden="true"></a><span class="dt">double</span> sizes[] = { <span class="fl">10.3</span>, <span class="fl">13.4</span>, <span class="fl">11.2</span>, <span class="fl">19.4</span> };</span>
<span id="cb378-2"><a href="#cb378-2" aria-hidden="true"></a><span class="dt">double</span>* p = sizes;</span>
<span id="cb378-3"><a href="#cb378-3" aria-hidden="true"></a><span class="ot">assert</span>(p[<span class="dv">0</span>] == <span class="fl">10.3</span>);  <span class="co">// Knows to look at all the bytes in the first double value</span></span>
<span id="cb378-4"><a href="#cb378-4" aria-hidden="true"></a><span class="ot">assert</span>(p[<span class="dv">1</span>] == <span class="fl">13.4</span>);  <span class="co">// Actually looks at bytes from address p + 1 * sizeof(double)</span></span>
<span id="cb378-5"><a href="#cb378-5" aria-hidden="true"></a>                       <span class="co">// (sizeof(double) is almost always eight bytes)</span></span>
<span id="cb378-6"><a href="#cb378-6" aria-hidden="true"></a><span class="ot">assert</span>(++p);           <span class="co">// Advance p by sizeof(double)</span></span>
<span id="cb378-7"><a href="#cb378-7" aria-hidden="true"></a><span class="ot">assert</span>(*p == <span class="fl">13.4</span>);    <span class="co">// The double at memory beginning at address p has value 13.4</span></span>
<span id="cb378-8"><a href="#cb378-8" aria-hidden="true"></a>*(p + <span class="dv">2</span>) = <span class="fl">29.8</span>;       <span class="co">// Change sizes[3] from 19.4 to 29.8</span></span>
<span id="cb378-9"><a href="#cb378-9" aria-hidden="true"></a>                       <span class="co">// Note: earlier ++p and + 2 here =&gt; sizes[3]</span></span></code></pre></div>
<h5>
Pointers to dynamically allocated memory
</h2>
<p>Sometimes you don’t know how much memory you’ll need until your program is running and sees what data is thrown at it… then you can dynamically allocate memory using <code>malloc</code>. It is common practice to store the address in a pointer…</p>
<div class="sourceCode" id="cb379"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb379-1"><a href="#cb379-1" aria-hidden="true"></a><span class="dt">int</span>* p = malloc(<span class="kw">sizeof</span>(<span class="dt">int</span>)); <span class="co">// Get some memory somewhere...</span></span>
<span id="cb379-2"><a href="#cb379-2" aria-hidden="true"></a>*p = <span class="dv">10</span>;            <span class="co">// Dereference the pointer to the memory, then write a value in</span></span>
<span id="cb379-3"><a href="#cb379-3" aria-hidden="true"></a>fn(*p);             <span class="co">// Call a function, passing it the value at address p</span></span>
<span id="cb379-4"><a href="#cb379-4" aria-hidden="true"></a>(*p) += <span class="dv">3</span>;          <span class="co">// Change the value, adding 3 to it</span></span>
<span id="cb379-5"><a href="#cb379-5" aria-hidden="true"></a>free(p);            <span class="co">// Release the memory back to the heap allocation library</span></span></code></pre></div>
<p>In C++, memory allocation is normally done with the <code>new</code> operator, and deallocation with <code>delete</code>:</p>
<div class="sourceCode" id="cb380"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb380-1"><a href="#cb380-1" aria-hidden="true"></a><span class="dt">int</span>* p = <span class="kw">new</span> <span class="dt">int</span>(<span class="dv">10</span>); <span class="co">// Memory for one int with initial value 10</span></span>
<span id="cb380-2"><a href="#cb380-2" aria-hidden="true"></a><span class="kw">delete</span> p;</span>
<span id="cb380-3"><a href="#cb380-3" aria-hidden="true"></a></span>
<span id="cb380-4"><a href="#cb380-4" aria-hidden="true"></a>p = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">10</span>];      <span class="co">// Memory for ten ints with unspecified initial value</span></span>
<span id="cb380-5"><a href="#cb380-5" aria-hidden="true"></a><span class="kw">delete</span>[] p;</span>
<span id="cb380-6"><a href="#cb380-6" aria-hidden="true"></a></span>
<span id="cb380-7"><a href="#cb380-7" aria-hidden="true"></a>p = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">10</span>]();    <span class="co">// Memory for ten ints that are value initialised (to 0)</span></span>
<span id="cb380-8"><a href="#cb380-8" aria-hidden="true"></a><span class="kw">delete</span>[] p;</span></code></pre></div>
<p>See also <em>C++ smart pointers</em> below.</p>
<h5>
Losing and leaking addresses
</h2>
<p>Often a pointer may be the only indication of where some data or buffer exists in memory. If ongoing use of that data/buffer is needed, or the ability to call <code>free()</code> or <code>delete</code> to avoid leaking the memory, then the programmer must operate on a copy of the pointer…</p>
<div class="sourceCode" id="cb381"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb381-1"><a href="#cb381-1" aria-hidden="true"></a><span class="at">const</span> <span class="dt">char</span>* p = asprintf(<span class="st">&quot;name: </span><span class="sc">%s</span><span class="st">&quot;</span>, name);  <span class="co">// Common but non-Standard printf-on-heap</span></span>
<span id="cb381-2"><a href="#cb381-2" aria-hidden="true"></a></span>
<span id="cb381-3"><a href="#cb381-3" aria-hidden="true"></a><span class="co">// Replace non-printable characters with underscores....</span></span>
<span id="cb381-4"><a href="#cb381-4" aria-hidden="true"></a><span class="cf">for</span> (<span class="at">const</span> <span class="dt">char</span>* q = p; *q; ++q)</span>
<span id="cb381-5"><a href="#cb381-5" aria-hidden="true"></a>    <span class="cf">if</span> (!isprint(*q))</span>
<span id="cb381-6"><a href="#cb381-6" aria-hidden="true"></a>        *q = <span class="ch">&#39;_&#39;</span>;</span>
<span id="cb381-7"><a href="#cb381-7" aria-hidden="true"></a></span>
<span id="cb381-8"><a href="#cb381-8" aria-hidden="true"></a>printf(<span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span>, p); <span class="co">// Only q was modified</span></span>
<span id="cb381-9"><a href="#cb381-9" aria-hidden="true"></a>free(p);</span></code></pre></div>
<p>…or carefully orchestrate reversal of any changes…</p>
<div class="sourceCode" id="cb382"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb382-1"><a href="#cb382-1" aria-hidden="true"></a><span class="at">const</span> <span class="dt">size_t</span> n = ...;</span>
<span id="cb382-2"><a href="#cb382-2" aria-hidden="true"></a>p += n;</span>
<span id="cb382-3"><a href="#cb382-3" aria-hidden="true"></a>...</span>
<span id="cb382-4"><a href="#cb382-4" aria-hidden="true"></a>p -= n;  <span class="co">// Restore earlier value...</span></span></code></pre></div>
<h5>
C++ smart pointers
</h2>
<p>In C++, it’s best practice to use <a href="http://en.wikipedia.org/wiki/Smart_pointer" rel="noreferrer">smart pointer</a> objects to store and manage the pointers, automatically deallocating them when the smart pointers’ destructors run. Since C++11 the Standard Library provides two, <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr" rel="noreferrer"><code>unique_ptr</code></a> for when there’s a single owner for an allocated object…</p>
<div class="sourceCode" id="cb383"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb383-1"><a href="#cb383-1" aria-hidden="true"></a>{</span>
<span id="cb383-2"><a href="#cb383-2" aria-hidden="true"></a>    <span class="bu">std::</span>unique_ptr&lt;T&gt; p{<span class="kw">new</span> T(<span class="dv">42</span>, <span class="st">&quot;meaning&quot;</span>)};</span>
<span id="cb383-3"><a href="#cb383-3" aria-hidden="true"></a>    call_a_function(p);</span>
<span id="cb383-4"><a href="#cb383-4" aria-hidden="true"></a>    <span class="co">// The function above might throw, so delete here is unreliable, but...</span></span>
<span id="cb383-5"><a href="#cb383-5" aria-hidden="true"></a>} <span class="co">// p&#39;s destructor&#39;s guaranteed to run &quot;here&quot;, calling delete</span></span></code></pre></div>
<p>…and <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr" rel="noreferrer"><code>shared_ptr</code></a> for share ownership (using <a href="http://en.wikipedia.org/wiki/Reference_counting" rel="noreferrer">reference counting</a>)…</p>
<div class="sourceCode" id="cb384"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb384-1"><a href="#cb384-1" aria-hidden="true"></a>{</span>
<span id="cb384-2"><a href="#cb384-2" aria-hidden="true"></a>    <span class="bu">std::</span>shared_ptr&lt;T&gt; p(<span class="kw">new</span> T(<span class="fl">3.14</span>, <span class="st">&quot;pi&quot;</span>));</span>
<span id="cb384-3"><a href="#cb384-3" aria-hidden="true"></a>    number_storage.may_add(p); <span class="co">// Might copy p into its container</span></span>
<span id="cb384-4"><a href="#cb384-4" aria-hidden="true"></a>} <span class="co">// p&#39;s destructor will only delete the T if number_storage didn&#39;t copy</span></span></code></pre></div>
<h5>
Null pointers
</h2>
<p>In C, <code>NULL</code> and <code>0</code> - and additionally in C++ <code>nullptr</code> - can be used to indicate that a pointer doesn’t currently hold the memory address of a variable, and shouldn’t be dereferenced or used in pointer arithmetic. For example:</p>
<div class="sourceCode" id="cb385"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb385-1"><a href="#cb385-1" aria-hidden="true"></a><span class="at">const</span> <span class="dt">char</span>* p_filename = NULL; <span class="co">// Or &quot;= 0&quot;, or &quot;= nullptr&quot; in C++</span></span>
<span id="cb385-2"><a href="#cb385-2" aria-hidden="true"></a><span class="dt">char</span> c;</span>
<span id="cb385-3"><a href="#cb385-3" aria-hidden="true"></a><span class="cf">while</span> ((c = getopt(argc, argv, <span class="st">&quot;f:&quot;</span>)) != EOF)</span>
<span id="cb385-4"><a href="#cb385-4" aria-hidden="true"></a>    <span class="cf">switch</span> (c) {</span>
<span id="cb385-5"><a href="#cb385-5" aria-hidden="true"></a>      <span class="cf">case</span> f: p_filename = optarg; <span class="cf">break</span>;</span>
<span id="cb385-6"><a href="#cb385-6" aria-hidden="true"></a>    }</span>
<span id="cb385-7"><a href="#cb385-7" aria-hidden="true"></a><span class="cf">if</span> (p_filename)  <span class="co">// Only NULL converts to false</span></span>
<span id="cb385-8"><a href="#cb385-8" aria-hidden="true"></a>    ...   <span class="co">// Only get here if -f flag specified</span></span></code></pre></div>
<p>In C and C++, just as inbuilt numeric types don’t necessarily default to <code>0</code>, nor <code>bools</code> to <code>false</code>, pointers are not always set to <code>NULL</code>. All these are set to 0/false/NULL when they’re <code>static</code> variables or (C++ only) direct or indirect member variables of static objects or their bases, or undergo zero initialisation (e.g. <code>new T();</code> and <code>new T(x, y, z);</code> perform zero-initialisation on T’s members including pointers, whereas <code>new T;</code> does not).</p>
<p>Further, when you assign <code>0</code>, <code>NULL</code> and <code>nullptr</code> to a pointer the bits in the pointer are not necessarily all reset: the pointer may not contain “0” at the hardware level, or refer to address 0 in your virtual address space. The compiler is allowed to store something else there if it has reason to, but whatever it does - if you come along and compare the pointer to <code>0</code>, <code>NULL</code>, <code>nullptr</code> or another pointer that was assigned any of those, the comparison must work as expected. So, below the source code at the compiler level, “NULL” is potentially a bit “magical” in the C and C++ languages…</p>
<h5>
More about memory addresses, and why you probably don’t need to know
</h2>
<p>More strictly, initialised pointers store a bit-pattern identifying either <code>NULL</code> or a (often <a href="http://en.wikipedia.org/wiki/Virtual_address_space" rel="noreferrer">virtual</a>) memory address.</p>
<p>The simple case is where this is a numeric offset into the process’s entire virtual address space; in more complex cases the pointer may be relative to some specific memory area, which the CPU may select based on CPU “segment” registers or some manner of segment id encoded in the bit-pattern, and/or looking in different places depending on the machine code instructions using the address.</p>
<p>For example, an <code>int*</code> properly initialised to point to an <code>int</code> variable might - after casting to a <code>float*</code> - access a value in “GPU” memory quite distinct from the <code>int</code> variable, then once cast to a function pointer might refer to distinct memory holding the machine opcodes for the function.</p>
<p>3GL programming languages like C and C++ tend to hide this complexity, such that:</p>
<ul>
<li>
<p>
If the compiler gives you a pointer to a variable or function, you can dereference it freely (as long as the variable’s not destructed/deallocated meanwhile) and it’s the compiler’s problem whether e.g. a particular CPU register needs to be restored beforehand, or a distinct machine code instruction used
</p>
</li>
<li>
<p>
If you get a pointer to an element in an array, you can use pointer arithmetic to move anywhere else in the array, or even to form an address one-past-the-end of the array that’s legal to compare with other pointers to elements in the array (or that have similarly been moved by pointer arithmetic to the same one-past-the-end value); again in C and C++, it’s up to the compiler to ensure this “just works”
</p>
</li>
<li>
<p>
Specific OS functions, e.g. shared memory mapping, may give you pointers, and they’ll “just work” within the range of addresses that makes sense for them
</p>
</li>
<li>
<p>
Attempts to move legal pointers beyond these boundaries, or to cast arbitrary numbers to pointers, or use pointers cast to unrelated types, typically have <a href="http://en.wikipedia.org/wiki/Undefined_behavior" rel="noreferrer"><em>undefined behaviour</em></a>, so should be avoided in higher level libraries and applications, but code for OSes, device drivers, etc. may need to rely on behaviour left undefined by C or C++, that is nevertheless well defined by their specific hardware.
</p>
</li>
</ul>
</section>
<section id="answer-2-score-90" class="level4">
<h4>Answer 2 (score 90)</h4>
<p>Dereferencing a pointer means getting the value that is stored in the memory location pointed by the pointer. The operator * is used to do this, and is called the dereferencing operator.</p>
<div class="sourceCode" id="cb386"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb386-1"><a href="#cb386-1" aria-hidden="true"></a><span class="dt">int</span> a = <span class="dv">10</span>;</span>
<span id="cb386-2"><a href="#cb386-2" aria-hidden="true"></a><span class="dt">int</span>* ptr = &amp;a;</span>
<span id="cb386-3"><a href="#cb386-3" aria-hidden="true"></a></span>
<span id="cb386-4"><a href="#cb386-4" aria-hidden="true"></a>printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>, *ptr); <span class="co">// With *ptr I&#39;m dereferencing the pointer. </span></span>
<span id="cb386-5"><a href="#cb386-5" aria-hidden="true"></a>                    <span class="co">// Which means, I am asking the value pointed at by the pointer.</span></span>
<span id="cb386-6"><a href="#cb386-6" aria-hidden="true"></a>                    <span class="co">// ptr is pointing to the location in memory of the variable a.</span></span>
<span id="cb386-7"><a href="#cb386-7" aria-hidden="true"></a>                    <span class="co">// In a&#39;s location, we have 10. So, dereferencing gives this value.</span></span>
<span id="cb386-8"><a href="#cb386-8" aria-hidden="true"></a></span>
<span id="cb386-9"><a href="#cb386-9" aria-hidden="true"></a><span class="co">// Since we have indirect control over a&#39;s location, we can modify its content using the pointer. This is an indirect way to access a.</span></span>
<span id="cb386-10"><a href="#cb386-10" aria-hidden="true"></a></span>
<span id="cb386-11"><a href="#cb386-11" aria-hidden="true"></a> *ptr = <span class="dv">20</span>;         <span class="co">// Now a&#39;s content is no longer 10, and has been modified to 20.</span></span></code></pre></div>
</section>
<section id="answer-3-score-16" class="level4">
<h4>Answer 3 (score 16)</h4>
<p>A pointer is a “reference” to a value.. much like a library call number is a reference to a book. “Dereferencing” the call number is physically going through and retrieving that book.</p>
<div class="sourceCode" id="cb387"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb387-1"><a href="#cb387-1" aria-hidden="true"></a><span class="dt">int</span> a=<span class="dv">4</span> ;</span>
<span id="cb387-2"><a href="#cb387-2" aria-hidden="true"></a><span class="dt">int</span> *pA = &amp;a ;</span>
<span id="cb387-3"><a href="#cb387-3" aria-hidden="true"></a>printf( <span class="st">&quot;The REFERENCE/call number for the variable `a` is </span><span class="sc">%p\n</span><span class="st">&quot;</span>, pA ) ;</span>
<span id="cb387-4"><a href="#cb387-4" aria-hidden="true"></a></span>
<span id="cb387-5"><a href="#cb387-5" aria-hidden="true"></a><span class="co">// The * causes pA to DEREFERENCE...  `a` via &quot;callnumber&quot; `pA`.</span></span>
<span id="cb387-6"><a href="#cb387-6" aria-hidden="true"></a>printf( <span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>, *pA ) ; <span class="co">// prints 4.. </span></span></code></pre></div>
<p>If the book isn’t there, the librarian starts shouting, shuts the library down, and a couple of people are set to investigate the cause of a person going to find a book that isn’t there.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="when-should-static_cast-dynamic_cast-const_cast-and-reinterpret_cast-be-used-score-515678-in-2015" class="level3">
<h3>61: When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used? (score <a href="https://stackoverflow.com/q/332030.html">515678</a> in 2015)</h3>
<section id="question-58" class="level4">
<h4>Question</h4>
<p>What are the proper uses of:</p>
<ul>
<li>
<code>static_cast</code>
</li>
<li>
<code>dynamic_cast</code>
</li>
<li>
<code>const_cast</code>
</li>
<li>
<code>reinterpret_cast</code>
</li>
<li>
C-style cast <code>(type)value</code>
</li>
<li>
Function-style cast <code>type(value)</code>
</li>
</ul>
<p>How does one decide which to use in which specific cases?</p>
</section>
<section id="answer-accepted-score-2440" class="level4">
<h4>Answer accepted (score 2440)</h4>
<p><strong><code>static_cast</code></strong> is the first cast you should attempt to use. It does things like implicit conversions between types (such as <code>int</code> to <code>float</code>, or pointer to <code>void*</code>), and it can also call explicit conversion functions (or implicit ones). In many cases, explicitly stating <code>static_cast</code> isn’t necessary, but it’s important to note that the <code>T(something)</code> syntax is equivalent to <code>(T)something</code> and should be avoided (more on that later). A <code>T(something, something_else)</code> is safe, however, and guaranteed to call the constructor.</p>
<p><code>static_cast</code> can also cast through inheritance hierarchies. It is unnecessary when casting upwards (towards a base class), but when casting downwards it can be used as long as it doesn’t cast through <code>virtual</code> inheritance. It does not do checking, however, and it is undefined behavior to <code>static_cast</code> down a hierarchy to a type that isn’t actually the type of the object.</p>
<hr>
<p><strong><code>const_cast</code></strong> can be used to remove or add <code>const</code> to a variable; no other C++ cast is capable of removing it (not even <code>reinterpret_cast</code>). It is important to note that modifying a formerly <code>const</code> value is only undefined if the original variable is <code>const</code>; if you use it to take the <code>const</code> off a reference to something that wasn’t declared with <code>const</code>, it is safe. This can be useful when overloading member functions based on <code>const</code>, for instance. It can also be used to add <code>const</code> to an object, such as to call a member function overload.</p>
<p><code>const_cast</code> also works similarly on <code>volatile</code>, though that’s less common.</p>
<hr>
<p><strong><code>dynamic_cast</code></strong> is exclusively used for handling polymorphism. You can cast a pointer or reference to any polymorphic type to any other class type (a polymorphic type has at least one virtual function, declared or inherited). You can use it for more than just casting downwards – you can cast sideways or even up another chain. The <code>dynamic_cast</code> will seek out the desired object and return it if possible. If it can’t, it will return <code>nullptr</code> in the case of a pointer, or throw <code>std::bad_cast</code> in the case of a reference.</p>
<p><code>dynamic_cast</code> has some limitations, though. It doesn’t work if there are multiple objects of the same type in the inheritance hierarchy (the so-called ‘dreaded diamond’) and you aren’t using <code>virtual</code> inheritance. It also can only go through public inheritance - it will always fail to travel through <code>protected</code> or <code>private</code> inheritance. This is rarely an issue, however, as such forms of inheritance are rare.</p>
<hr>
<p><strong><code>reinterpret_cast</code></strong> is the most dangerous cast, and should be used very sparingly. It turns one type directly into another — such as casting the value from one pointer to another, or storing a pointer in an <code>int</code>, or all sorts of other nasty things. Largely, the only guarantee you get with <code>reinterpret_cast</code> is that normally if you cast the result back to the original type, you will get the exact same value (but <strong><em>not</em></strong> if the intermediate type is smaller than the original type). There are a number of conversions that <strong><code>reinterpret_cast</code></strong> cannot do, too. It’s used primarily for particularly weird conversions and bit manipulations, like turning a raw data stream into actual data, or storing data in the low bits of a pointer to aligned data.</p>
<hr>
<p><strong>C-style cast</strong> and <strong>function-style cast</strong> are casts using <code>(type)object</code> or <code>type(object)</code>, respectively, and are functionally equivalent. They are defined as the first of the following which succeeds:</p>
<ul>
<li>
<code>const_cast</code>
</li>
<li>
<code>static_cast</code> (though ignoring access restrictions)
</li>
<li>
<code>static_cast</code> (see above), then <code>const_cast</code>
</li>
<li>
<code>reinterpret_cast</code>
</li>
<li>
<code>reinterpret_cast</code>, then <code>const_cast</code>
</li>
</ul>
<p>It can therefore be used as a replacement for other casts in some instances, but can be extremely dangerous because of the ability to devolve into a <code>reinterpret_cast</code>, and the latter should be preferred when explicit casting is needed, unless you are sure <code>static_cast</code> will succeed or <code>reinterpret_cast</code> will fail. Even then, consider the longer, more explicit option.</p>
<p>C-style casts also ignore access control when performing a <code>static_cast</code>, which means that they have the ability to perform an operation that no other cast can. This is mostly a kludge, though, and in my mind is just another reason to avoid C-style casts.</p>
</section>
<section id="answer-2-score-315" class="level4">
<h4>Answer 2 (score 315)</h4>
<p>Use <code>dynamic_cast</code> for converting pointers/references within an inheritance hierarchy.</p>
<p>Use <code>static_cast</code> for ordinary type conversions.</p>
<p>Use <code>reinterpret_cast</code> for low-level reinterpreting of bit patterns. Use with extreme caution.</p>
<p>Use <code>const_cast</code> for casting away <code>const/volatile</code>. Avoid this unless you are stuck using a const-incorrect API.</p>
</section>
<section id="answer-3-score-186" class="level4">
<h4>Answer 3 (score 186)</h4>
<p><em>(A lot of theoretical and conceptual explanation has been given above)</em></p>
<p>Below are some of the <strong>practical examples</strong> when I used <strong>static_cast</strong>, <strong>dynamic_cast</strong>, <strong>const_cast</strong>, <strong>reinterpret_cast</strong>.</p>
<p>(Also referes this to understand the explaination : <a href="http://www.cplusplus.com/doc/tutorial/typecasting/" rel="noreferrer">http://www.cplusplus.com/doc/tutorial/typecasting/</a>)</p>
<p><strong>static_cast :</strong></p>
<div class="sourceCode" id="cb388"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb388-1"><a href="#cb388-1" aria-hidden="true"></a>OnEventData(<span class="dt">void</span>* pData)</span>
<span id="cb388-2"><a href="#cb388-2" aria-hidden="true"></a></span>
<span id="cb388-3"><a href="#cb388-3" aria-hidden="true"></a>{</span>
<span id="cb388-4"><a href="#cb388-4" aria-hidden="true"></a>  ......</span>
<span id="cb388-5"><a href="#cb388-5" aria-hidden="true"></a></span>
<span id="cb388-6"><a href="#cb388-6" aria-hidden="true"></a>  <span class="co">//  pData is a void* pData, </span></span>
<span id="cb388-7"><a href="#cb388-7" aria-hidden="true"></a></span>
<span id="cb388-8"><a href="#cb388-8" aria-hidden="true"></a>  <span class="co">//  EventData is a structure e.g. </span></span>
<span id="cb388-9"><a href="#cb388-9" aria-hidden="true"></a>  <span class="co">//  typedef struct _EventData {</span></span>
<span id="cb388-10"><a href="#cb388-10" aria-hidden="true"></a>  <span class="co">//  std::string id;</span></span>
<span id="cb388-11"><a href="#cb388-11" aria-hidden="true"></a>  <span class="co">//  std:: string remote_id;</span></span>
<span id="cb388-12"><a href="#cb388-12" aria-hidden="true"></a>  <span class="co">//  } EventData;</span></span>
<span id="cb388-13"><a href="#cb388-13" aria-hidden="true"></a></span>
<span id="cb388-14"><a href="#cb388-14" aria-hidden="true"></a>  <span class="co">// On Some Situation a void pointer *pData</span></span>
<span id="cb388-15"><a href="#cb388-15" aria-hidden="true"></a>  <span class="co">// has been static_casted as </span></span>
<span id="cb388-16"><a href="#cb388-16" aria-hidden="true"></a>  <span class="co">// EventData* pointer </span></span>
<span id="cb388-17"><a href="#cb388-17" aria-hidden="true"></a></span>
<span id="cb388-18"><a href="#cb388-18" aria-hidden="true"></a>  EventData *evtdata = <span class="kw">static_cast</span>&lt;EventData*&gt;(pData);</span>
<span id="cb388-19"><a href="#cb388-19" aria-hidden="true"></a>  .....</span>
<span id="cb388-20"><a href="#cb388-20" aria-hidden="true"></a>}</span></code></pre></div>
<p><strong>dynamic_cast :</strong></p>
<div class="sourceCode" id="cb389"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb389-1"><a href="#cb389-1" aria-hidden="true"></a><span class="dt">void</span> DebugLog::OnMessage(Message *msg)</span>
<span id="cb389-2"><a href="#cb389-2" aria-hidden="true"></a>{</span>
<span id="cb389-3"><a href="#cb389-3" aria-hidden="true"></a>    <span class="at">static</span> DebugMsgData *debug;</span>
<span id="cb389-4"><a href="#cb389-4" aria-hidden="true"></a>    <span class="at">static</span> XYZMsgData *xyz;</span>
<span id="cb389-5"><a href="#cb389-5" aria-hidden="true"></a></span>
<span id="cb389-6"><a href="#cb389-6" aria-hidden="true"></a>    <span class="cf">if</span>(debug = <span class="kw">dynamic_cast</span>&lt;DebugMsgData*&gt;(msg-&gt;pdata)){</span>
<span id="cb389-7"><a href="#cb389-7" aria-hidden="true"></a>        <span class="co">// debug message</span></span>
<span id="cb389-8"><a href="#cb389-8" aria-hidden="true"></a>    }</span>
<span id="cb389-9"><a href="#cb389-9" aria-hidden="true"></a>    <span class="cf">else</span> <span class="cf">if</span>(xyz = <span class="kw">dynamic_cast</span>&lt;XYZMsgData*&gt;(msg-&gt;pdata)){</span>
<span id="cb389-10"><a href="#cb389-10" aria-hidden="true"></a>        <span class="co">// xyz message</span></span>
<span id="cb389-11"><a href="#cb389-11" aria-hidden="true"></a>    }</span>
<span id="cb389-12"><a href="#cb389-12" aria-hidden="true"></a>    <span class="cf">else</span><span class="co">/* if( ... )*/</span>{</span>
<span id="cb389-13"><a href="#cb389-13" aria-hidden="true"></a>        <span class="co">// ...</span></span>
<span id="cb389-14"><a href="#cb389-14" aria-hidden="true"></a>    }</span>
<span id="cb389-15"><a href="#cb389-15" aria-hidden="true"></a>}</span></code></pre></div>
<p><strong>const_cast :</strong></p>
<div class="sourceCode" id="cb390"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb390-1"><a href="#cb390-1" aria-hidden="true"></a><span class="co">// *Passwd declared as a const</span></span>
<span id="cb390-2"><a href="#cb390-2" aria-hidden="true"></a></span>
<span id="cb390-3"><a href="#cb390-3" aria-hidden="true"></a><span class="at">const</span> <span class="dt">unsigned</span> <span class="dt">char</span> *Passwd</span>
<span id="cb390-4"><a href="#cb390-4" aria-hidden="true"></a></span>
<span id="cb390-5"><a href="#cb390-5" aria-hidden="true"></a></span>
<span id="cb390-6"><a href="#cb390-6" aria-hidden="true"></a><span class="co">// on some situation it require to remove its constness</span></span>
<span id="cb390-7"><a href="#cb390-7" aria-hidden="true"></a></span>
<span id="cb390-8"><a href="#cb390-8" aria-hidden="true"></a><span class="kw">const_cast</span>&lt;<span class="dt">unsigned</span> <span class="dt">char</span>*&gt;(Passwd)</span></code></pre></div>
<p><strong>reinterpret_cast :</strong></p>
<div class="sourceCode" id="cb391"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb391-1"><a href="#cb391-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">short</span> uint16;</span>
<span id="cb391-2"><a href="#cb391-2" aria-hidden="true"></a></span>
<span id="cb391-3"><a href="#cb391-3" aria-hidden="true"></a><span class="co">// Read Bytes returns that 2 bytes got read. </span></span>
<span id="cb391-4"><a href="#cb391-4" aria-hidden="true"></a></span>
<span id="cb391-5"><a href="#cb391-5" aria-hidden="true"></a><span class="dt">bool</span> ByteBuffer::ReadUInt16(uint16&amp; val) {</span>
<span id="cb391-6"><a href="#cb391-6" aria-hidden="true"></a>  <span class="cf">return</span> ReadBytes(<span class="kw">reinterpret_cast</span>&lt;<span class="dt">char</span>*&gt;(&amp;val), <span class="dv">2</span>);</span>
<span id="cb391-7"><a href="#cb391-7" aria-hidden="true"></a>}</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="why-do-we-need-virtual-functions-in-c-score-514757-in-2017" class="level3">
<h3>62: Why do we need virtual functions in C++? (score <a href="https://stackoverflow.com/q/2391679.html">514757</a> in 2017)</h3>
<section id="question-59" class="level4">
<h4>Question</h4>
<p>I’m learning C++ and I’m just getting into virtual functions.</p>
<p>From what I’ve read (in the book and online), virtual functions are functions in the base class that you can override in derived classes.</p>
<p>But earlier in the book, when learning about basic inheritance, I was able to override base functions in derived classes without using <code>virtual</code>.</p>
<p>So what am I missing here? I know there is more to virtual functions, and it seems to be important so I want to be clear on what it is exactly. I just can’t find a straight answer online.</p>
</section>
<section id="answer-accepted-score-2588" class="level4">
<h4>Answer accepted (score 2588)</h4>
<p>Here is how I understood not just what <a href="https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.3.0/com.ibm.zos.v2r3.cbclx01/cplr139.htm" rel="noreferrer"><code>virtual</code></a> functions are, but why they’re required:</p>
<p>Let’s say you have these two classes:</p>
<div class="sourceCode" id="cb392"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb392-1"><a href="#cb392-1" aria-hidden="true"></a><span class="kw">class</span> Animal</span>
<span id="cb392-2"><a href="#cb392-2" aria-hidden="true"></a>{</span>
<span id="cb392-3"><a href="#cb392-3" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb392-4"><a href="#cb392-4" aria-hidden="true"></a>        <span class="dt">void</span> eat() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;I&#39;m eating generic food.&quot;</span>; }</span>
<span id="cb392-5"><a href="#cb392-5" aria-hidden="true"></a>};</span>
<span id="cb392-6"><a href="#cb392-6" aria-hidden="true"></a></span>
<span id="cb392-7"><a href="#cb392-7" aria-hidden="true"></a><span class="kw">class</span> Cat : <span class="kw">public</span> Animal</span>
<span id="cb392-8"><a href="#cb392-8" aria-hidden="true"></a>{</span>
<span id="cb392-9"><a href="#cb392-9" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb392-10"><a href="#cb392-10" aria-hidden="true"></a>        <span class="dt">void</span> eat() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;I&#39;m eating a rat.&quot;</span>; }</span>
<span id="cb392-11"><a href="#cb392-11" aria-hidden="true"></a>};</span></code></pre></div>
<p>In your main function:</p>
<div class="sourceCode" id="cb393"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb393-1"><a href="#cb393-1" aria-hidden="true"></a>Animal *animal = <span class="kw">new</span> Animal;</span>
<span id="cb393-2"><a href="#cb393-2" aria-hidden="true"></a>Cat *cat = <span class="kw">new</span> Cat;</span>
<span id="cb393-3"><a href="#cb393-3" aria-hidden="true"></a></span>
<span id="cb393-4"><a href="#cb393-4" aria-hidden="true"></a>animal-&gt;eat(); <span class="co">// Outputs: &quot;I&#39;m eating generic food.&quot;</span></span>
<span id="cb393-5"><a href="#cb393-5" aria-hidden="true"></a>cat-&gt;eat();    <span class="co">// Outputs: &quot;I&#39;m eating a rat.&quot;</span></span></code></pre></div>
<p>So far so good, right? Animals eat generic food, cats eat rats, all without <code>virtual</code>.</p>
<p>Let’s change it a little now so that <code>eat()</code> is called via an intermediate function (a trivial function just for this example):</p>
<div class="sourceCode" id="cb394"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb394-1"><a href="#cb394-1" aria-hidden="true"></a><span class="co">// This can go at the top of the main.cpp file</span></span>
<span id="cb394-2"><a href="#cb394-2" aria-hidden="true"></a><span class="dt">void</span> func(Animal *xyz) { xyz-&gt;eat(); }</span></code></pre></div>
<p>Now our main function is:</p>
<div class="sourceCode" id="cb395"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb395-1"><a href="#cb395-1" aria-hidden="true"></a>Animal *animal = <span class="kw">new</span> Animal;</span>
<span id="cb395-2"><a href="#cb395-2" aria-hidden="true"></a>Cat *cat = <span class="kw">new</span> Cat;</span>
<span id="cb395-3"><a href="#cb395-3" aria-hidden="true"></a></span>
<span id="cb395-4"><a href="#cb395-4" aria-hidden="true"></a>func(animal); <span class="co">// Outputs: &quot;I&#39;m eating generic food.&quot;</span></span>
<span id="cb395-5"><a href="#cb395-5" aria-hidden="true"></a>func(cat);    <span class="co">// Outputs: &quot;I&#39;m eating generic food.&quot;</span></span></code></pre></div>
<p>Uh oh… we passed a Cat into <code>func()</code>, but it won’t eat rats. Should you overload <code>func()</code> so it takes a <code>Cat*</code>? If you have to derive more animals from Animal they would all need their own <code>func()</code>.</p>
<p>The solution is to make <code>eat()</code> from the <code>Animal</code> class a virtual function:</p>
<div class="sourceCode" id="cb396"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb396-1"><a href="#cb396-1" aria-hidden="true"></a><span class="kw">class</span> Animal</span>
<span id="cb396-2"><a href="#cb396-2" aria-hidden="true"></a>{</span>
<span id="cb396-3"><a href="#cb396-3" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb396-4"><a href="#cb396-4" aria-hidden="true"></a>        <span class="kw">virtual</span> <span class="dt">void</span> eat() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;I&#39;m eating generic food.&quot;</span>; }</span>
<span id="cb396-5"><a href="#cb396-5" aria-hidden="true"></a>};</span>
<span id="cb396-6"><a href="#cb396-6" aria-hidden="true"></a></span>
<span id="cb396-7"><a href="#cb396-7" aria-hidden="true"></a><span class="kw">class</span> Cat : <span class="kw">public</span> Animal</span>
<span id="cb396-8"><a href="#cb396-8" aria-hidden="true"></a>{</span>
<span id="cb396-9"><a href="#cb396-9" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb396-10"><a href="#cb396-10" aria-hidden="true"></a>        <span class="dt">void</span> eat() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;I&#39;m eating a rat.&quot;</span>; }</span>
<span id="cb396-11"><a href="#cb396-11" aria-hidden="true"></a>};</span></code></pre></div>
<p>Main:</p>
<div class="sourceCode" id="cb397"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb397-1"><a href="#cb397-1" aria-hidden="true"></a>func(animal); <span class="co">// Outputs: &quot;I&#39;m eating generic food.&quot;</span></span>
<span id="cb397-2"><a href="#cb397-2" aria-hidden="true"></a>func(cat);    <span class="co">// Outputs: &quot;I&#39;m eating a rat.&quot;</span></span></code></pre></div>
<p>Done.</p>
</section>
<section id="answer-2-score-622" class="level4">
<h4>Answer 2 (score 622)</h4>
<p>Without “virtual” you get “early binding”. Which implementation of the method is used gets decided at compile time based on the type of the pointer that you call through.</p>
<p>With “virtual” you get “late binding”. Which implementation of the method is used gets decided at run time based on the type of the pointed-to object - what it was originally constructed as. This is not necessarily what you’d think based on the type of the pointer that points to that object.</p>
<div class="sourceCode" id="cb398"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb398-1"><a href="#cb398-1" aria-hidden="true"></a><span class="kw">class</span> Base</span>
<span id="cb398-2"><a href="#cb398-2" aria-hidden="true"></a>{</span>
<span id="cb398-3"><a href="#cb398-3" aria-hidden="true"></a>  <span class="kw">public</span>:</span>
<span id="cb398-4"><a href="#cb398-4" aria-hidden="true"></a>            <span class="dt">void</span> Method1 ()  {  <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Base::Method1&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;  }</span>
<span id="cb398-5"><a href="#cb398-5" aria-hidden="true"></a>    <span class="kw">virtual</span> <span class="dt">void</span> Method2 ()  {  <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Base::Method2&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;  }</span>
<span id="cb398-6"><a href="#cb398-6" aria-hidden="true"></a>};</span>
<span id="cb398-7"><a href="#cb398-7" aria-hidden="true"></a></span>
<span id="cb398-8"><a href="#cb398-8" aria-hidden="true"></a><span class="kw">class</span> Derived : <span class="kw">public</span> Base</span>
<span id="cb398-9"><a href="#cb398-9" aria-hidden="true"></a>{</span>
<span id="cb398-10"><a href="#cb398-10" aria-hidden="true"></a>  <span class="kw">public</span>:</span>
<span id="cb398-11"><a href="#cb398-11" aria-hidden="true"></a>    <span class="dt">void</span> Method1 ()  {  <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Derived::Method1&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;  }</span>
<span id="cb398-12"><a href="#cb398-12" aria-hidden="true"></a>    <span class="dt">void</span> Method2 ()  {  <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Derived::Method2&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;  }</span>
<span id="cb398-13"><a href="#cb398-13" aria-hidden="true"></a>};</span>
<span id="cb398-14"><a href="#cb398-14" aria-hidden="true"></a></span>
<span id="cb398-15"><a href="#cb398-15" aria-hidden="true"></a>Base* obj = <span class="kw">new</span> Derived ();</span>
<span id="cb398-16"><a href="#cb398-16" aria-hidden="true"></a>  <span class="co">//  Note - constructed as Derived, but pointer stored as Base*</span></span>
<span id="cb398-17"><a href="#cb398-17" aria-hidden="true"></a></span>
<span id="cb398-18"><a href="#cb398-18" aria-hidden="true"></a>obj-&gt;Method1 ();  <span class="co">//  Prints &quot;Base::Method1&quot;</span></span>
<span id="cb398-19"><a href="#cb398-19" aria-hidden="true"></a>obj-&gt;Method2 ();  <span class="co">//  Prints &quot;Derived::Method2&quot;</span></span></code></pre></div>
<p><strong>EDIT</strong> - see <a href="https://stackoverflow.com/questions/10580/what-are-early-and-late-binding">this question</a>.</p>
<p>Also - <a href="http://www.learncpp.com/cpp-tutorial/124-early-binding-and-late-binding/" rel="noreferrer">this tutorial</a> covers early and late binding in C++.</p>
</section>
<section id="answer-3-score-79-1" class="level4">
<h4>Answer 3 (score 79)</h4>
<p>You need at least 1 level of inheritance and a downcast to demonstrate it. Here is a very simple example:</p>
<div class="sourceCode" id="cb399"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb399-1"><a href="#cb399-1" aria-hidden="true"></a><span class="kw">class</span> Animal</span>
<span id="cb399-2"><a href="#cb399-2" aria-hidden="true"></a>{        </span>
<span id="cb399-3"><a href="#cb399-3" aria-hidden="true"></a>    <span class="kw">public</span>: </span>
<span id="cb399-4"><a href="#cb399-4" aria-hidden="true"></a>      <span class="co">// turn the following virtual modifier on/off to see what happens</span></span>
<span id="cb399-5"><a href="#cb399-5" aria-hidden="true"></a>      <span class="co">//virtual   </span></span>
<span id="cb399-6"><a href="#cb399-6" aria-hidden="true"></a>      <span class="bu">std::</span>string Says() { <span class="cf">return</span> <span class="st">&quot;?&quot;</span>; }  </span>
<span id="cb399-7"><a href="#cb399-7" aria-hidden="true"></a>};</span>
<span id="cb399-8"><a href="#cb399-8" aria-hidden="true"></a></span>
<span id="cb399-9"><a href="#cb399-9" aria-hidden="true"></a><span class="kw">class</span> Dog: <span class="kw">public</span> Animal</span>
<span id="cb399-10"><a href="#cb399-10" aria-hidden="true"></a>{</span>
<span id="cb399-11"><a href="#cb399-11" aria-hidden="true"></a>    <span class="kw">public</span>: <span class="bu">std::</span>string Says() { <span class="cf">return</span> <span class="st">&quot;Woof&quot;</span>; }</span>
<span id="cb399-12"><a href="#cb399-12" aria-hidden="true"></a>};</span>
<span id="cb399-13"><a href="#cb399-13" aria-hidden="true"></a></span>
<span id="cb399-14"><a href="#cb399-14" aria-hidden="true"></a><span class="dt">void</span> test()</span>
<span id="cb399-15"><a href="#cb399-15" aria-hidden="true"></a>{</span>
<span id="cb399-16"><a href="#cb399-16" aria-hidden="true"></a>    Dog* d = <span class="kw">new</span> Dog();</span>
<span id="cb399-17"><a href="#cb399-17" aria-hidden="true"></a>    Animal* a = d;       <span class="co">// refer to Dog instance with Animal pointer</span></span>
<span id="cb399-18"><a href="#cb399-18" aria-hidden="true"></a></span>
<span id="cb399-19"><a href="#cb399-19" aria-hidden="true"></a>    cout &lt;&lt; d-&gt;Says();   <span class="co">// always Woof</span></span>
<span id="cb399-20"><a href="#cb399-20" aria-hidden="true"></a>    cout &lt;&lt; a-&gt;Says();   <span class="co">// Woof or ?, depends on virtual</span></span>
<span id="cb399-21"><a href="#cb399-21" aria-hidden="true"></a>}</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="what-is-an-undefined-referenceunresolved-external-symbol-error-and-how-do-i-fix-it-score-514061-in-2018" class="level3">
<h3>63: What is an undefined reference/unresolved external symbol error and how do I fix it? (score <a href="https://stackoverflow.com/q/12573816.html">514061</a> in 2018)</h3>
<section id="question-60" class="level4">
<h4>Question</h4>
<p>What are undefined reference/unresolved external symbol errors? What are common causes and how to fix/prevent them?</p>
<p><sub>Feel free to edit/add your own.</sub></p>
</section>
<section id="answer-accepted-score-806" class="level4">
<h4>Answer accepted (score 806)</h4>
<p>Compiling a C++ program takes place in several steps, as specified by <strong>2.2</strong> <a href="https://stackoverflow.com/a/8834196/673730">(credits to Keith Thompson for the reference)</a>:</p>
<blockquote>
<p>The precedence among the syntax rules of translation is specified by the following phases <em>[see footnote]</em>.</p>
<ol>
<li>
Physical source file characters are mapped, in an implementation-defined manner, to the basic source character set (introducing new-line characters for end-of-line indicators) if necessary. <em>[SNIP]</em>
</li>
<li>
Each instance of a backslash character () immediately followed by a new-line character is deleted, splicing physical source lines to form logical source lines. <em>[SNIP]</em>
</li>
<li>
The source file is decomposed into preprocessing tokens (2.5) and sequences of white-space characters (including comments). <em>[SNIP]</em>
</li>
<li>
Preprocessing directives are executed, macro invocations are expanded, and _Pragma unary operator expressions are executed. <em>[SNIP]</em>
</li>
<li>
Each source character set member in a character literal or a string literal, as well as each escape sequence and universal-character-name in a character literal or a non-raw string literal, is converted to the corresponding member of the execution character set; <em>[SNIP]</em>
</li>
<li>
Adjacent string literal tokens are concatenated.
</li>
<li>
White-space characters separating tokens are no longer significant. Each preprocessing token is converted into a token. (2.7). The resulting tokens are syntactically and semantically analyzed and translated as a translation unit. <em>[SNIP]</em>
</li>
<li>
Translated translation units and instantiation units are combined as follows: <em>[SNIP]</em>
</li>
<li>
<strong>All external entity references are resolved. Library components are linked to satisfy external references to entities not defined in the current translation. All such translator output is collected into a program image which contains information needed for execution in its execution environment.</strong> (emphasis mine)
</li>
</ol>
<em>[footnote]</em> Implementations must behave as if these separate phases occur, although in practice different phases might be folded together.
</blockquote>
<p>The specified errors occur during this last stage of compilation, most commonly referred to as linking. It basically means that you compiled a bunch of implementation files into object files or libraries and now you want to get them to work together.</p>
<p>Say you defined symbol <code>a</code> in <code>a.cpp</code>. Now, <code>b.cpp</code> <em>declared</em> that symbol and used it. Before linking, it simply assumes that that symbol was defined <em>somewhere</em>, but it doesn’t yet care where. The linking phase is responsible for finding the symbol and correctly linking it to <code>b.cpp</code> (well, actually to the object or library that uses it).</p>
<p>If you’re using Microsoft Visual Studio, you’ll see that projects generate <code>.lib</code> files. These contain a table of exported symbols, and a table of imported symbols. The imported symbols are resolved against the libraries you link against, and the exported symbols are provided for the libraries that use that <code>.lib</code> (if any).</p>
<p>Similar mechanisms exist for other compilers/ platforms.</p>
<p>Common error messages are <code>error LNK2001</code>, <code>error LNK1120</code>, <code>error LNK2019</code> for <strong>Microsoft Visual Studio</strong> and <code>undefined reference to</code> <em>symbolName</em> for <strong>GCC</strong>.</p>
<p>The code:</p>
<div class="sourceCode" id="cb400"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb400-1"><a href="#cb400-1" aria-hidden="true"></a><span class="kw">struct</span> X</span>
<span id="cb400-2"><a href="#cb400-2" aria-hidden="true"></a>{</span>
<span id="cb400-3"><a href="#cb400-3" aria-hidden="true"></a>   <span class="kw">virtual</span> <span class="dt">void</span> foo();</span>
<span id="cb400-4"><a href="#cb400-4" aria-hidden="true"></a>};</span>
<span id="cb400-5"><a href="#cb400-5" aria-hidden="true"></a><span class="kw">struct</span> Y : X</span>
<span id="cb400-6"><a href="#cb400-6" aria-hidden="true"></a>{</span>
<span id="cb400-7"><a href="#cb400-7" aria-hidden="true"></a>   <span class="dt">void</span> foo() {}</span>
<span id="cb400-8"><a href="#cb400-8" aria-hidden="true"></a>};</span>
<span id="cb400-9"><a href="#cb400-9" aria-hidden="true"></a><span class="kw">struct</span> A</span>
<span id="cb400-10"><a href="#cb400-10" aria-hidden="true"></a>{</span>
<span id="cb400-11"><a href="#cb400-11" aria-hidden="true"></a>   <span class="kw">virtual</span> ~A() = <span class="dv">0</span>;</span>
<span id="cb400-12"><a href="#cb400-12" aria-hidden="true"></a>};</span>
<span id="cb400-13"><a href="#cb400-13" aria-hidden="true"></a><span class="kw">struct</span> B: A</span>
<span id="cb400-14"><a href="#cb400-14" aria-hidden="true"></a>{</span>
<span id="cb400-15"><a href="#cb400-15" aria-hidden="true"></a>   <span class="kw">virtual</span> ~B(){}</span>
<span id="cb400-16"><a href="#cb400-16" aria-hidden="true"></a>};</span>
<span id="cb400-17"><a href="#cb400-17" aria-hidden="true"></a><span class="at">extern</span> <span class="dt">int</span> x;</span>
<span id="cb400-18"><a href="#cb400-18" aria-hidden="true"></a><span class="dt">void</span> foo();</span>
<span id="cb400-19"><a href="#cb400-19" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb400-20"><a href="#cb400-20" aria-hidden="true"></a>{</span>
<span id="cb400-21"><a href="#cb400-21" aria-hidden="true"></a>   x = <span class="dv">0</span>;</span>
<span id="cb400-22"><a href="#cb400-22" aria-hidden="true"></a>   foo();</span>
<span id="cb400-23"><a href="#cb400-23" aria-hidden="true"></a>   Y y;</span>
<span id="cb400-24"><a href="#cb400-24" aria-hidden="true"></a>   B b;</span>
<span id="cb400-25"><a href="#cb400-25" aria-hidden="true"></a>}</span></code></pre></div>
<p>will generate the following errors with <strong>GCC</strong>:</p>
<div class="sourceCode" id="cb401"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb401-1"><a href="#cb401-1" aria-hidden="true"></a>/home/AbiSfw/ccvvuHoX.o: In function <span class="er">`</span>main<span class="ch">&#39;:</span></span>
<span id="cb401-2"><a href="#cb401-2" aria-hidden="true"></a>prog.cpp:(.text+<span class="bn">0x10</span>): undefined reference to <span class="er">`</span>x<span class="ch">&#39;</span></span>
<span id="cb401-3"><a href="#cb401-3" aria-hidden="true"></a>prog.cpp:(.text+<span class="bn">0x19</span>): undefined reference to <span class="er">`</span>foo()<span class="ch">&#39;</span></span>
<span id="cb401-4"><a href="#cb401-4" aria-hidden="true"></a>prog.cpp:(.text+<span class="bn">0x2d</span>): undefined reference to <span class="er">`</span>A::~A()<span class="ch">&#39;</span></span>
<span id="cb401-5"><a href="#cb401-5" aria-hidden="true"></a>/home/AbiSfw/ccvvuHoX.o: In function <span class="er">`</span>B::~B()<span class="ch">&#39;:</span></span>
<span id="cb401-6"><a href="#cb401-6" aria-hidden="true"></a>prog.cpp:(.text._ZN1BD1Ev[B::~B()]+<span class="bn">0xb</span>): undefined reference to <span class="er">`</span>A::~A()<span class="ch">&#39;</span></span>
<span id="cb401-7"><a href="#cb401-7" aria-hidden="true"></a>/home/AbiSfw/ccvvuHoX.o: In function <span class="er">`</span>B::~B()<span class="ch">&#39;:</span></span>
<span id="cb401-8"><a href="#cb401-8" aria-hidden="true"></a>prog.cpp:(.text._ZN1BD0Ev[B::~B()]+<span class="bn">0x12</span>): undefined reference to <span class="er">`</span>A::~A()<span class="ch">&#39;</span></span>
<span id="cb401-9"><a href="#cb401-9" aria-hidden="true"></a>/home/AbiSfw/ccvvuHoX.o:(.rodata._ZTI1Y[typeinfo <span class="cf">for</span> Y]+<span class="bn">0x8</span>): undefined reference to <span class="er">`</span>typeinfo <span class="cf">for</span> X<span class="ch">&#39;</span></span>
<span id="cb401-10"><a href="#cb401-10" aria-hidden="true"></a>/home/AbiSfw/ccvvuHoX.o:(.rodata._ZTI1B[typeinfo <span class="cf">for</span> B]+<span class="bn">0x8</span>): undefined reference to <span class="er">`</span>typeinfo <span class="cf">for</span> A<span class="ch">&#39;</span></span>
<span id="cb401-11"><a href="#cb401-11" aria-hidden="true"></a>collect2: ld returned <span class="dv">1</span> exit status</span></code></pre></div>
<p>and similar errors with <strong>Microsoft Visual Studio</strong>:</p>
<div class="sourceCode" id="cb402"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb402-1"><a href="#cb402-1" aria-hidden="true"></a><span class="dv">1</span>&gt;test2.obj : error LNK2001: unresolved external symbol <span class="st">&quot;void __cdecl foo(void)&quot;</span> (?foo<span class="er">@@</span>YAXXZ)</span>
<span id="cb402-2"><a href="#cb402-2" aria-hidden="true"></a><span class="dv">1</span>&gt;test2.obj : error LNK2001: unresolved external symbol <span class="st">&quot;int x&quot;</span> (?x<span class="er">@@</span><span class="dv">3</span><span class="er">HA</span>)</span>
<span id="cb402-3"><a href="#cb402-3" aria-hidden="true"></a><span class="dv">1</span>&gt;test2.obj : error LNK2001: unresolved external symbol <span class="st">&quot;public: virtual __thiscall A::~A(void)&quot;</span> (??<span class="dv">1</span><span class="er">A@@</span>UAE<span class="er">@</span>XZ)</span>
<span id="cb402-4"><a href="#cb402-4" aria-hidden="true"></a><span class="dv">1</span>&gt;test2.obj : error LNK2001: unresolved external symbol <span class="st">&quot;public: virtual void __thiscall X::foo(void)&quot;</span> (?foo<span class="er">@</span>X<span class="er">@@</span>UAEXXZ)</span>
<span id="cb402-5"><a href="#cb402-5" aria-hidden="true"></a><span class="dv">1</span>&gt;...\test2.exe : fatal error LNK1120: <span class="dv">4</span> unresolved externals</span></code></pre></div>
<p>Common causes include:</p>
<ul>
<li>
<a href="https://stackoverflow.com/a/12574400/673730">Failure to link against appropriate libraries/object files or compile implementation files</a>
</li>
<li>
<a href="https://stackoverflow.com/a/12574403/673730">Declared and undefined variable or function.</a>
</li>
<li>
<a href="https://stackoverflow.com/a/12574407/673730">Common issues with class-type members</a>
</li>
<li>
<a href="https://stackoverflow.com/a/12574417/673730">Template implementations not visible.</a>
</li>
<li>
<a href="https://stackoverflow.com/a/12574420/673730">Symbols were defined in a C program and used in C++ code.</a>
</li>
<li>
<a href="https://stackoverflow.com/a/12574423/673730">Incorrectly importing/exporting methods/classes across modules/dll. (MSVS specific)</a>
</li>
<li>
<a href="https://stackoverflow.com/a/20358542/673730">Circular library dependency</a>
</li>
<li>
<a href="https://stackoverflow.com/questions/5259714/undefined-reference-to-winmain16/5260237
#5260237">undefined reference to <code>WinMain@16'&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://stackoverflow.com/a/24675715/1356926"&gt;Interdependent library order&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://stackoverflow.com/questions/14364362/visualstudio-project-with-multiple-sourcefiles-of-the-same-name"&gt;Multiple source files of the same name&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://stackoverflow.com/a/25744263/3747990"&gt;Mistyping or not including the .lib extension when using the</code> #pragma<code>(Microsoft Visual Studio)&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://stackoverflow.com/a/35891188/3747990"&gt;Problems with template friends&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://stackoverflow.com/a/36475406/3747990"&gt;Inconsistent</code>UNICODE` definitions</a>
</li>
</ul>
</section>
<section id="answer-2-score-169" class="level4">
<h4>Answer 2 (score 169)</h4>
<h5>
Class members:
</h2>
<h5>
A pure <code>virtual</code> destructor needs an implementation.
</h3>
<p>Declaring a destructor pure still requires you to define it (unlike a regular function):</p>
<div class="sourceCode" id="cb403"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb403-1"><a href="#cb403-1" aria-hidden="true"></a><span class="kw">struct</span> X</span>
<span id="cb403-2"><a href="#cb403-2" aria-hidden="true"></a>{</span>
<span id="cb403-3"><a href="#cb403-3" aria-hidden="true"></a>    <span class="kw">virtual</span> ~X() = <span class="dv">0</span>;</span>
<span id="cb403-4"><a href="#cb403-4" aria-hidden="true"></a>};</span>
<span id="cb403-5"><a href="#cb403-5" aria-hidden="true"></a><span class="kw">struct</span> Y : X</span>
<span id="cb403-6"><a href="#cb403-6" aria-hidden="true"></a>{</span>
<span id="cb403-7"><a href="#cb403-7" aria-hidden="true"></a>    ~Y() {}</span>
<span id="cb403-8"><a href="#cb403-8" aria-hidden="true"></a>};</span>
<span id="cb403-9"><a href="#cb403-9" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb403-10"><a href="#cb403-10" aria-hidden="true"></a>{</span>
<span id="cb403-11"><a href="#cb403-11" aria-hidden="true"></a>    Y y;</span>
<span id="cb403-12"><a href="#cb403-12" aria-hidden="true"></a>}</span>
<span id="cb403-13"><a href="#cb403-13" aria-hidden="true"></a><span class="co">//X::~X(){} //uncomment this line for successful definition</span></span></code></pre></div>
<p>This happens because base class destructors are called when the object is destroyed implicitly, so a definition is required.</p>
<h5>
<code>virtual</code> methods must either be implemented or defined as pure.
</h3>
<p>
This is similar to non-<code>virtual</code> methods with no definition, with the added reasoning that the pure declaration generates a dummy vtable and you might get the linker error without using the function:
</p>
<div class="sourceCode" id="cb404"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb404-1"><a href="#cb404-1" aria-hidden="true"></a><span class="kw">struct</span> X</span>
<span id="cb404-2"><a href="#cb404-2" aria-hidden="true"></a>{</span>
<span id="cb404-3"><a href="#cb404-3" aria-hidden="true"></a>    <span class="kw">virtual</span> <span class="dt">void</span> foo();</span>
<span id="cb404-4"><a href="#cb404-4" aria-hidden="true"></a>};</span>
<span id="cb404-5"><a href="#cb404-5" aria-hidden="true"></a><span class="kw">struct</span> Y : X</span>
<span id="cb404-6"><a href="#cb404-6" aria-hidden="true"></a>{</span>
<span id="cb404-7"><a href="#cb404-7" aria-hidden="true"></a>   <span class="dt">void</span> foo() {}</span>
<span id="cb404-8"><a href="#cb404-8" aria-hidden="true"></a>};</span>
<span id="cb404-9"><a href="#cb404-9" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb404-10"><a href="#cb404-10" aria-hidden="true"></a>{</span>
<span id="cb404-11"><a href="#cb404-11" aria-hidden="true"></a>   Y y; <span class="co">//linker error although there was no call to X::foo</span></span>
<span id="cb404-12"><a href="#cb404-12" aria-hidden="true"></a>}</span></code></pre></div>
<p>For this to work, declare <code>X::foo()</code> as pure:</p>
<div class="sourceCode" id="cb405"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb405-1"><a href="#cb405-1" aria-hidden="true"></a><span class="kw">struct</span> X</span>
<span id="cb405-2"><a href="#cb405-2" aria-hidden="true"></a>{</span>
<span id="cb405-3"><a href="#cb405-3" aria-hidden="true"></a>    <span class="kw">virtual</span> <span class="dt">void</span> foo() = <span class="dv">0</span>;</span>
<span id="cb405-4"><a href="#cb405-4" aria-hidden="true"></a>};</span></code></pre></div>
<h5>
Non-<code>virtual</code> class members
</h3>
<p>Some members need to be defined even if not used explicitly:</p>
<div class="sourceCode" id="cb406"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb406-1"><a href="#cb406-1" aria-hidden="true"></a><span class="kw">struct</span> A</span>
<span id="cb406-2"><a href="#cb406-2" aria-hidden="true"></a>{ </span>
<span id="cb406-3"><a href="#cb406-3" aria-hidden="true"></a>    ~A();</span>
<span id="cb406-4"><a href="#cb406-4" aria-hidden="true"></a>};</span></code></pre></div>
<p>The following would yield the error:</p>
<div class="sourceCode" id="cb407"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb407-1"><a href="#cb407-1" aria-hidden="true"></a>A a;      <span class="co">//destructor undefined</span></span></code></pre></div>
<p>The implementation can be inline, in the class definition itself:</p>
<div class="sourceCode" id="cb408"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb408-1"><a href="#cb408-1" aria-hidden="true"></a><span class="kw">struct</span> A</span>
<span id="cb408-2"><a href="#cb408-2" aria-hidden="true"></a>{ </span>
<span id="cb408-3"><a href="#cb408-3" aria-hidden="true"></a>    ~A() {}</span>
<span id="cb408-4"><a href="#cb408-4" aria-hidden="true"></a>};</span></code></pre></div>
<p>or outside:</p>
<div class="sourceCode" id="cb409"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb409-1"><a href="#cb409-1" aria-hidden="true"></a>A::~A() {}</span></code></pre></div>
<p>If the implementation is outside the class definition, but in a header, the methods have to be marked as <code>inline</code> to prevent a multiple definition.</p>
<p>All used member methods need to be defined if used.</p>
<h5>
A common mistake is forgetting to qualify the name:
</h3>
<div class="sourceCode" id="cb410"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb410-1"><a href="#cb410-1" aria-hidden="true"></a><span class="kw">struct</span> A</span>
<span id="cb410-2"><a href="#cb410-2" aria-hidden="true"></a>{</span>
<span id="cb410-3"><a href="#cb410-3" aria-hidden="true"></a>   <span class="dt">void</span> foo();</span>
<span id="cb410-4"><a href="#cb410-4" aria-hidden="true"></a>};</span>
<span id="cb410-5"><a href="#cb410-5" aria-hidden="true"></a></span>
<span id="cb410-6"><a href="#cb410-6" aria-hidden="true"></a><span class="dt">void</span> foo() {}</span>
<span id="cb410-7"><a href="#cb410-7" aria-hidden="true"></a></span>
<span id="cb410-8"><a href="#cb410-8" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb410-9"><a href="#cb410-9" aria-hidden="true"></a>{</span>
<span id="cb410-10"><a href="#cb410-10" aria-hidden="true"></a>   A a;</span>
<span id="cb410-11"><a href="#cb410-11" aria-hidden="true"></a>   a.foo();</span>
<span id="cb410-12"><a href="#cb410-12" aria-hidden="true"></a>}</span></code></pre></div>
<p>The definition should be</p>
<div class="sourceCode" id="cb411"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb411-1"><a href="#cb411-1" aria-hidden="true"></a><span class="dt">void</span> A::foo() {}</span></code></pre></div>
<h5>
<code>static</code> data members must be defined outside the class in a <strong>single translation unit</strong>:
</h3>
<div class="sourceCode" id="cb412"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb412-1"><a href="#cb412-1" aria-hidden="true"></a><span class="kw">struct</span> X</span>
<span id="cb412-2"><a href="#cb412-2" aria-hidden="true"></a>{</span>
<span id="cb412-3"><a href="#cb412-3" aria-hidden="true"></a>    <span class="at">static</span> <span class="dt">int</span> x;</span>
<span id="cb412-4"><a href="#cb412-4" aria-hidden="true"></a>};</span>
<span id="cb412-5"><a href="#cb412-5" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb412-6"><a href="#cb412-6" aria-hidden="true"></a>{</span>
<span id="cb412-7"><a href="#cb412-7" aria-hidden="true"></a>    <span class="dt">int</span> x = X::x;</span>
<span id="cb412-8"><a href="#cb412-8" aria-hidden="true"></a>}</span>
<span id="cb412-9"><a href="#cb412-9" aria-hidden="true"></a><span class="co">//int X::x; //uncomment this line to define X::x</span></span></code></pre></div>
<p>An initializer can be provided for a <code>static</code> <code>const</code> data member of integral or enumeration type within the class definition; however, odr-use of this member will still require a namespace scope definition as described above. C++11 allows initialization inside the class for all <code>static const</code> data members.</p>
</section>
<section id="answer-3-score-106" class="level4">
<h4>Answer 3 (score 106)</h4>
<h5>
Failure to link against appropriate libraries/object files or compile implementation files
</h3>
<p>
Commonly, each translation unit will generate an object file that contains the definitions of the symbols defined in that translation unit. To use those symbols, you have to link against those object files.
</p>
<p>Under <strong>gcc</strong> you would specify all object files that are to be linked together in the command line, or compile the implementation files together.</p>
<div class="sourceCode" id="cb413"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb413-1"><a href="#cb413-1" aria-hidden="true"></a>g++ -o test objectFile1.o objectFile2.o -lLibraryName</span></code></pre></div>
<p>The <code>libraryName</code> here is just the bare name of the library, without platform-specific additions. So e.g. on Linux library files are usually called <code>libfoo.so</code> but you’d only write <code>-lfoo</code>. On Windows that same file might be called <code>foo.lib</code>, but you’d use the same argument. You might have to add the directory where those files can be found using <code>-L‹directory›</code>. Make sure to not write a space after <code>-l</code> or <code>-L</code>.</p>
<p>For <strong>XCode</strong>: Add the User Header Search Paths -&gt; add the Library Search Path -&gt; drag and drop the actual library reference into the project folder.</p>
<p>
Under <strong>MSVS</strong>, files added to a project automatically have their object files linked together and a <code>lib</code> file would be generated (in common usage). To use the symbols in a separate project, you’d need to include the <code>lib</code> files in the project settings. This is done in the Linker section of the project properties, in <code>Input -&amp;gt; Additional Dependencies</code>. (the path to the <code>lib</code> file should be added in <code>Linker -&amp;gt; General -&amp;gt; Additional Library Directories</code>) When using a third-party library that is provided with a <code>lib</code> file, failure to do so usually results in the error.
</p>
<p>It can also happen that you forget to add the file to the compilation, in which case the object file won’t be generated. In <strong>gcc</strong> you’d add the files to the command line. In <strong>MSVS</strong> adding the file to the project will make it compile it automatically (albeit files can, manually, be individually excluded from the build).</p>
<p>In Windows programming, the tell-tale sign that you did not link a necessary library is that the name of the unresolved symbol begins with <code>__imp_</code>. Look up the name of the function in the documentation, and it should say which library you need to use. For example, MSDN puts the information in a box at the bottom of each function in a section called “Library”.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="struct-constructor-in-c-score-511554-in-2014" class="level3">
<h3>64: Struct Constructor in C++? (score <a href="https://stackoverflow.com/q/1127396.html">511554</a> in 2014)</h3>
<section id="question-61" class="level4">
<h4>Question</h4>
<p>Can a <code>struct</code> have a constructor in C++?</p>
<p>I have been trying to solve this problem but I am not getting the syntax.</p>
</section>
<section id="answer-2-score-437" class="level4">
<h4>Answer 2 (score 437)</h4>
<p>In C++ the only difference between a <code>class</code> and a <code>struct</code> is that members and base classes are private by default in classes, whereas they are public by default in structs.</p>
<p>So structs can have constructors, and the syntax is the same as for classes.</p>
</section>
<section id="answer-3-score-153" class="level4">
<h4>Answer 3 (score 153)</h4>
<div class="sourceCode" id="cb414"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb414-1"><a href="#cb414-1" aria-hidden="true"></a><span class="kw">struct</span> TestStruct {</span>
<span id="cb414-2"><a href="#cb414-2" aria-hidden="true"></a>        <span class="dt">int</span> id;</span>
<span id="cb414-3"><a href="#cb414-3" aria-hidden="true"></a>        TestStruct() : id(<span class="dv">42</span>)</span>
<span id="cb414-4"><a href="#cb414-4" aria-hidden="true"></a>        {</span>
<span id="cb414-5"><a href="#cb414-5" aria-hidden="true"></a>        }</span>
<span id="cb414-6"><a href="#cb414-6" aria-hidden="true"></a>};</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-to-convert-string-to-char-array-in-c-score-499222-in-2015" class="level3">
<h3>65: How to convert string to char array in C++? (score <a href="https://stackoverflow.com/q/13294067.html">499222</a> in 2015)</h3>
<section id="question-62" class="level4">
<h4>Question</h4>
<p>I would like to convert <code>string</code> to <code>char</code> array but not <code>char*</code>. I know how to convert string to <code>char*</code> (by using <code>malloc</code> or the way I posted it in my code) - but that’s not what I want. I simply want to convert <code>string</code> to <code>char[size]</code> array. Is it possible?</p>
<div class="sourceCode" id="cb415"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb415-1"><a href="#cb415-1" aria-hidden="true"></a></span>
<span id="cb415-2"><a href="#cb415-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb415-3"><a href="#cb415-3" aria-hidden="true"></a></span>
<span id="cb415-4"><a href="#cb415-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb415-5"><a href="#cb415-5" aria-hidden="true"></a></span>
<span id="cb415-6"><a href="#cb415-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb415-7"><a href="#cb415-7" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb415-8"><a href="#cb415-8" aria-hidden="true"></a></span>
<span id="cb415-9"><a href="#cb415-9" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb415-10"><a href="#cb415-10" aria-hidden="true"></a>{</span>
<span id="cb415-11"><a href="#cb415-11" aria-hidden="true"></a>    <span class="co">// char to string</span></span>
<span id="cb415-12"><a href="#cb415-12" aria-hidden="true"></a>    <span class="dt">char</span> tab[<span class="dv">4</span>];</span>
<span id="cb415-13"><a href="#cb415-13" aria-hidden="true"></a>    tab[<span class="dv">0</span>] = <span class="ch">&#39;c&#39;</span>;</span>
<span id="cb415-14"><a href="#cb415-14" aria-hidden="true"></a>    tab[<span class="dv">1</span>] = <span class="ch">&#39;a&#39;</span>;</span>
<span id="cb415-15"><a href="#cb415-15" aria-hidden="true"></a>    tab[<span class="dv">2</span>] = <span class="ch">&#39;t&#39;</span>;</span>
<span id="cb415-16"><a href="#cb415-16" aria-hidden="true"></a>    tab[<span class="dv">3</span>] = <span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span>;</span>
<span id="cb415-17"><a href="#cb415-17" aria-hidden="true"></a>    string tmp(tab);</span>
<span id="cb415-18"><a href="#cb415-18" aria-hidden="true"></a>    cout &lt;&lt; tmp &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb415-19"><a href="#cb415-19" aria-hidden="true"></a></span>
<span id="cb415-20"><a href="#cb415-20" aria-hidden="true"></a>    <span class="co">// string to char* - but thats not what I want</span></span>
<span id="cb415-21"><a href="#cb415-21" aria-hidden="true"></a></span>
<span id="cb415-22"><a href="#cb415-22" aria-hidden="true"></a>    <span class="dt">char</span> *c = <span class="kw">const_cast</span>&lt;<span class="dt">char</span>*&gt;(tmp.c_str());</span>
<span id="cb415-23"><a href="#cb415-23" aria-hidden="true"></a>    cout &lt;&lt; c &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb415-24"><a href="#cb415-24" aria-hidden="true"></a></span>
<span id="cb415-25"><a href="#cb415-25" aria-hidden="true"></a>    <span class="co">//string to char</span></span>
<span id="cb415-26"><a href="#cb415-26" aria-hidden="true"></a>    <span class="dt">char</span> tab2[<span class="dv">1024</span>];</span>
<span id="cb415-27"><a href="#cb415-27" aria-hidden="true"></a>    <span class="co">// ?</span></span>
<span id="cb415-28"><a href="#cb415-28" aria-hidden="true"></a></span>
<span id="cb415-29"><a href="#cb415-29" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb415-30"><a href="#cb415-30" aria-hidden="true"></a>}</span></code></pre></div>
</section>
<section id="answer-accepted-score-113" class="level4">
<h4>Answer accepted (score 113)</h4>
<p>Simplest way I can think of doing it is:</p>
<div class="sourceCode" id="cb416"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb416-1"><a href="#cb416-1" aria-hidden="true"></a>string temp = <span class="st">&quot;cat&quot;</span>;</span>
<span id="cb416-2"><a href="#cb416-2" aria-hidden="true"></a><span class="dt">char</span> tab2[<span class="dv">1024</span>];</span>
<span id="cb416-3"><a href="#cb416-3" aria-hidden="true"></a>strcpy(tab2, temp.c_str());</span></code></pre></div>
<p>For safety, you might prefer:</p>
<div class="sourceCode" id="cb417"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb417-1"><a href="#cb417-1" aria-hidden="true"></a>string temp = <span class="st">&quot;cat&quot;</span>;</span>
<span id="cb417-2"><a href="#cb417-2" aria-hidden="true"></a><span class="dt">char</span> tab2[<span class="dv">1024</span>];</span>
<span id="cb417-3"><a href="#cb417-3" aria-hidden="true"></a>strncpy(tab2, temp.c_str(), <span class="kw">sizeof</span>(tab2));</span>
<span id="cb417-4"><a href="#cb417-4" aria-hidden="true"></a>tab2[<span class="kw">sizeof</span>(tab2) - <span class="dv">1</span>] = <span class="dv">0</span>;</span></code></pre></div>
<p>or could be in this fashion:</p>
<div class="sourceCode" id="cb418"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb418-1"><a href="#cb418-1" aria-hidden="true"></a>string temp = <span class="st">&quot;cat&quot;</span>;</span>
<span id="cb418-2"><a href="#cb418-2" aria-hidden="true"></a><span class="dt">char</span> * tab2 = <span class="kw">new</span> <span class="dt">char</span> [temp.length()+<span class="dv">1</span>];</span>
<span id="cb418-3"><a href="#cb418-3" aria-hidden="true"></a>strcpy (tab2, temp.c_str());</span></code></pre></div>
</section>
<section id="answer-2-score-52" class="level4">
<h4>Answer 2 (score 52)</h4>
<p>Ok, i am shocked that no one really gave a good answer, now my turn. There are two cases;</p>
<ol>
<li>
<p>
A <strong>constant char array</strong> is good enough for you so you go with,
</p>
<div class="sourceCode" id="cb419"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb419-1"><a href="#cb419-1" aria-hidden="true"></a><span class="at">const</span> <span class="dt">char</span> *array = tmp.c_str();</span>
<span id="cb419-2"><a href="#cb419-2" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb419-3"><a href="#cb419-3" aria-hidden="true"></a>&lt;li&gt;&lt;p&gt;Or you &lt;strong&gt;need to modify&lt;/strong&gt; the <span class="dt">char</span> array so constant is <span class="kw">not</span> ok, then just go with <span class="kw">this</span> &lt;/p&gt;</span>
<span id="cb419-4"><a href="#cb419-4" aria-hidden="true"></a></span>
<span id="cb419-5"><a href="#cb419-5" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb419-6"><a href="#cb419-6" aria-hidden="true"></a><span class="dt">char</span> *array = &amp;tmp[<span class="dv">0</span>];</span>
<span id="cb419-7"><a href="#cb419-7" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb419-8"><a href="#cb419-8" aria-hidden="true"></a>&lt;/ol&gt;</span>
<span id="cb419-9"><a href="#cb419-9" aria-hidden="true"></a></span>
<span id="cb419-10"><a href="#cb419-10" aria-hidden="true"></a>Both of them are &lt;strong&gt;just assignment operations&lt;/strong&gt; <span class="kw">and</span> most of the time that is just what you need, <span class="cf">if</span> you really need a <span class="kw">new</span> copy then follow other fellows answers.  </span>
<span id="cb419-11"><a href="#cb419-11" aria-hidden="true"></a></span>
<span id="cb419-12"><a href="#cb419-12" aria-hidden="true"></a></span>
<span id="cb419-13"><a href="#cb419-13" aria-hidden="true"></a><span class="pp">#</span><span class="er">### Answer 3 (score 16)</span></span>
<span id="cb419-14"><a href="#cb419-14" aria-hidden="true"></a>Easiest way to <span class="cf">do</span> it would be <span class="kw">this</span>  </span>
<span id="cb419-15"><a href="#cb419-15" aria-hidden="true"></a></span>
<span id="cb419-16"><a href="#cb419-16" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb419-17"><a href="#cb419-17" aria-hidden="true"></a><span class="bu">std::</span>string myWord = <span class="st">&quot;myWord&quot;</span>;</span>
<span id="cb419-18"><a href="#cb419-18" aria-hidden="true"></a><span class="dt">char</span> myArray[myWord.size()+<span class="dv">1</span>];<span class="co">//as 1 char space for null is also required</span></span>
<span id="cb419-19"><a href="#cb419-19" aria-hidden="true"></a>strcpy(myArray, myWord.c_str());</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="convert-a-char-to-stdstring-score-498258-in-2018" class="level3">
<h3>66: convert a char* to std::string (score <a href="https://stackoverflow.com/q/1195675.html">498258</a> in 2018)</h3>
<section id="question-63" class="level4">
<h4>Question</h4>
<p>I need to use an <code>std::string</code> to store data retrieved by <code>fgets()</code>. To do this I need to convert the <code>char*</code> return value from <code>fgets()</code> into an <code>std::string</code> to store in an array. How can this be done?</p>
</section>
<section id="answer-accepted-score-332" class="level4">
<h4>Answer accepted (score 332)</h4>
<p><code>std::string</code> has a constructor for this:</p>
<div class="sourceCode" id="cb420"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb420-1"><a href="#cb420-1" aria-hidden="true"></a><span class="at">const</span> <span class="dt">char</span> *s = <span class="st">&quot;Hello, World!&quot;</span>;</span>
<span id="cb420-2"><a href="#cb420-2" aria-hidden="true"></a><span class="bu">std::</span>string str(s);</span></code></pre></div>
<p>Just make sure that your <code>char *</code> isn’t <code>NULL</code>, or else the behavior is undefined.</p>
</section>
<section id="answer-2-score-114" class="level4">
<h4>Answer 2 (score 114)</h4>
<p>If you already know size of the char*, use this instead</p>
<div class="sourceCode" id="cb421"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb421-1"><a href="#cb421-1" aria-hidden="true"></a><span class="dt">char</span>* data = ...;</span>
<span id="cb421-2"><a href="#cb421-2" aria-hidden="true"></a><span class="dt">int</span> size = ...;</span>
<span id="cb421-3"><a href="#cb421-3" aria-hidden="true"></a><span class="bu">std::</span>string myString(data, size);</span></code></pre></div>
<p>This doesn’t use strlen.</p>
<p>EDIT: If string variable already exists, use assign():</p>
<div class="sourceCode" id="cb422"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb422-1"><a href="#cb422-1" aria-hidden="true"></a><span class="bu">std::</span>string myString;</span>
<span id="cb422-2"><a href="#cb422-2" aria-hidden="true"></a><span class="dt">char</span>* data = ...;</span>
<span id="cb422-3"><a href="#cb422-3" aria-hidden="true"></a><span class="dt">int</span> size = ...;</span>
<span id="cb422-4"><a href="#cb422-4" aria-hidden="true"></a>myString.assign(data, size);</span></code></pre></div>
</section>
<section id="answer-3-score-28" class="level4">
<h4>Answer 3 (score 28)</h4>
<blockquote>
I need to use std::string to store data retrieved by fgets().
</blockquote>
<p>Why using <code>fgets()</code> when you are programming C++? Why not <code>std::getline()</code>?</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-to-compile-and-run-cc-in-a-unix-consolemac-terminal-score-496686-in-2018" class="level3">
<h3>67: How to compile and run C/C++ in a Unix console/Mac terminal? (score <a href="https://stackoverflow.com/q/221185.html">496686</a> in 2018)</h3>
<section id="question-64" class="level4">
<h4>Question</h4>
<p>How can I compile/run C or C++ in Unix console or a Mac terminal?</p>
<p>(I know it, forget it, and relearn it again. Time to write it down.)</p>
</section>
<section id="answer-accepted-score-173" class="level4">
<h4>Answer accepted (score 173)</h4>
<p>If it is a simple single source program:</p>
<div class="sourceCode" id="cb423"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb423-1"><a href="#cb423-1" aria-hidden="true"></a>make foo</span></code></pre></div>
<p>where the source file is foo.c or foo.cpp, etc.</p>
<p>You dont even need a makefile. Make has enough built-in rules to build your source file into an executable of the same name, minus extension.</p>
<p>Running the executable just built is the same as running any program - but you will most often need to specify the path to the executable as the shell will only search what is in <code>$PATH</code> to find executables, and most often that does not include the current directory (<code>.</code>).</p>
<p>So to run the built executable <code>foo</code>:</p>
<div class="sourceCode" id="cb424"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb424-1"><a href="#cb424-1" aria-hidden="true"></a>./foo</span></code></pre></div>
</section>
<section id="answer-2-score-107-1" class="level4">
<h4>Answer 2 (score 107)</h4>
<div class="sourceCode" id="cb425"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb425-1"><a href="#cb425-1" aria-hidden="true"></a>gcc main.cpp -o main.out  </span>
<span id="cb425-2"><a href="#cb425-2" aria-hidden="true"></a>./main.out</span></code></pre></div>
</section>
<section id="answer-3-score-67" class="level4">
<h4>Answer 3 (score 67)</h4>
<p>This is the command that works on all Unix machines… I use it on Linux/Ubuntu, but it works in OS X as well. Type the following command in <strong>Terminal.app</strong>.</p>
<div class="sourceCode" id="cb426"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb426-1"><a href="#cb426-1" aria-hidden="true"></a><span class="er">$</span> g++ -o lab21 iterative.cpp</span></code></pre></div>
<p><code>-o</code> is the letter O not zero</p>
<p><code>lab21</code> will be your executable file</p>
<p><code>iterative.cpp</code> is your c++ file</p>
<p>After you run that command type the following in terminal to run your program:</p>
<div class="sourceCode" id="cb427"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb427-1"><a href="#cb427-1" aria-hidden="true"></a><span class="er">$</span> ./lab21</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="appending-a-vector-to-a-vector-score-491976-in-2016" class="level3">
<h3>68: Appending a vector to a vector (score <a href="https://stackoverflow.com/q/2551775.html">491976</a> in 2016)</h3>
<section id="question-65" class="level4">
<h4>Question</h4>
<p>Assuming I have 2 standard vectors:</p>
<div class="sourceCode" id="cb428"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb428-1"><a href="#cb428-1" aria-hidden="true"></a>vector&lt;<span class="dt">int</span>&gt; a;</span>
<span id="cb428-2"><a href="#cb428-2" aria-hidden="true"></a>vector&lt;<span class="dt">int</span>&gt; b;</span></code></pre></div>
<p>Let’s also say the both have around 30 elements.</p>
<ul>
<li>
How do I add the vector b to the end of vector a?
</li>
</ul>
<p>The dirty way would be iterating through b and adding each element via <code>vector&amp;lt;int&amp;gt;::push_back()</code>, though I wouldn’t like to do that!</p>
</section>
<section id="answer-2-score-1107" class="level4">
<h4>Answer 2 (score 1107)</h4>
<div class="sourceCode" id="cb429"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb429-1"><a href="#cb429-1" aria-hidden="true"></a>a.insert(a.end(), b.begin(), b.end());</span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb430"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb430-1"><a href="#cb430-1" aria-hidden="true"></a>a.insert(<span class="bu">std::</span>end(a), <span class="bu">std::</span>begin(b), <span class="bu">std::</span>end(b));</span></code></pre></div>
<p>The second variant is a more generically applicable solution, as <code>b</code> could also be an array. However, it requires C++11. If you want to work with user-defined types, use ADL:</p>
<div class="sourceCode" id="cb431"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb431-1"><a href="#cb431-1" aria-hidden="true"></a><span class="kw">using</span> <span class="bu">std::</span>begin, <span class="bu">std::</span>end;</span>
<span id="cb431-2"><a href="#cb431-2" aria-hidden="true"></a>a.insert(end(a), begin(b), end(b));</span></code></pre></div>
</section>
<section id="answer-3-score-79-2" class="level4">
<h4>Answer 3 (score 79)</h4>
<div class="sourceCode" id="cb432"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb432-1"><a href="#cb432-1" aria-hidden="true"></a><span class="bu">std::</span>copy (b.begin(), b.end(), <span class="bu">std::</span>back_inserter(a));</span></code></pre></div>
<p>This can be used in case the items in vector a have no assignment operator (e.g. const member).</p>
<p>In all other cases this solution is ineffiecent compared to the above insert solution.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="difference-between-struct-and-typedef-struct-in-c-score-489010-in" class="level3">
<h3>69: Difference between ‘struct’ and ‘typedef struct’ in C++? (score <a href="https://stackoverflow.com/q/612328.html">489010</a> in )</h3>
<section id="question-66" class="level4">
<h4>Question</h4>
<p>In C++, is there any difference between:</p>
<div class="sourceCode" id="cb433"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb433-1"><a href="#cb433-1" aria-hidden="true"></a><span class="kw">struct</span> Foo { ... };</span></code></pre></div>
<p>and</p>
<div class="sourceCode" id="cb434"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb434-1"><a href="#cb434-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> { ... } Foo;</span></code></pre></div>
</section>
<section id="answer-accepted-score-1135" class="level4">
<h4>Answer accepted (score 1135)</h4>
<p>In C++, there is only a subtle difference. It’s a holdover from C, in which it makes a difference.</p>
<p>The C language standard (<a href="http://port70.net/~nsz/c/c89/c89-draft.txt" rel="noreferrer">C89 §3.1.2.3</a>, <a href="http://port70.net/~nsz/c/c99/n1256.html
#6.2.3" rel="noreferrer">C99 §6.2.3</a>, and <a href="http://port70.net/~nsz/c/c11/n1570.html#6.2.3" rel="noreferrer">C11 §6.2.3</a>) mandates separate namespaces for different categories of identifiers, including <em>tag identifiers</em> (for <code>struct</code>/<code>union</code>/<code>enum</code>) and <em>ordinary identifiers</em> (for <code>typedef</code> and other identifiers).</p>
<p>If you just said:</p>
<div class="sourceCode" id="cb435"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb435-1"><a href="#cb435-1" aria-hidden="true"></a><span class="kw">struct</span> Foo { ... };</span>
<span id="cb435-2"><a href="#cb435-2" aria-hidden="true"></a>Foo x;</span></code></pre></div>
<p>you would get a compiler error, because <code>Foo</code> is only defined in the tag namespace.</p>
<p>You’d have to declare it as:</p>
<div class="sourceCode" id="cb436"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb436-1"><a href="#cb436-1" aria-hidden="true"></a><span class="kw">struct</span> Foo x;</span></code></pre></div>
<p>Any time you want to refer to a <code>Foo</code>, you’d always have to call it a <code>struct Foo</code>. This gets annoying fast, so you can add a <code>typedef</code>:</p>
<div class="sourceCode" id="cb437"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb437-1"><a href="#cb437-1" aria-hidden="true"></a><span class="kw">struct</span> Foo { ... };</span>
<span id="cb437-2"><a href="#cb437-2" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> Foo Foo;</span></code></pre></div>
<p>Now <code>struct Foo</code> (in the tag namespace) and just plain <code>Foo</code> (in the ordinary identifier namespace) both refer to the same thing, and you can freely declare objects of type <code>Foo</code> without the <code>struct</code> keyword.</p>
<hr>
<p>The construct:</p>
<div class="sourceCode" id="cb438"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb438-1"><a href="#cb438-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> Foo { ... } Foo;</span></code></pre></div>
<p>is just an abbreviation for the declaration and <code>typedef</code>.</p>
<hr>
<p>Finally,</p>
<div class="sourceCode" id="cb439"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb439-1"><a href="#cb439-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> { ... } Foo;</span></code></pre></div>
<p>declares an anonymous structure and creates a <code>typedef</code> for it. Thus, with this construct, it doesn’t have a name in the tag namespace, only a name in the typedef namespace. This means it also cannot be forward-declared. <em>If you want to make a forward declaration, you have to give it a name in the tag namespace</em>.</p>
<hr>
<p>In C++, all <code>struct</code>/<code>union</code>/<code>enum</code>/<code>class</code> declarations act like they are implicitly <code>typedef</code>’ed, as long as the name is not hidden by another declaration with the same name. See <a href="https://stackoverflow.com/questions/612328/difference-between-struct-and-typedef-struct-in-c/612476
#612476">Michael Burr’s answer</a> for the full details.</p>
</section>
<section id="answer-2-score-220" class="level4">
<h4>Answer 2 (score 220)</h4>
<p>In <a href="http://drdobbs.com/article/print?articleId=184403396" rel="noreferrer">this DDJ article</a>, Dan Saks explains one small area where bugs can creep through if you do not typedef your structs (and classes!):</p>
<blockquote>
<p>
If you want, you can imagine that C++ generates a typedef for every tag name, such as
</p>
<div class="sourceCode" id="cb440"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb440-1"><a href="#cb440-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">class</span> string string;</span></code></pre></div>
<p>
Unfortunately, this is not entirely accurate. I wish it were that simple, but it’s not. C++ can’t generate such typedefs for structs, unions, or enums without introducing incompatibilities with C.
</p>
<p>
For example, suppose a C program declares both a function and a struct named status:
</p>
<div class="sourceCode" id="cb441"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb441-1"><a href="#cb441-1" aria-hidden="true"></a><span class="dt">int</span> status(); <span class="kw">struct</span> status;</span></code></pre></div>
<p>
Again, this may be bad practice, but it is C. In this program, status (by itself) refers to the function; struct status refers to the type.
</p>
<p>
If C++ did automatically generate typedefs for tags, then when you compiled this program as C++, the compiler would generate:
</p>
<div class="sourceCode" id="cb442"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb442-1"><a href="#cb442-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> status status;</span></code></pre></div>
<p>
Unfortunately, this type name would conflict with the function name, and the program would not compile. That’s why C++ can’t simply generate a typedef for each tag.
</p>
<p>
In C++, tags act just like typedef names, except that a program can declare an object, function, or enumerator with the same name and the same scope as a tag. In that case, the object, function, or enumerator name hides the tag name. The program can refer to the tag name only by using the keyword class, struct, union, or enum (as appropriate) in front of the tag name. A type name consisting of one of these keywords followed by a tag is an elaborated-type-specifier. For instance, struct status and enum month are elaborated-type-specifiers.
</p>
<p>Thus, a C program that contains both:</p>
<div class="sourceCode" id="cb443"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb443-1"><a href="#cb443-1" aria-hidden="true"></a><span class="dt">int</span> status(); <span class="kw">struct</span> status;</span></code></pre></div>
<p>
behaves the same when compiled as C++. The name status alone refers to the function. The program can refer to the type only by using the elaborated-type-specifier struct status.
</p>
<p>
So how does this allow bugs to creep into programs? Consider the program in <a href="http://drdobbs.com/cpp/184403396?pgno=1" rel="noreferrer">Listing 1</a>. This program defines a class foo with a default constructor, and a conversion operator that converts a foo object to char const *. The expression
</p>
<div class="sourceCode" id="cb444"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb444-1"><a href="#cb444-1" aria-hidden="true"></a>p = foo();</span></code></pre></div>
<p>
in main should construct a foo object and apply the conversion operator. The subsequent output statement
</p>
<div class="sourceCode" id="cb445"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb445-1"><a href="#cb445-1" aria-hidden="true"></a>cout &lt;&lt; p &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span></code></pre></div>
<p>
should display class foo, but it doesn’t. It displays function foo.
</p>
<p>
This surprising result occurs because the program includes header lib.h shown in <a href="http://drdobbs.com/cpp/184403396?pgno=2" rel="noreferrer">Listing 2</a>. This header defines a function also named foo. The function name foo hides the class name foo, so the reference to foo in main refers to the function, not the class. main can refer to the class only by using an elaborated-type-specifier, as in
</p>
<div class="sourceCode" id="cb446"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb446-1"><a href="#cb446-1" aria-hidden="true"></a>p = <span class="kw">class</span> foo();</span></code></pre></div>
<p>
The way to avoid such confusion throughout the program is to add the following typedef for the class name foo:
</p>
<div class="sourceCode" id="cb447"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb447-1"><a href="#cb447-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">class</span> foo foo;</span></code></pre></div>
<p>
immediately before or after the class definition. This typedef causes a conflict between the type name foo and the function name foo (from the library) that will trigger a compile-time error.
</p>
<p>
I know of no one who actually writes these typedefs as a matter of course. It requires a lot of discipline. Since the incidence of errors such as the one in <a href="http://drdobbs.com/cpp/184403396?pgno=1" rel="noreferrer">Listing 1</a> is probably pretty small, you many never run afoul of this problem. But if an error in your software might cause bodily injury, then you should write the typedefs no matter how unlikely the error.
</p>
<p>
I can’t imagine why anyone would ever want to hide a class name with a function or object name in the same scope as the class. The hiding rules in C were a mistake, and they should not have been extended to classes in C++. Indeed, you can correct the mistake, but it requires extra programming discipline and effort that should not be necessary.
</p>
</blockquote>
</section>
<section id="answer-3-score-62" class="level4">
<h4>Answer 3 (score 62)</h4>
<p>One more important difference: <code>typedef</code>s cannot be forward declared. So for the <code>typedef</code> option you must <code>#include</code> the file containing the <code>typedef</code>, meaning everything that <code>#include</code>s your <code>.h</code> also includes that file whether it directly needs it or not, and so on. It can definitely impact your build times on larger projects.</p>
<p>Without the <code>typedef</code>, in some cases you can just add a forward declaration of <code>struct Foo;</code> at the top of your <code>.h</code> file, and only <code>#include</code> the struct definition in your <code>.cpp</code> file.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-to-find-if-a-given-key-exists-in-a-c-stdmap-score-487253-in-2017" class="level3">
<h3>70: How to find if a given key exists in a C++ std::map (score <a href="https://stackoverflow.com/q/1939953.html">487253</a> in 2017)</h3>
<section id="question-67" class="level4">
<h4>Question</h4>
<p>I’m trying to check if a given key is in a map and somewhat can’t do it:</p>
<div class="sourceCode" id="cb448"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb448-1"><a href="#cb448-1" aria-hidden="true"></a><span class="kw">typedef</span> map&lt;string,string&gt;::iterator mi;</span>
<span id="cb448-2"><a href="#cb448-2" aria-hidden="true"></a>map&lt;string, string&gt; m;</span>
<span id="cb448-3"><a href="#cb448-3" aria-hidden="true"></a>m.insert(make_pair(<span class="st">&quot;f&quot;</span>,<span class="st">&quot;++--&quot;</span>));</span>
<span id="cb448-4"><a href="#cb448-4" aria-hidden="true"></a>pair&lt;mi,mi&gt; p = m.equal_range(<span class="st">&quot;f&quot;</span>);<span class="co">//I&#39;m not sure if equal_range does what I want</span></span>
<span id="cb448-5"><a href="#cb448-5" aria-hidden="true"></a>cout &lt;&lt; p.first;<span class="co">//I&#39;m getting error here</span></span></code></pre></div>
<p>so how can I print what is in p?</p>
</section>
<section id="answer-accepted-score-637" class="level4">
<h4>Answer accepted (score 637)</h4>
<p>Use <a href="http://en.cppreference.com/w/cpp/container/map/find" rel="noreferrer"><code>map::find</code></a></p>
<div class="sourceCode" id="cb449"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb449-1"><a href="#cb449-1" aria-hidden="true"></a><span class="cf">if</span> ( m.find(<span class="st">&quot;f&quot;</span>) == m.end() ) {</span>
<span id="cb449-2"><a href="#cb449-2" aria-hidden="true"></a>  <span class="co">// not found</span></span>
<span id="cb449-3"><a href="#cb449-3" aria-hidden="true"></a>} <span class="cf">else</span> {</span>
<span id="cb449-4"><a href="#cb449-4" aria-hidden="true"></a>  <span class="co">// found</span></span>
<span id="cb449-5"><a href="#cb449-5" aria-hidden="true"></a>}</span></code></pre></div>
</section>
<section id="answer-2-score-285-1" class="level4">
<h4>Answer 2 (score 285)</h4>
<p>To check if a particular key in the map exists, use the <code>count</code> member function in one of the following ways:</p>
<div class="sourceCode" id="cb450"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb450-1"><a href="#cb450-1" aria-hidden="true"></a>m.count(key) &gt; <span class="dv">0</span></span>
<span id="cb450-2"><a href="#cb450-2" aria-hidden="true"></a>m.count(key) == <span class="dv">1</span></span>
<span id="cb450-3"><a href="#cb450-3" aria-hidden="true"></a>m.count(key) != <span class="dv">0</span></span></code></pre></div>
<p>The <a href="http://www.cplusplus.com/reference/map/map/find/" rel="noreferrer">documentation</a> for <code>map::find</code> says: “Another member function, <code>map::count</code>, can be used to just check whether a particular key exists.”</p>
<p>The <a href="http://www.cplusplus.com/reference/map/map/count/" rel="noreferrer">documentation</a> for <code>map::count</code> says: “Because all elements in a map container are unique, the function can only return 1 (if the element is found) or zero (otherwise).”</p>
<p>To retrieve a value from the map via a key that you know to exist, use <a href="http://www.cplusplus.com/reference/map/map/at/" rel="noreferrer">map::at</a>:</p>
<div class="sourceCode" id="cb451"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb451-1"><a href="#cb451-1" aria-hidden="true"></a>value = m.at(key)</span></code></pre></div>
<p>Unlike <a href="http://www.cplusplus.com/reference/map/map/operator%5B%5D/" rel="noreferrer">map::operator[]</a>, <code>map::at</code> will not create a new key in the map if the specified key does not exist.</p>
</section>
<section id="answer-3-score-35-1" class="level4">
<h4>Answer 3 (score 35)</h4>
<p>You can use <code>.find()</code>:</p>
<div class="sourceCode" id="cb452"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb452-1"><a href="#cb452-1" aria-hidden="true"></a>map&lt;string,string&gt;::iterator i = m.find(<span class="st">&quot;f&quot;</span>);</span>
<span id="cb452-2"><a href="#cb452-2" aria-hidden="true"></a></span>
<span id="cb452-3"><a href="#cb452-3" aria-hidden="true"></a><span class="cf">if</span> (i == m.end()) { <span class="co">/* Not found */</span> }</span>
<span id="cb452-4"><a href="#cb452-4" aria-hidden="true"></a><span class="cf">else</span> { <span class="co">/* Found, i-&gt;first is f, i-&gt;second is ++-- */</span> }</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-can-i-profile-c-code-running-on-linux-score-485365-in-2018" class="level3">
<h3>71: How can I profile C++ code running on Linux? (score <a href="https://stackoverflow.com/q/375913.html">485365</a> in 2018)</h3>
<section id="question-68" class="level4">
<h4>Question</h4>
<p>I have a C++ application, running on Linux, which I’m in the process of optimizing. How can I pinpoint which areas of my code are running slowly?</p>
</section>
<section id="answer-accepted-score-1349" class="level4">
<h4>Answer accepted (score 1349)</h4>
<p>If your goal is to use a profiler, use one of the suggested ones.</p>
<p>However, if you’re in a hurry and you can manually interrupt your program under the debugger while it’s being subjectively slow, there’s a simple way to find performance problems.</p>
<p>
Just halt it several times, and each time look at the call stack. If there is some code that is wasting some percentage of the time, 20% or 50% or whatever, that is the probability that you will catch it in the act on each sample. So that is roughly the percentage of samples on which you will see it. There is no educated guesswork required. If you do have a guess as to what the problem is, this will prove or disprove it.
</p>
<p>
You may have multiple performance problems of different sizes. If you clean out any one of them, the remaining ones will take a larger percentage, and be easier to spot, on subsequent passes. This <em>magnification effect</em>, when compounded over multiple problems, can lead to truly massive speedup factors.
</p>
<p>Caveat: Programmers tend to be skeptical of this technique unless they’ve used it themselves. They will say that profilers give you this information, but that is only true if they sample the entire call stack, and then let you examine a random set of samples. (The summaries are where the insight is lost.) Call graphs don’t give you the same information, because</p>
<ol>
<li>
they don’t summarize at the instruction level, and
</li>
<li>
they give confusing summaries in the presence of recursion.
</li>
</ol>
<p>
They will also say it only works on toy programs, when actually it works on any program, and it seems to work better on bigger programs, because they tend to have more problems to find. They will say it sometimes finds things that aren’t problems, but that is only true if you see something <em>once</em>. If you see a problem on more than one sample, it is real.
</p>
<p>P.S. This can also be done on multi-thread programs if there is a way to collect call-stack samples of the thread pool at a point in time, as there is in Java.</p>
<p>P.P.S As a rough generality, the more layers of abstraction you have in your software, the more likely you are to find that that is the cause of performance problems (and the opportunity to get speedup).</p>
<p>Added: It might not be obvious, but the stack sampling technique works equally well in the presence of recursion. The reason is that the time that would be saved by removal of an instruction is approximated by the fraction of samples containing it, regardless of the number of times it may occur within a sample.</p>
<p>
Another objection I often hear is: “<em>It will stop someplace random, and it will miss the real problem</em>”. This comes from having a prior concept of what the real problem is. A key property of performance problems is that they defy expectations. Sampling tells you something is a problem, and your first reaction is disbelief. That is natural, but you can be sure if it finds a problem it is real, and vice-versa.
</p>
<p>ADDED: Let me make a Bayesian explanation of how it works. Suppose there is some instruction <code>I</code> (call or otherwise) which is on the call stack some fraction <code>f</code> of the time (and thus costs that much). For simplicity, suppose we don’t know what <code>f</code> is, but assume it is either 0.1, 0.2, 0.3, … 0.9, 1.0, and the prior probability of each of these possibilities is 0.1, so all of these costs are equally likely a-priori.</p>
<p>Then suppose we take just 2 stack samples, and we see instruction <code>I</code> on both samples, designated observation <code>o=2/2</code>. This gives us new estimates of the frequency <code>f</code> of <code>I</code>, according to this:</p>
<div class="sourceCode" id="cb453"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb453-1"><a href="#cb453-1" aria-hidden="true"></a>Prior                                    </span>
<span id="cb453-2"><a href="#cb453-2" aria-hidden="true"></a>P(f=x) x  P(o=<span class="dv">2</span>/<span class="dv">2</span>|f=x) P(o=<span class="dv">2</span>/<span class="dv">2</span>&amp;&amp;f=x)  P(o=<span class="dv">2</span>/<span class="dv">2</span>&amp;&amp;f &gt;= x)  P(f &gt;= x | o=<span class="dv">2</span>/<span class="dv">2</span>)</span>
<span id="cb453-3"><a href="#cb453-3" aria-hidden="true"></a></span>
<span id="cb453-4"><a href="#cb453-4" aria-hidden="true"></a><span class="fl">0.1</span>    <span class="dv">1</span>     <span class="dv">1</span>             <span class="fl">0.1</span>          <span class="fl">0.1</span>            <span class="fl">0.25974026</span></span>
<span id="cb453-5"><a href="#cb453-5" aria-hidden="true"></a><span class="fl">0.1</span>    <span class="fl">0.9</span>   <span class="fl">0.81</span>          <span class="fl">0.081</span>        <span class="fl">0.181</span>          <span class="fl">0.47012987</span></span>
<span id="cb453-6"><a href="#cb453-6" aria-hidden="true"></a><span class="fl">0.1</span>    <span class="fl">0.8</span>   <span class="fl">0.64</span>          <span class="fl">0.064</span>        <span class="fl">0.245</span>          <span class="fl">0.636363636</span></span>
<span id="cb453-7"><a href="#cb453-7" aria-hidden="true"></a><span class="fl">0.1</span>    <span class="fl">0.7</span>   <span class="fl">0.49</span>          <span class="fl">0.049</span>        <span class="fl">0.294</span>          <span class="fl">0.763636364</span></span>
<span id="cb453-8"><a href="#cb453-8" aria-hidden="true"></a><span class="fl">0.1</span>    <span class="fl">0.6</span>   <span class="fl">0.36</span>          <span class="fl">0.036</span>        <span class="fl">0.33</span>           <span class="fl">0.857142857</span></span>
<span id="cb453-9"><a href="#cb453-9" aria-hidden="true"></a><span class="fl">0.1</span>    <span class="fl">0.5</span>   <span class="fl">0.25</span>          <span class="fl">0.025</span>        <span class="fl">0.355</span>          <span class="fl">0.922077922</span></span>
<span id="cb453-10"><a href="#cb453-10" aria-hidden="true"></a><span class="fl">0.1</span>    <span class="fl">0.4</span>   <span class="fl">0.16</span>          <span class="fl">0.016</span>        <span class="fl">0.371</span>          <span class="fl">0.963636364</span></span>
<span id="cb453-11"><a href="#cb453-11" aria-hidden="true"></a><span class="fl">0.1</span>    <span class="fl">0.3</span>   <span class="fl">0.09</span>          <span class="fl">0.009</span>        <span class="fl">0.38</span>           <span class="fl">0.987012987</span></span>
<span id="cb453-12"><a href="#cb453-12" aria-hidden="true"></a><span class="fl">0.1</span>    <span class="fl">0.2</span>   <span class="fl">0.04</span>          <span class="fl">0.004</span>        <span class="fl">0.384</span>          <span class="fl">0.997402597</span></span>
<span id="cb453-13"><a href="#cb453-13" aria-hidden="true"></a><span class="fl">0.1</span>    <span class="fl">0.1</span>   <span class="fl">0.01</span>          <span class="fl">0.001</span>        <span class="fl">0.385</span>          <span class="dv">1</span></span>
<span id="cb453-14"><a href="#cb453-14" aria-hidden="true"></a></span>
<span id="cb453-15"><a href="#cb453-15" aria-hidden="true"></a>                  P(o=<span class="dv">2</span>/<span class="dv">2</span>) <span class="fl">0.385</span>                </span></code></pre></div>
<p>The last column says that, for example, the probability that <code>f</code> &gt;= 0.5 is 92%, up from the prior assumption of 60%.</p>
<p>Suppose the prior assumptions are different. Suppose we assume P(f=0.1) is .991 (nearly certain), and all the other possibilities are almost impossible (0.001). In other words, our prior certainty is that <code>I</code> is cheap. Then we get:</p>
<div class="sourceCode" id="cb454"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb454-1"><a href="#cb454-1" aria-hidden="true"></a>Prior                                    </span>
<span id="cb454-2"><a href="#cb454-2" aria-hidden="true"></a>P(f=x) x  P(o=<span class="dv">2</span>/<span class="dv">2</span>|f=x) P(o=<span class="dv">2</span>/<span class="dv">2</span>&amp;&amp; f=x)  P(o=<span class="dv">2</span>/<span class="dv">2</span>&amp;&amp;f &gt;= x)  P(f &gt;= x | o=<span class="dv">2</span>/<span class="dv">2</span>)</span>
<span id="cb454-3"><a href="#cb454-3" aria-hidden="true"></a></span>
<span id="cb454-4"><a href="#cb454-4" aria-hidden="true"></a><span class="fl">0.001</span>  <span class="dv">1</span>    <span class="dv">1</span>              <span class="fl">0.001</span>        <span class="fl">0.001</span>          <span class="fl">0.072727273</span></span>
<span id="cb454-5"><a href="#cb454-5" aria-hidden="true"></a><span class="fl">0.001</span>  <span class="fl">0.9</span>  <span class="fl">0.81</span>           <span class="fl">0.00081</span>      <span class="fl">0.00181</span>        <span class="fl">0.131636364</span></span>
<span id="cb454-6"><a href="#cb454-6" aria-hidden="true"></a><span class="fl">0.001</span>  <span class="fl">0.8</span>  <span class="fl">0.64</span>           <span class="fl">0.00064</span>      <span class="fl">0.00245</span>        <span class="fl">0.178181818</span></span>
<span id="cb454-7"><a href="#cb454-7" aria-hidden="true"></a><span class="fl">0.001</span>  <span class="fl">0.7</span>  <span class="fl">0.49</span>           <span class="fl">0.00049</span>      <span class="fl">0.00294</span>        <span class="fl">0.213818182</span></span>
<span id="cb454-8"><a href="#cb454-8" aria-hidden="true"></a><span class="fl">0.001</span>  <span class="fl">0.6</span>  <span class="fl">0.36</span>           <span class="fl">0.00036</span>      <span class="fl">0.0033</span>         <span class="fl">0.24</span></span>
<span id="cb454-9"><a href="#cb454-9" aria-hidden="true"></a><span class="fl">0.001</span>  <span class="fl">0.5</span>  <span class="fl">0.25</span>           <span class="fl">0.00025</span>      <span class="fl">0.00355</span>        <span class="fl">0.258181818</span></span>
<span id="cb454-10"><a href="#cb454-10" aria-hidden="true"></a><span class="fl">0.001</span>  <span class="fl">0.4</span>  <span class="fl">0.16</span>           <span class="fl">0.00016</span>      <span class="fl">0.00371</span>        <span class="fl">0.269818182</span></span>
<span id="cb454-11"><a href="#cb454-11" aria-hidden="true"></a><span class="fl">0.001</span>  <span class="fl">0.3</span>  <span class="fl">0.09</span>           <span class="fl">0.00009</span>      <span class="fl">0.0038</span>         <span class="fl">0.276363636</span></span>
<span id="cb454-12"><a href="#cb454-12" aria-hidden="true"></a><span class="fl">0.001</span>  <span class="fl">0.2</span>  <span class="fl">0.04</span>           <span class="fl">0.00004</span>      <span class="fl">0.00384</span>        <span class="fl">0.279272727</span></span>
<span id="cb454-13"><a href="#cb454-13" aria-hidden="true"></a><span class="fl">0.991</span>  <span class="fl">0.1</span>  <span class="fl">0.01</span>           <span class="fl">0.00991</span>      <span class="fl">0.01375</span>        <span class="dv">1</span></span>
<span id="cb454-14"><a href="#cb454-14" aria-hidden="true"></a></span>
<span id="cb454-15"><a href="#cb454-15" aria-hidden="true"></a>                  P(o=<span class="dv">2</span>/<span class="dv">2</span>) <span class="fl">0.01375</span>                </span></code></pre></div>
<p>Now it says P(f &gt;= 0.5) is 26%, up from the prior assumption of 0.6%. So Bayes allows us to update our estimate of the probable cost of <code>I</code>. If the amount of data is small, it doesn’t tell us accurately what the cost is, only that it is big enough to be worth fixing.</p>
<p>
Yet another way to look at it is called the <a href="http://en.wikipedia.org/wiki/Rule_of_succession" rel="noreferrer">Rule Of Succession</a>. If you flip a coin 2 times, and it comes up heads both times, what does that tell you about the probable weighting of the coin? The respected way to answer is to say that it’s a Beta distribution, with average value (number of hits + 1) / (number of tries + 2) = (2+1)/(2+2) = 75%.
</p>
<p>(The key is that we see <code>I</code> more than once. If we only see it once, that doesn’t tell us much except that <code>f</code> &gt; 0.)</p>
<p>So, even a very small number of samples can tell us a lot about the cost of instructions that it sees. (And it will see them with a frequency, on average, proportional to their cost. If <code>n</code> samples are taken, and <code>f</code> is the cost, then <code>I</code> will appear on <code>nf+/-sqrt(nf(1-f))</code> samples. Example, <code>n=10</code>, <code>f=0.3</code>, that is <code>3+/-1.4</code> samples.)</p>
<hr>
<p>
ADDED, to give an intuitive feel for the difference between measuring and random stack sampling:<br> There are profilers now that sample the stack, even on wall-clock time, but <em>what comes out</em> is measurements (or hot path, or hot spot, from which a “bottleneck” can easily hide). What they don’t show you (and they easily could) is the actual samples themselves. And if your goal is to <em>find</em> the bottleneck, the number of them you need to see is, <em>on average</em>, 2 divided by the fraction of time it takes. So if it takes 30% of time, 2/.3 = 6.7 samples, on average, will show it, and the chance that 20 samples will show it is 99.2%.
</p>
<p>
Here is an off-the-cuff illustration of the difference between examining measurements and examining stack samples. The bottleneck could be one big blob like this, or numerous small ones, it makes no difference.
</p>
<p><a href="https://i.stack.imgur.com/FpWuS.png" rel="noreferrer"><img src="https://i.stack.imgur.com/FpWuS.png" alt="enter image description here"></a></p>
<p>
Measurement is horizontal; it tells you what fraction of time specific routines take. Sampling is vertical. If there is any way to avoid what the whole program is doing at that moment, <em>and if you see it on a second sample</em>, you’ve found the bottleneck. That’s what makes the difference - seeing the whole reason for the time being spent, not just how much.
</p>
</section>
<section id="answer-2-score-547" class="level4">
<h4>Answer 2 (score 547)</h4>
<p>You can use <a href="http://en.wikipedia.org/wiki/Valgrind" rel="noreferrer">Valgrind</a> with the following options</p>
<div class="sourceCode" id="cb455"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb455-1"><a href="#cb455-1" aria-hidden="true"></a>valgrind --tool=callgrind ./(Your binary)</span></code></pre></div>
<p>It will generate a file called <code>callgrind.out.x</code>. You can then use <code>kcachegrind</code> tool to read this file. It will give you a graphical analysis of things with results like which lines cost how much.</p>
</section>
<section id="answer-3-score-332" class="level4">
<h4>Answer 3 (score 332)</h4>
<p>I assume you’re using GCC. The standard solution would be to profile with <a href="http://www.math.utah.edu/docs/info/gprof_toc.html" rel="noreferrer">gprof</a>.</p>
<p>Be sure to add <code>-pg</code> to compilation before profiling:</p>
<div class="sourceCode" id="cb456"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb456-1"><a href="#cb456-1" aria-hidden="true"></a>cc -o myprog myprog.c utils.c -g -pg</span></code></pre></div>
<p>I haven’t tried it yet but I’ve heard good things about <a href="https://github.com/gperftools/gperftools" rel="noreferrer">google-perftools</a>. It is definitely worth a try.</p>
<p>Related question <a href="https://stackoverflow.com/questions/56672/how-do-you-profile-your-code">here</a>.</p>
<p>A few other buzzwords if <code>gprof</code> does not do the job for you: <a href="http://en.wikipedia.org/wiki/Valgrind" rel="noreferrer">Valgrind</a>, Intel <a href="http://en.wikipedia.org/wiki/VTune" rel="noreferrer">VTune</a>, Sun <a href="http://en.wikipedia.org/wiki/DTrace" rel="noreferrer">DTrace</a>.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="read-whole-ascii-file-into-c-stdstring-score-478956-in-2014" class="level3">
<h3>72: Read whole ASCII file into C++ std::string (score <a href="https://stackoverflow.com/q/2602013.html">478956</a> in 2014)</h3>
<section id="question-69" class="level4">
<h4>Question</h4>
<p>I need to read a whole file into memory and place it in a C++ <code>std::string</code>.</p>
<p>If I were to read it into a <code>char[]</code>, the answer would be very simple:</p>
<div class="sourceCode" id="cb457"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb457-1"><a href="#cb457-1" aria-hidden="true"></a><span class="bu">std::</span>ifstream t;</span>
<span id="cb457-2"><a href="#cb457-2" aria-hidden="true"></a><span class="dt">int</span> length;</span>
<span id="cb457-3"><a href="#cb457-3" aria-hidden="true"></a>t.open(<span class="st">&quot;file.txt&quot;</span>);      <span class="co">// open input file</span></span>
<span id="cb457-4"><a href="#cb457-4" aria-hidden="true"></a>t.seekg(<span class="dv">0</span>, <span class="bu">std::</span>ios<span class="bu">::</span>end);    <span class="co">// go to the end</span></span>
<span id="cb457-5"><a href="#cb457-5" aria-hidden="true"></a>length = t.tellg();           <span class="co">// report location (this is the length)</span></span>
<span id="cb457-6"><a href="#cb457-6" aria-hidden="true"></a>t.seekg(<span class="dv">0</span>, <span class="bu">std::</span>ios<span class="bu">::</span>beg);    <span class="co">// go back to the beginning</span></span>
<span id="cb457-7"><a href="#cb457-7" aria-hidden="true"></a>buffer = <span class="kw">new</span> <span class="dt">char</span>[length];    <span class="co">// allocate memory for a buffer of appropriate dimension</span></span>
<span id="cb457-8"><a href="#cb457-8" aria-hidden="true"></a>t.read(buffer, length);       <span class="co">// read the whole file into the buffer</span></span>
<span id="cb457-9"><a href="#cb457-9" aria-hidden="true"></a>t.close();                    <span class="co">// close file handle</span></span>
<span id="cb457-10"><a href="#cb457-10" aria-hidden="true"></a></span>
<span id="cb457-11"><a href="#cb457-11" aria-hidden="true"></a><span class="co">// ... Do stuff with buffer here ...</span></span></code></pre></div>
<p>Now, I want to do the exact same thing, but using a <code>std::string</code> instead of a <code>char[]</code>. I want to avoid loops, i.e. I <strong>don’t</strong> want to:</p>
<div class="sourceCode" id="cb458"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb458-1"><a href="#cb458-1" aria-hidden="true"></a><span class="bu">std::</span>ifstream t;</span>
<span id="cb458-2"><a href="#cb458-2" aria-hidden="true"></a>t.open(<span class="st">&quot;file.txt&quot;</span>);</span>
<span id="cb458-3"><a href="#cb458-3" aria-hidden="true"></a><span class="bu">std::</span>string buffer;</span>
<span id="cb458-4"><a href="#cb458-4" aria-hidden="true"></a><span class="bu">std::</span>string line;</span>
<span id="cb458-5"><a href="#cb458-5" aria-hidden="true"></a><span class="cf">while</span>(t){</span>
<span id="cb458-6"><a href="#cb458-6" aria-hidden="true"></a><span class="bu">std::</span>getline(t, line);</span>
<span id="cb458-7"><a href="#cb458-7" aria-hidden="true"></a><span class="co">// ... Append line to buffer and go on</span></span>
<span id="cb458-8"><a href="#cb458-8" aria-hidden="true"></a>}</span>
<span id="cb458-9"><a href="#cb458-9" aria-hidden="true"></a>t.close()</span></code></pre></div>
<p>Any ideas?</p>
</section>
<section id="answer-accepted-score-498-1" class="level4">
<h4>Answer accepted (score 498)</h4>
<p><strong>Update:</strong> Turns out that this method, while following STL idioms well, is actually surprisingly inefficient! Don’t do this with large files. (See: <a href="http://insanecoding.blogspot.com/2011/11/how-to-read-in-file-in-c.html" rel="noreferrer">http://insanecoding.blogspot.com/2011/11/how-to-read-in-file-in-c.html</a>)</p>
<p>You can make a streambuf iterator out of the file and initialize the string with it:</p>
<div class="sourceCode" id="cb459"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb459-1"><a href="#cb459-1" aria-hidden="true"></a></span>
<span id="cb459-2"><a href="#cb459-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb459-3"><a href="#cb459-3" aria-hidden="true"></a></span>
<span id="cb459-4"><a href="#cb459-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;fstream&gt;</span></span>
<span id="cb459-5"><a href="#cb459-5" aria-hidden="true"></a></span>
<span id="cb459-6"><a href="#cb459-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;streambuf&gt;</span></span>
<span id="cb459-7"><a href="#cb459-7" aria-hidden="true"></a></span>
<span id="cb459-8"><a href="#cb459-8" aria-hidden="true"></a><span class="bu">std::</span>ifstream t(<span class="st">&quot;file.txt&quot;</span>);</span>
<span id="cb459-9"><a href="#cb459-9" aria-hidden="true"></a><span class="bu">std::</span>string str((<span class="bu">std::</span>istreambuf_iterator&lt;<span class="dt">char</span>&gt;(t)),</span>
<span id="cb459-10"><a href="#cb459-10" aria-hidden="true"></a>                 <span class="bu">std::</span>istreambuf_iterator&lt;<span class="dt">char</span>&gt;());</span></code></pre></div>
<p>Not sure where you’re getting the <code>t.open("file.txt", "r")</code> syntax from. As far as I know that’s not a method that <code>std::ifstream</code> has. It looks like you’ve confused it with C’s <code>fopen</code>.</p>
<p><strong>Edit:</strong> Also note the extra parentheses around the first argument to the string constructor. <em>These are essential</em>. They prevent the problem known as the “<a href="http://web.archive.org/web/20110426155617/http://www.informit.com/guides/content.aspx?g=cplusplus&amp;seqNum=439" rel="noreferrer">most vexing parse</a>”, which in this case won’t actually give you a compile error like it usually does, but will give you interesting (read: wrong) results.</p>
<p>Following KeithB’s point in the comments, here’s a way to do it that allocates all the memory up front (rather than relying on the string class’s automatic reallocation):</p>
<div class="sourceCode" id="cb460"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb460-1"><a href="#cb460-1" aria-hidden="true"></a></span>
<span id="cb460-2"><a href="#cb460-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb460-3"><a href="#cb460-3" aria-hidden="true"></a></span>
<span id="cb460-4"><a href="#cb460-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;fstream&gt;</span></span>
<span id="cb460-5"><a href="#cb460-5" aria-hidden="true"></a></span>
<span id="cb460-6"><a href="#cb460-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;streambuf&gt;</span></span>
<span id="cb460-7"><a href="#cb460-7" aria-hidden="true"></a></span>
<span id="cb460-8"><a href="#cb460-8" aria-hidden="true"></a><span class="bu">std::</span>ifstream t(<span class="st">&quot;file.txt&quot;</span>);</span>
<span id="cb460-9"><a href="#cb460-9" aria-hidden="true"></a><span class="bu">std::</span>string str;</span>
<span id="cb460-10"><a href="#cb460-10" aria-hidden="true"></a></span>
<span id="cb460-11"><a href="#cb460-11" aria-hidden="true"></a>t.seekg(<span class="dv">0</span>, <span class="bu">std::</span>ios<span class="bu">::</span>end);   </span>
<span id="cb460-12"><a href="#cb460-12" aria-hidden="true"></a>str.reserve(t.tellg());</span>
<span id="cb460-13"><a href="#cb460-13" aria-hidden="true"></a>t.seekg(<span class="dv">0</span>, <span class="bu">std::</span>ios<span class="bu">::</span>beg);</span>
<span id="cb460-14"><a href="#cb460-14" aria-hidden="true"></a></span>
<span id="cb460-15"><a href="#cb460-15" aria-hidden="true"></a>str.assign((<span class="bu">std::</span>istreambuf_iterator&lt;<span class="dt">char</span>&gt;(t)),</span>
<span id="cb460-16"><a href="#cb460-16" aria-hidden="true"></a>            <span class="bu">std::</span>istreambuf_iterator&lt;<span class="dt">char</span>&gt;());</span></code></pre></div>
</section>
<section id="answer-2-score-751" class="level4">
<h4>Answer 2 (score 751)</h4>
<p>There are a couple of possibilities. One I like uses a stringstream as a go-between:</p>
<div class="sourceCode" id="cb461"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb461-1"><a href="#cb461-1" aria-hidden="true"></a><span class="bu">std::</span>ifstream t(<span class="st">&quot;file.txt&quot;</span>);</span>
<span id="cb461-2"><a href="#cb461-2" aria-hidden="true"></a><span class="bu">std::</span>stringstream buffer;</span>
<span id="cb461-3"><a href="#cb461-3" aria-hidden="true"></a>buffer &lt;&lt; t.rdbuf();</span></code></pre></div>
<p>Now the contents of “file.txt” are available in a string as <code>buffer.str()</code>.</p>
<p>Another possibility (though I certainly don’t like it as well) is much more like your original:</p>
<div class="sourceCode" id="cb462"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb462-1"><a href="#cb462-1" aria-hidden="true"></a><span class="bu">std::</span>ifstream t(<span class="st">&quot;file.txt&quot;</span>);</span>
<span id="cb462-2"><a href="#cb462-2" aria-hidden="true"></a>t.seekg(<span class="dv">0</span>, <span class="bu">std::</span>ios<span class="bu">::</span>end);</span>
<span id="cb462-3"><a href="#cb462-3" aria-hidden="true"></a><span class="dt">size_t</span> size = t.tellg();</span>
<span id="cb462-4"><a href="#cb462-4" aria-hidden="true"></a><span class="bu">std::</span>string buffer(size, <span class="ch">&#39; &#39;</span>);</span>
<span id="cb462-5"><a href="#cb462-5" aria-hidden="true"></a>t.seekg(<span class="dv">0</span>);</span>
<span id="cb462-6"><a href="#cb462-6" aria-hidden="true"></a>t.read(&amp;buffer[<span class="dv">0</span>], size); </span></code></pre></div>
<p>Officially, this isn’t required to work under the C++98 or 03 standard (string isn’t required to store data contiguously) but in fact it works with all known implementations, and C++11 and later do require contiguous storage, so it’s guaranteed to work with them.</p>
<p>As to why I don’t like the latter as well: first, because it’s longer and harder to read. Second, because it requires that you initialize the contents of the string with data you don’t care about, then immediately write over that data (yes, the time to initialize is usually trivial compared to the reading, so it probably doesn’t matter, but to me it still feels kind of wrong). Third, in a text file, position X in the file doesn’t necessarily mean you’ll have read X characters to reach that point – it’s not required to take into account things like line-end translations. On real systems that do such translations (e.g., Windows) the translated form is shorter than what’s in the file (i.e., “” in the file becomes “” in the translated string) so all you’ve done is reserved a little extra space you never use. Again, doesn’t really cause a major problem but feels a little wrong anyway.</p>
</section>
<section id="answer-3-score-62-1" class="level4">
<h4>Answer 3 (score 62)</h4>
<p>I think best way is to use string stream. simple and quick !!!</p>
<div class="sourceCode" id="cb463"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb463-1"><a href="#cb463-1" aria-hidden="true"></a></span>
<span id="cb463-2"><a href="#cb463-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;fstream&gt;</span></span>
<span id="cb463-3"><a href="#cb463-3" aria-hidden="true"></a></span>
<span id="cb463-4"><a href="#cb463-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb463-5"><a href="#cb463-5" aria-hidden="true"></a></span>
<span id="cb463-6"><a href="#cb463-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sstream&gt;</span><span class="pp"> </span><span class="co">//std::stringstream</span></span>
<span id="cb463-7"><a href="#cb463-7" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb463-8"><a href="#cb463-8" aria-hidden="true"></a>    <span class="bu">std::</span>ifstream inFile;</span>
<span id="cb463-9"><a href="#cb463-9" aria-hidden="true"></a>    inFile.open(<span class="st">&quot;inFileName&quot;</span>); <span class="co">//open the input file</span></span>
<span id="cb463-10"><a href="#cb463-10" aria-hidden="true"></a></span>
<span id="cb463-11"><a href="#cb463-11" aria-hidden="true"></a>    <span class="bu">std::</span>stringstream strStream;</span>
<span id="cb463-12"><a href="#cb463-12" aria-hidden="true"></a>    strStream &lt;&lt; inFile.rdbuf(); <span class="co">//read the file</span></span>
<span id="cb463-13"><a href="#cb463-13" aria-hidden="true"></a>    <span class="bu">std::</span>string str = strStream.str(); <span class="co">//str holds the content of the file</span></span>
<span id="cb463-14"><a href="#cb463-14" aria-hidden="true"></a></span>
<span id="cb463-15"><a href="#cb463-15" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; str &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>; <span class="co">//you can do anything with the string!!!</span></span>
<span id="cb463-16"><a href="#cb463-16" aria-hidden="true"></a>}</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-do-i-get-the-directory-that-a-program-is-running-from-score-477268-in-2013" class="level3">
<h3>73: How do I get the directory that a program is running from? (score <a href="https://stackoverflow.com/q/143174.html">477268</a> in 2013)</h3>
<section id="question-70" class="level4">
<h4>Question</h4>
<p>Is there a platform-agnostic and filesystem-agnostic method to obtain the full path of the directory from where a program is running using C/C++? Not to be confused with the current working directory. (Please don’t suggest libraries unless they’re standard ones like clib or STL.)</p>
<p>(If there’s no platform/filesystem-agnostic method, suggestions that work in Windows and Linux for specific filesystems are welcome too.)</p>
</section>
<section id="answer-accepted-score-171" class="level4">
<h4>Answer accepted (score 171)</h4>
<p>Here’s code to get the full path to the executing app:</p>
<p>Windows:</p>
<div class="sourceCode" id="cb464"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb464-1"><a href="#cb464-1" aria-hidden="true"></a><span class="dt">int</span> bytes = GetModuleFileName(NULL, pBuf, len);</span>
<span id="cb464-2"><a href="#cb464-2" aria-hidden="true"></a><span class="cf">if</span>(bytes == <span class="dv">0</span>)</span>
<span id="cb464-3"><a href="#cb464-3" aria-hidden="true"></a>    <span class="cf">return</span> -<span class="dv">1</span>;</span>
<span id="cb464-4"><a href="#cb464-4" aria-hidden="true"></a><span class="cf">else</span></span>
<span id="cb464-5"><a href="#cb464-5" aria-hidden="true"></a>    <span class="cf">return</span> bytes;</span></code></pre></div>
<p>Linux:</p>
<div class="sourceCode" id="cb465"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb465-1"><a href="#cb465-1" aria-hidden="true"></a><span class="dt">char</span> szTmp[<span class="dv">32</span>];</span>
<span id="cb465-2"><a href="#cb465-2" aria-hidden="true"></a>sprintf(szTmp, <span class="st">&quot;/proc/</span><span class="sc">%d</span><span class="st">/exe&quot;</span>, getpid());</span>
<span id="cb465-3"><a href="#cb465-3" aria-hidden="true"></a><span class="dt">int</span> bytes = MIN(readlink(szTmp, pBuf, len), len - <span class="dv">1</span>);</span>
<span id="cb465-4"><a href="#cb465-4" aria-hidden="true"></a><span class="cf">if</span>(bytes &gt;= <span class="dv">0</span>)</span>
<span id="cb465-5"><a href="#cb465-5" aria-hidden="true"></a>    pBuf[bytes] = <span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span>;</span>
<span id="cb465-6"><a href="#cb465-6" aria-hidden="true"></a><span class="cf">return</span> bytes;</span></code></pre></div>
</section>
<section id="answer-2-score-165" class="level4">
<h4>Answer 2 (score 165)</h4>
<p>If you fetch the current directory when your program first starts, then you effectively have the directory your program was started from. Store the value in a variable and refer to it later in your program. This is distinct from <a href="https://stackoverflow.com/q/933850/33732">the directory that holds the current executable program file</a>. It isn’t necessarily the same directory; if someone runs the program from a command prompt, then the program is being <em>run from</em> the command prompt’s current working directory even though the program file lives elsewhere.</p>
<p>getcwd is a POSIX function and supported out of the box by all POSIX compliant platforms. You would not have to do anything special (apart from incliding the right headers unistd.h on Unix and direct.h on windows).</p>
<p>Since you are creating a C program it will link with the default c run time library which is linked to by ALL processes in the system (specially crafted exceptions avoided) and it will include this function by default. The CRT is never considered an external library because that provides the basic standard compliant interface to the OS.</p>
<p>On windows getcwd function has been deprecated in favour of _getcwd. I think you could use it in this fashion.</p>
<div class="sourceCode" id="cb466"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb466-1"><a href="#cb466-1" aria-hidden="true"></a></span>
<span id="cb466-2"><a href="#cb466-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span><span class="pp">  </span><span class="co">/* defines FILENAME_MAX */</span></span>
<span id="cb466-3"><a href="#cb466-3" aria-hidden="true"></a></span>
<span id="cb466-4"><a href="#cb466-4" aria-hidden="true"></a><span class="pp">#ifdef WINDOWS</span></span>
<span id="cb466-5"><a href="#cb466-5" aria-hidden="true"></a></span>
<span id="cb466-6"><a href="#cb466-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;direct.h&gt;</span></span>
<span id="cb466-7"><a href="#cb466-7" aria-hidden="true"></a></span>
<span id="cb466-8"><a href="#cb466-8" aria-hidden="true"></a><span class="pp">#define GetCurrentDir </span>_getcwd</span>
<span id="cb466-9"><a href="#cb466-9" aria-hidden="true"></a></span>
<span id="cb466-10"><a href="#cb466-10" aria-hidden="true"></a><span class="pp">#else</span></span>
<span id="cb466-11"><a href="#cb466-11" aria-hidden="true"></a></span>
<span id="cb466-12"><a href="#cb466-12" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb466-13"><a href="#cb466-13" aria-hidden="true"></a></span>
<span id="cb466-14"><a href="#cb466-14" aria-hidden="true"></a><span class="pp">#define GetCurrentDir </span>getcwd</span>
<span id="cb466-15"><a href="#cb466-15" aria-hidden="true"></a></span>
<span id="cb466-16"><a href="#cb466-16" aria-hidden="true"></a><span class="pp">#endif</span></span>
<span id="cb466-17"><a href="#cb466-17" aria-hidden="true"></a></span>
<span id="cb466-18"><a href="#cb466-18" aria-hidden="true"></a> <span class="dt">char</span> cCurrentPath[FILENAME_MAX];</span>
<span id="cb466-19"><a href="#cb466-19" aria-hidden="true"></a></span>
<span id="cb466-20"><a href="#cb466-20" aria-hidden="true"></a> <span class="cf">if</span> (!GetCurrentDir(cCurrentPath, <span class="kw">sizeof</span>(cCurrentPath)))</span>
<span id="cb466-21"><a href="#cb466-21" aria-hidden="true"></a>     {</span>
<span id="cb466-22"><a href="#cb466-22" aria-hidden="true"></a>     <span class="cf">return</span> errno;</span>
<span id="cb466-23"><a href="#cb466-23" aria-hidden="true"></a>     }</span>
<span id="cb466-24"><a href="#cb466-24" aria-hidden="true"></a></span>
<span id="cb466-25"><a href="#cb466-25" aria-hidden="true"></a>cCurrentPath[<span class="kw">sizeof</span>(cCurrentPath) - <span class="dv">1</span>] = <span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span>; <span class="co">/* not really required */</span></span>
<span id="cb466-26"><a href="#cb466-26" aria-hidden="true"></a></span>
<span id="cb466-27"><a href="#cb466-27" aria-hidden="true"></a>printf (<span class="st">&quot;The current working directory is </span><span class="sc">%s</span><span class="st">&quot;</span>, cCurrentPath);</span></code></pre></div>
</section>
<section id="answer-3-score-39-1" class="level4">
<h4>Answer 3 (score 39)</h4>
<p>This is from the <a href="http://www.cplusplus.com/forum/general/11104/">cplusplus forum</a></p>
<p><strong>On windows:</strong></p>
<div class="sourceCode" id="cb467"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb467-1"><a href="#cb467-1" aria-hidden="true"></a></span>
<span id="cb467-2"><a href="#cb467-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb467-3"><a href="#cb467-3" aria-hidden="true"></a></span>
<span id="cb467-4"><a href="#cb467-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;windows.h&gt;</span></span>
<span id="cb467-5"><a href="#cb467-5" aria-hidden="true"></a></span>
<span id="cb467-6"><a href="#cb467-6" aria-hidden="true"></a><span class="bu">std::</span>string getexepath()</span>
<span id="cb467-7"><a href="#cb467-7" aria-hidden="true"></a>{</span>
<span id="cb467-8"><a href="#cb467-8" aria-hidden="true"></a>  <span class="dt">char</span> result[ MAX_PATH ];</span>
<span id="cb467-9"><a href="#cb467-9" aria-hidden="true"></a>  <span class="cf">return</span> <span class="bu">std::</span>string( result, GetModuleFileName( NULL, result, MAX_PATH ) );</span>
<span id="cb467-10"><a href="#cb467-10" aria-hidden="true"></a>}</span></code></pre></div>
<p><strong>On Linux:</strong></p>
<div class="sourceCode" id="cb468"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb468-1"><a href="#cb468-1" aria-hidden="true"></a></span>
<span id="cb468-2"><a href="#cb468-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb468-3"><a href="#cb468-3" aria-hidden="true"></a></span>
<span id="cb468-4"><a href="#cb468-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb468-5"><a href="#cb468-5" aria-hidden="true"></a></span>
<span id="cb468-6"><a href="#cb468-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb468-7"><a href="#cb468-7" aria-hidden="true"></a></span>
<span id="cb468-8"><a href="#cb468-8" aria-hidden="true"></a><span class="bu">std::</span>string getexepath()</span>
<span id="cb468-9"><a href="#cb468-9" aria-hidden="true"></a>{</span>
<span id="cb468-10"><a href="#cb468-10" aria-hidden="true"></a>  <span class="dt">char</span> result[ PATH_MAX ];</span>
<span id="cb468-11"><a href="#cb468-11" aria-hidden="true"></a>  <span class="dt">ssize_t</span> count = readlink( <span class="st">&quot;/proc/self/exe&quot;</span>, result, PATH_MAX );</span>
<span id="cb468-12"><a href="#cb468-12" aria-hidden="true"></a>  <span class="cf">return</span> <span class="bu">std::</span>string( result, (count &gt; <span class="dv">0</span>) ? count : <span class="dv">0</span> );</span>
<span id="cb468-13"><a href="#cb468-13" aria-hidden="true"></a>}</span></code></pre></div>
<p><strong>On HP-UX:</strong></p>
<div class="sourceCode" id="cb469"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb469-1"><a href="#cb469-1" aria-hidden="true"></a></span>
<span id="cb469-2"><a href="#cb469-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb469-3"><a href="#cb469-3" aria-hidden="true"></a></span>
<span id="cb469-4"><a href="#cb469-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb469-5"><a href="#cb469-5" aria-hidden="true"></a></span>
<span id="cb469-6"><a href="#cb469-6" aria-hidden="true"></a><span class="pp">#define _PSTAT64</span></span>
<span id="cb469-7"><a href="#cb469-7" aria-hidden="true"></a></span>
<span id="cb469-8"><a href="#cb469-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sys/pstat.h&gt;</span></span>
<span id="cb469-9"><a href="#cb469-9" aria-hidden="true"></a></span>
<span id="cb469-10"><a href="#cb469-10" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb469-11"><a href="#cb469-11" aria-hidden="true"></a></span>
<span id="cb469-12"><a href="#cb469-12" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb469-13"><a href="#cb469-13" aria-hidden="true"></a></span>
<span id="cb469-14"><a href="#cb469-14" aria-hidden="true"></a><span class="bu">std::</span>string getexepath()</span>
<span id="cb469-15"><a href="#cb469-15" aria-hidden="true"></a>{</span>
<span id="cb469-16"><a href="#cb469-16" aria-hidden="true"></a>  <span class="dt">char</span> result[ PATH_MAX ];</span>
<span id="cb469-17"><a href="#cb469-17" aria-hidden="true"></a>  <span class="kw">struct</span> pst_status ps;</span>
<span id="cb469-18"><a href="#cb469-18" aria-hidden="true"></a></span>
<span id="cb469-19"><a href="#cb469-19" aria-hidden="true"></a>  <span class="cf">if</span> (pstat_getproc( &amp;ps, <span class="kw">sizeof</span>( ps ), <span class="dv">0</span>, getpid() ) &lt; <span class="dv">0</span>)</span>
<span id="cb469-20"><a href="#cb469-20" aria-hidden="true"></a>    <span class="cf">return</span> <span class="bu">std::</span>string();</span>
<span id="cb469-21"><a href="#cb469-21" aria-hidden="true"></a></span>
<span id="cb469-22"><a href="#cb469-22" aria-hidden="true"></a>  <span class="cf">if</span> (pstat_getpathname( result, PATH_MAX, &amp;ps.pst_fid_text ) &lt; <span class="dv">0</span>)</span>
<span id="cb469-23"><a href="#cb469-23" aria-hidden="true"></a>    <span class="cf">return</span> <span class="bu">std::</span>string();</span>
<span id="cb469-24"><a href="#cb469-24" aria-hidden="true"></a></span>
<span id="cb469-25"><a href="#cb469-25" aria-hidden="true"></a>  <span class="cf">return</span> <span class="bu">std::</span>string( result );</span>
<span id="cb469-26"><a href="#cb469-26" aria-hidden="true"></a>}</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="easily-measure-elapsed-time-score-469449-in-2013" class="level3">
<h3>74: Easily measure elapsed time (score <a href="https://stackoverflow.com/q/2808398.html">469449</a> in 2013)</h3>
<section id="question-71" class="level4">
<h4>Question</h4>
<p>I am trying to use <a href="http://en.cppreference.com/w/cpp/chrono/c/time" rel="noreferrer">time()</a> to measure various points of my program.</p>
<p>What I don’t understand is why the values in the before and after are the same? I understand this is not the best way to profile my program, I just want to see how long something take.</p>
<div class="sourceCode" id="cb470"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb470-1"><a href="#cb470-1" aria-hidden="true"></a>printf(<span class="st">&quot;**MyProgram::before time= </span><span class="sc">%ld\n</span><span class="st">&quot;</span>, time(NULL));</span>
<span id="cb470-2"><a href="#cb470-2" aria-hidden="true"></a></span>
<span id="cb470-3"><a href="#cb470-3" aria-hidden="true"></a>doSomthing();</span>
<span id="cb470-4"><a href="#cb470-4" aria-hidden="true"></a>doSomthingLong();</span>
<span id="cb470-5"><a href="#cb470-5" aria-hidden="true"></a></span>
<span id="cb470-6"><a href="#cb470-6" aria-hidden="true"></a>printf(<span class="st">&quot;**MyProgram::after time= </span><span class="sc">%ld\n</span><span class="st">&quot;</span>, time(NULL));</span></code></pre></div>
<p>I have tried:</p>
<div class="sourceCode" id="cb471"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb471-1"><a href="#cb471-1" aria-hidden="true"></a><span class="kw">struct</span> timeval diff, startTV, endTV;</span>
<span id="cb471-2"><a href="#cb471-2" aria-hidden="true"></a></span>
<span id="cb471-3"><a href="#cb471-3" aria-hidden="true"></a>gettimeofday(&amp;startTV, NULL); </span>
<span id="cb471-4"><a href="#cb471-4" aria-hidden="true"></a></span>
<span id="cb471-5"><a href="#cb471-5" aria-hidden="true"></a>doSomething();</span>
<span id="cb471-6"><a href="#cb471-6" aria-hidden="true"></a>doSomethingLong();</span>
<span id="cb471-7"><a href="#cb471-7" aria-hidden="true"></a></span>
<span id="cb471-8"><a href="#cb471-8" aria-hidden="true"></a>gettimeofday(&amp;endTV, NULL); </span>
<span id="cb471-9"><a href="#cb471-9" aria-hidden="true"></a></span>
<span id="cb471-10"><a href="#cb471-10" aria-hidden="true"></a>timersub(&amp;endTV, &amp;startTV, &amp;diff);</span>
<span id="cb471-11"><a href="#cb471-11" aria-hidden="true"></a></span>
<span id="cb471-12"><a href="#cb471-12" aria-hidden="true"></a>printf(<span class="st">&quot;**time taken = </span><span class="sc">%ld</span><span class="st"> </span><span class="sc">%ld\n</span><span class="st">&quot;</span>, diff.tv_sec, diff.tv_usec);</span></code></pre></div>
<p>How do I read a result of <code>**time taken = 0 26339</code>? Does that mean 26,339 nanoseconds = 26.3 msec?</p>
<p>What about <code>**time taken = 4 45025</code>, does that mean 4 seconds and 25 msec?</p>
</section>
<section id="answer-2-score-263" class="level4">
<h4>Answer 2 (score 263)</h4>
<div class="sourceCode" id="cb472"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb472-1"><a href="#cb472-1" aria-hidden="true"></a></span>
<span id="cb472-2"><a href="#cb472-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;ctime&gt;</span></span>
<span id="cb472-3"><a href="#cb472-3" aria-hidden="true"></a></span>
<span id="cb472-4"><a href="#cb472-4" aria-hidden="true"></a><span class="dt">void</span> f() {</span>
<span id="cb472-5"><a href="#cb472-5" aria-hidden="true"></a>  <span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb472-6"><a href="#cb472-6" aria-hidden="true"></a>  <span class="dt">clock_t</span> begin = clock();</span>
<span id="cb472-7"><a href="#cb472-7" aria-hidden="true"></a></span>
<span id="cb472-8"><a href="#cb472-8" aria-hidden="true"></a>  code_to_time();</span>
<span id="cb472-9"><a href="#cb472-9" aria-hidden="true"></a></span>
<span id="cb472-10"><a href="#cb472-10" aria-hidden="true"></a>  <span class="dt">clock_t</span> end = clock();</span>
<span id="cb472-11"><a href="#cb472-11" aria-hidden="true"></a>  <span class="dt">double</span> elapsed_secs = <span class="dt">double</span>(end - begin) / CLOCKS_PER_SEC;</span>
<span id="cb472-12"><a href="#cb472-12" aria-hidden="true"></a>}</span></code></pre></div>
<p>The <code>time()</code> function is only accurate to within a second, but there are <a href="http://en.cppreference.com/w/cpp/chrono/c/CLOCKS_PER_SEC" rel="noreferrer"><code>CLOCKS_PER_SEC</code></a> “clocks” within a second. This is an easy, portable measurement, even though it’s over-simplified.</p>
</section>
<section id="answer-3-score-261" class="level4">
<h4>Answer 3 (score 261)</h4>
<p>You can <strong>abstract the time measuring mechanism</strong> and have each callable’s run time measured with <strong>minimal extra code</strong>, just by being called through a timer structure. Plus, at compile time you can <strong>parametrize the timing type</strong> (milliseconds, nanoseconds etc).</p>
<p>
<sup>Thanks to the review by <a href="https://stackoverflow.com/users/14065/loki-astari">Loki Astari</a> and the suggestion to use variadic templates.</sup> <sup><a href="https://stackoverflow.com/q/31253334/2567683">This</a> is why the forwarded function call.</sup>
</p>
<div class="sourceCode" id="cb473"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb473-1"><a href="#cb473-1" aria-hidden="true"></a></span>
<span id="cb473-2"><a href="#cb473-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb473-3"><a href="#cb473-3" aria-hidden="true"></a></span>
<span id="cb473-4"><a href="#cb473-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;chrono&gt;</span></span>
<span id="cb473-5"><a href="#cb473-5" aria-hidden="true"></a></span>
<span id="cb473-6"><a href="#cb473-6" aria-hidden="true"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> TimeT = <span class="bu">std::</span>chrono<span class="bu">::</span>milliseconds&gt;</span>
<span id="cb473-7"><a href="#cb473-7" aria-hidden="true"></a><span class="kw">struct</span> measure</span>
<span id="cb473-8"><a href="#cb473-8" aria-hidden="true"></a>{</span>
<span id="cb473-9"><a href="#cb473-9" aria-hidden="true"></a>    <span class="kw">template</span>&lt;<span class="kw">typename</span> F, <span class="kw">typename</span> ...Args&gt;</span>
<span id="cb473-10"><a href="#cb473-10" aria-hidden="true"></a>    <span class="at">static</span> <span class="kw">typename</span> TimeT::rep execution(F&amp;&amp; func, Args&amp;&amp;... args)</span>
<span id="cb473-11"><a href="#cb473-11" aria-hidden="true"></a>    {</span>
<span id="cb473-12"><a href="#cb473-12" aria-hidden="true"></a>        <span class="kw">auto</span> start = <span class="bu">std::</span>chrono<span class="bu">::</span>steady_clock<span class="bu">::</span>now();</span>
<span id="cb473-13"><a href="#cb473-13" aria-hidden="true"></a>        <span class="bu">std::</span>forward&lt;<span class="kw">decltype</span>(func)&gt;(func)(<span class="bu">std::</span>forward&lt;Args&gt;(args)...);</span>
<span id="cb473-14"><a href="#cb473-14" aria-hidden="true"></a>        <span class="kw">auto</span> duration = <span class="bu">std::</span>chrono<span class="bu">::</span>duration_cast&lt; TimeT&gt; </span>
<span id="cb473-15"><a href="#cb473-15" aria-hidden="true"></a>                            (<span class="bu">std::</span>chrono<span class="bu">::</span>steady_clock<span class="bu">::</span>now() - start);</span>
<span id="cb473-16"><a href="#cb473-16" aria-hidden="true"></a>        <span class="cf">return</span> duration.count();</span>
<span id="cb473-17"><a href="#cb473-17" aria-hidden="true"></a>    }</span>
<span id="cb473-18"><a href="#cb473-18" aria-hidden="true"></a>};</span>
<span id="cb473-19"><a href="#cb473-19" aria-hidden="true"></a></span>
<span id="cb473-20"><a href="#cb473-20" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb473-21"><a href="#cb473-21" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; measure&lt;&gt;::execution(functor(dummy)) &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb473-22"><a href="#cb473-22" aria-hidden="true"></a>}</span></code></pre></div>
<p><a href="http://ideone.com/JbUkPq" rel="noreferrer"><kbd><strong>Demo</strong></kbd></a></p>
<p>According to the comment by <a href="https://stackoverflow.com/users/576911/howard-hinnant"><strong>Howard Hinnant</strong></a> it’s best not to escape out of the chrono system until we have to. So the above class could give the user the choice to call <code>count</code> manually by providing an extra static method (shown in C++14)</p>
<div class="sourceCode" id="cb474"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb474-1"><a href="#cb474-1" aria-hidden="true"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> F, <span class="kw">typename</span> ...Args&gt;</span>
<span id="cb474-2"><a href="#cb474-2" aria-hidden="true"></a><span class="at">static</span> <span class="kw">auto</span> duration(F&amp;&amp; func, Args&amp;&amp;... args)</span>
<span id="cb474-3"><a href="#cb474-3" aria-hidden="true"></a>{</span>
<span id="cb474-4"><a href="#cb474-4" aria-hidden="true"></a>    <span class="kw">auto</span> start = <span class="bu">std::</span>chrono<span class="bu">::</span>steady_clock<span class="bu">::</span>now();</span>
<span id="cb474-5"><a href="#cb474-5" aria-hidden="true"></a>    <span class="bu">std::</span>forward&lt;<span class="kw">decltype</span>(func)&gt;(func)(<span class="bu">std::</span>forward&lt;Args&gt;(args)...);</span>
<span id="cb474-6"><a href="#cb474-6" aria-hidden="true"></a>    <span class="cf">return</span> <span class="bu">std::</span>chrono<span class="bu">::</span>duration_cast&lt;TimeT&gt;(<span class="bu">std::</span>chrono<span class="bu">::</span>steady_clock<span class="bu">::</span>now()-start);</span>
<span id="cb474-7"><a href="#cb474-7" aria-hidden="true"></a>} </span>
<span id="cb474-8"><a href="#cb474-8" aria-hidden="true"></a></span>
<span id="cb474-9"><a href="#cb474-9" aria-hidden="true"></a><span class="co">// call .count() manually later when needed (eg IO)</span></span>
<span id="cb474-10"><a href="#cb474-10" aria-hidden="true"></a><span class="kw">auto</span> avg = (measure&lt;&gt;::duration(func) + measure&lt;&gt;::duration(func)) / <span class="fl">2.0</span>;</span></code></pre></div>
<p>and be most useful for clients that</p>
<blockquote>
“want to post-process a bunch of durations prior to I/O (e.g. average)”
</blockquote>
<hr>
<p>The complete <a href="https://github.com/picanumber/bureaucrat/blob/master/time_lapse.h" rel="noreferrer"><strong>code can be found here</strong></a>. My attempt to build a <strong>benchmarking tool</strong> based on chrono is recorded <a href="https://isocpp.org/blog/2015/04/https-ngathanasiou.wordpress.com-2015-04-01-benchmarking-in-c" rel="noreferrer"><strong>here</strong></a>.</p>
<hr>
<p>If C++17’s <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke" rel="noreferrer"><code>std::invoke</code></a> is available, the invocation of the callable in <code>execution</code> could be done like this :</p>
<div class="sourceCode" id="cb475"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb475-1"><a href="#cb475-1" aria-hidden="true"></a>invoke(forward&lt;<span class="kw">decltype</span>(func)&gt;(func), forward&lt;Args&gt;(args)...);</span></code></pre></div>
<p>to provide for callables that are pointers to member functions.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="convert-a-string-in-c-to-upper-case-score-469068-in-2012" class="level3">
<h3>75: Convert a String In C++ To Upper Case (score <a href="https://stackoverflow.com/q/735204.html">469068</a> in 2012)</h3>
<section id="question-72" class="level4">
<h4>Question</h4>
<p>How could one convert a string to upper case. The examples I have found from googling only have to deal with chars.</p>
</section>
<section id="answer-accepted-score-204" class="level4">
<h4>Answer accepted (score 204)</h4>
<p>Boost string algorithms:</p>
<div class="sourceCode" id="cb476"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb476-1"><a href="#cb476-1" aria-hidden="true"></a></span>
<span id="cb476-2"><a href="#cb476-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;boost/algorithm/string.hpp&gt;</span></span>
<span id="cb476-3"><a href="#cb476-3" aria-hidden="true"></a></span>
<span id="cb476-4"><a href="#cb476-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb476-5"><a href="#cb476-5" aria-hidden="true"></a></span>
<span id="cb476-6"><a href="#cb476-6" aria-hidden="true"></a><span class="bu">std::</span>string str = <span class="st">&quot;Hello World&quot;</span>;</span>
<span id="cb476-7"><a href="#cb476-7" aria-hidden="true"></a></span>
<span id="cb476-8"><a href="#cb476-8" aria-hidden="true"></a><span class="ex">boost::</span>to_upper(str);</span>
<span id="cb476-9"><a href="#cb476-9" aria-hidden="true"></a></span>
<span id="cb476-10"><a href="#cb476-10" aria-hidden="true"></a><span class="bu">std::</span>string newstr = <span class="ex">boost::</span>to_upper_copy&lt;<span class="bu">std::</span>string&gt;(<span class="st">&quot;Hello World&quot;</span>);</span></code></pre></div>
</section>
<section id="answer-2-score-466-1" class="level4">
<h4>Answer 2 (score 466)</h4>
<div class="sourceCode" id="cb477"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb477-1"><a href="#cb477-1" aria-hidden="true"></a></span>
<span id="cb477-2"><a href="#cb477-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb477-3"><a href="#cb477-3" aria-hidden="true"></a></span>
<span id="cb477-4"><a href="#cb477-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb477-5"><a href="#cb477-5" aria-hidden="true"></a></span>
<span id="cb477-6"><a href="#cb477-6" aria-hidden="true"></a><span class="bu">std::</span>string str = <span class="st">&quot;Hello World&quot;</span>;</span>
<span id="cb477-7"><a href="#cb477-7" aria-hidden="true"></a><span class="bu">std::</span>transform(str.begin(), str.end(),str.begin(), ::toupper);</span></code></pre></div>
</section>
<section id="answer-3-score-82" class="level4">
<h4>Answer 3 (score 82)</h4>
<p>Short solution using C++11 and toupper().</p>
<div class="sourceCode" id="cb478"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb478-1"><a href="#cb478-1" aria-hidden="true"></a><span class="cf">for</span> (<span class="kw">auto</span> &amp; c: str) c = toupper(c);</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-to-initialize-private-static-members-in-c-score-466489-in-2018" class="level3">
<h3>76: How to initialize private static members in C++? (score <a href="https://stackoverflow.com/q/185844.html">466489</a> in 2018)</h3>
<section id="question-73" class="level4">
<h4>Question</h4>
<p>What is the best way to initialize a private, static data member in C++? I tried this in my header file, but it gives me weird linker errors:</p>
<div class="sourceCode" id="cb479"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb479-1"><a href="#cb479-1" aria-hidden="true"></a><span class="kw">class</span> foo</span>
<span id="cb479-2"><a href="#cb479-2" aria-hidden="true"></a>{</span>
<span id="cb479-3"><a href="#cb479-3" aria-hidden="true"></a>    <span class="kw">private</span>:</span>
<span id="cb479-4"><a href="#cb479-4" aria-hidden="true"></a>        <span class="at">static</span> <span class="dt">int</span> i;</span>
<span id="cb479-5"><a href="#cb479-5" aria-hidden="true"></a>};</span>
<span id="cb479-6"><a href="#cb479-6" aria-hidden="true"></a></span>
<span id="cb479-7"><a href="#cb479-7" aria-hidden="true"></a><span class="dt">int</span> foo::i = <span class="dv">0</span>;</span></code></pre></div>
<p>I’m guessing this is because I can’t initialize a private member from outside the class. So what’s the best way to do this?</p>
</section>
<section id="answer-accepted-score-519" class="level4">
<h4>Answer accepted (score 519)</h4>
<p>
The class declaration should be in the header file (Or in the source file if not shared).<br> File: foo.h
</p>
<div class="sourceCode" id="cb480"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb480-1"><a href="#cb480-1" aria-hidden="true"></a><span class="kw">class</span> foo</span>
<span id="cb480-2"><a href="#cb480-2" aria-hidden="true"></a>{</span>
<span id="cb480-3"><a href="#cb480-3" aria-hidden="true"></a>    <span class="kw">private</span>:</span>
<span id="cb480-4"><a href="#cb480-4" aria-hidden="true"></a>        <span class="at">static</span> <span class="dt">int</span> i;</span>
<span id="cb480-5"><a href="#cb480-5" aria-hidden="true"></a>};</span></code></pre></div>
<p>
But the initialization should be in source file.<br> File: foo.cpp
</p>
<div class="sourceCode" id="cb481"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb481-1"><a href="#cb481-1" aria-hidden="true"></a><span class="dt">int</span> foo::i = <span class="dv">0</span>;</span></code></pre></div>
<p>If the initialization is in the header file then each file that includes the header file will have a definition of the static member. Thus during the link phase you will get linker errors as the code to initialize the variable will be defined in multiple source files.</p>
<p><b>Note:</b> Matt Curtis: points out that C++ allows the simplification of the above if the static member variable is of const int type (e.g. <code>int</code>, <code>bool</code>, <code>char</code>). You can then declare and initialize the member variable directly inside the class declaration in the header file:</p>
<div class="sourceCode" id="cb482"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb482-1"><a href="#cb482-1" aria-hidden="true"></a><span class="kw">class</span> foo</span>
<span id="cb482-2"><a href="#cb482-2" aria-hidden="true"></a>{</span>
<span id="cb482-3"><a href="#cb482-3" aria-hidden="true"></a>    <span class="kw">private</span>:</span>
<span id="cb482-4"><a href="#cb482-4" aria-hidden="true"></a>        <span class="at">static</span> <span class="dt">int</span> <span class="at">const</span> i = <span class="dv">42</span>;</span>
<span id="cb482-5"><a href="#cb482-5" aria-hidden="true"></a>};</span></code></pre></div>
</section>
<section id="answer-2-score-86-1" class="level4">
<h4>Answer 2 (score 86)</h4>
<p>For a <strong>variable</strong>:</p>
<p>foo.h:</p>
<div class="sourceCode" id="cb483"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb483-1"><a href="#cb483-1" aria-hidden="true"></a><span class="kw">class</span> foo</span>
<span id="cb483-2"><a href="#cb483-2" aria-hidden="true"></a>{</span>
<span id="cb483-3"><a href="#cb483-3" aria-hidden="true"></a><span class="kw">private</span>:</span>
<span id="cb483-4"><a href="#cb483-4" aria-hidden="true"></a>    <span class="at">static</span> <span class="dt">int</span> i;</span>
<span id="cb483-5"><a href="#cb483-5" aria-hidden="true"></a>};</span></code></pre></div>
<p>foo.cpp:</p>
<div class="sourceCode" id="cb484"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb484-1"><a href="#cb484-1" aria-hidden="true"></a><span class="dt">int</span> foo::i = <span class="dv">0</span>;</span></code></pre></div>
<p>This is because there can only be one instance of <code>foo::i</code> in your program. It’s sort of the equivalent of <code>extern int i</code> in a header file and <code>int i</code> in a source file.</p>
<p>For a <strong>constant</strong> you can put the value straight in the class declaration:</p>
<div class="sourceCode" id="cb485"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb485-1"><a href="#cb485-1" aria-hidden="true"></a><span class="kw">class</span> foo</span>
<span id="cb485-2"><a href="#cb485-2" aria-hidden="true"></a>{</span>
<span id="cb485-3"><a href="#cb485-3" aria-hidden="true"></a><span class="kw">private</span>:</span>
<span id="cb485-4"><a href="#cb485-4" aria-hidden="true"></a>    <span class="at">static</span> <span class="dt">int</span> i;</span>
<span id="cb485-5"><a href="#cb485-5" aria-hidden="true"></a>    <span class="at">const</span> <span class="at">static</span> <span class="dt">int</span> a = <span class="dv">42</span>;</span>
<span id="cb485-6"><a href="#cb485-6" aria-hidden="true"></a>};</span></code></pre></div>
</section>
<section id="answer-3-score-27-1" class="level4">
<h4>Answer 3 (score 27)</h4>
<p>For future viewers of this question, I want to point out that you should avoid what <a href="https://stackoverflow.com/a/8772501/5571184">monkey0506 is suggesting</a>.</p>
<p>Header files are for declarations.</p>
<p>Header files get compiled once for every <code>.cpp</code> file that directly or indirectly <code>#includes</code> them, and code outside of any function is run at program initialization, before <code>main()</code>.</p>
<p>By putting: <code>foo::i = VALUE;</code> into the header, <code>foo:i</code> will be assigned the value <code>VALUE</code> (whatever that is) for every <code>.cpp</code> file, and these assignments will happen in an indeterminate order (determined by the linker) before <code>main()</code> is run.</p>
<p>What if we <code>#define VALUE</code> to be a different number in one of our <code>.cpp</code> files? It will compile fine and we will have no way of knowing which one wins until we run the program.</p>
<p>Never put executed code into a header for the same reason that you never <code>#include</code> a <code>.cpp</code> file.</p>
<p>include guards (which I agree you should always use) protect you from something different: the same header being indirectly <code>#include</code>d multiple times while compiling a single <code>.cpp</code> file</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="differences-between-c-string-and-compare-score-464209-in-2012" class="level3">
<h3>77: Differences between C++ string == and compare()? (score <a href="https://stackoverflow.com/q/9158894.html">464209</a> in 2012)</h3>
<section id="question-74" class="level4">
<h4>Question</h4>
<p>I just read some recommendations on using</p>
<div class="sourceCode" id="cb486"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb486-1"><a href="#cb486-1" aria-hidden="true"></a><span class="bu">std::</span>string s = get_string();</span>
<span id="cb486-2"><a href="#cb486-2" aria-hidden="true"></a><span class="bu">std::</span>string t = another_string();</span>
<span id="cb486-3"><a href="#cb486-3" aria-hidden="true"></a></span>
<span id="cb486-4"><a href="#cb486-4" aria-hidden="true"></a><span class="cf">if</span>( !s.compare(t) ) </span>
<span id="cb486-5"><a href="#cb486-5" aria-hidden="true"></a>{</span></code></pre></div>
<p>instead of</p>
<div class="sourceCode" id="cb487"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb487-1"><a href="#cb487-1" aria-hidden="true"></a><span class="cf">if</span>( s == t )</span>
<span id="cb487-2"><a href="#cb487-2" aria-hidden="true"></a>{</span></code></pre></div>
<p>
I’m almost always using the last one because I’m used to it and it feels natural, more readable. I didn’t even know that there was a separate comparison function. To be more precise, I thought == would call compare().
</p>
<p><strong>What are the differences? In which contexts should one way be favored to the other?</strong></p>
<p>I’m considering only the cases where I need to know if a string is the same value as another string.</p>
</section>
<section id="answer-accepted-score-412" class="level4">
<h4>Answer accepted (score 412)</h4>
<p>This is what the standard has to say about <code>operator==</code></p>
<blockquote>
<p><strong>21.4.8.2 operator==</strong></p>
<div class="sourceCode" id="cb488"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb488-1"><a href="#cb488-1" aria-hidden="true"></a><span class="kw">template</span>&lt;<span class="kw">class</span> charT, <span class="kw">class</span> traits, <span class="kw">class</span> Allocator&gt;</span>
<span id="cb488-2"><a href="#cb488-2" aria-hidden="true"></a><span class="dt">bool</span> <span class="kw">operator</span>==(<span class="at">const</span> basic_string&lt;charT,traits,Allocator&gt;&amp; lhs,</span>
<span id="cb488-3"><a href="#cb488-3" aria-hidden="true"></a>                <span class="at">const</span> basic_string&lt;charT,traits,Allocator&gt;&amp; rhs) <span class="kw">noexcept</span>;</span></code></pre></div>
Returns: lhs.compare(rhs) == 0.
</blockquote>
<p>Seems like there isn’t much of a difference!</p>
</section>
<section id="answer-2-score-130" class="level4">
<h4>Answer 2 (score 130)</h4>
<p><a href="http://www.cplusplus.com/reference/string/string/compare/">std::string::compare()</a> returns an <code>int</code>:</p>
<ul>
<li>
equal to zero if <code>s</code> and <code>t</code> are equal,
</li>
<li>
less than zero if <code>s</code> is less than <code>t</code>,
</li>
<li>
greater than zero if <code>s</code> is greater than <code>t</code>.
</li>
</ul>
<p>If you want your first code snippet to be equivalent to the second one, it should actually read:</p>
<div class="sourceCode" id="cb489"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb489-1"><a href="#cb489-1" aria-hidden="true"></a><span class="cf">if</span> (!s.compare(t)) {</span>
<span id="cb489-2"><a href="#cb489-2" aria-hidden="true"></a>    <span class="co">// &#39;s&#39; and &#39;t&#39; are equal.</span></span>
<span id="cb489-3"><a href="#cb489-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>The equality operator only tests for equality (hence its name) and returns a <code>bool</code>.</p>
<p>To elaborate on the use cases, <code>compare()</code> can be useful if you’re interested in how the two strings relate to one another (less or greater) when they happen to be different. PlasmaHH rightfully mentions trees, and it could also be, say, a string insertion algorithm that aims to keep the container sorted, a dichotomic search algorithm for the aforementioned container, and so on.</p>
<p><strong>EDIT:</strong> As Steve Jessop points out in the comments, <code>compare()</code> is most useful for quick sort and binary search algorithms. Natural sorts and dichotomic searches can be implemented with only <a href="http://www.cplusplus.com/reference/std/functional/less/">std::less</a>.</p>
</section>
<section id="answer-3-score-30-2" class="level4">
<h4>Answer 3 (score 30)</h4>
<p><code>compare</code> has overloads for comparing substrings. If you’re comparing whole strings you should just use <code>==</code> operator (and whether it calls <code>compare</code> or not is pretty much irrelevant).</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="unresolved-external-symbol-in-object-files-score-462491-in-2016" class="level3">
<h3>78: Unresolved external symbol in object files (score <a href="https://stackoverflow.com/q/9928238.html">462491</a> in 2016)</h3>
<section id="question-75" class="level4">
<h4>Question</h4>
<p>
During coding in Visual Studio I got an unresolved external symbol error and I’ve got no idea what to do. I don’t know what’s wrong. Could you please decipher me? Where should I be looking for what kind of errors?
</p>
<div class="sourceCode" id="cb490"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb490-1"><a href="#cb490-1" aria-hidden="true"></a><span class="dv">1</span>&gt;Form.obj : error LNK2019: unresolved external symbol <span class="st">&quot;public: class Field * __thiscall Field::addField(class Field *)&quot;</span> (?addField<span class="er">@</span>Field<span class="er">@@</span>QAEPAV1<span class="er">@</span>PAV1<span class="er">@@</span>Z) referenced in function <span class="st">&quot;public: void __thiscall Form::parse(class std::basic_stringstream&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &amp;)&quot;</span> (?parse<span class="er">@</span>Form<span class="er">@@</span>QAEXAAV?<span class="er">$</span>basic_stringstream<span class="er">@</span>DU?<span class="er">$</span>char_traits<span class="er">@</span>D<span class="er">@</span>std<span class="er">@@</span>V?<span class="er">$</span>allocator<span class="er">@</span>D<span class="er">@</span><span class="dv">2</span><span class="er">@@</span>std<span class="er">@@@</span>Z)</span>
<span id="cb490-2"><a href="#cb490-2" aria-hidden="true"></a><span class="dv">1</span>&gt;Form.obj : error LNK2019: unresolved external symbol <span class="st">&quot;public: virtual void __thiscall Field::parse(class std::basic_stringstream&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &amp;)&quot;</span> (?parse<span class="er">@</span>Field<span class="er">@@</span>UAEXAAV?<span class="er">$</span>basic_stringstream<span class="er">@</span>DU?<span class="er">$</span>char_traits<span class="er">@</span>D<span class="er">@</span>std<span class="er">@@</span>V?<span class="er">$</span>allocator<span class="er">@</span>D<span class="er">@</span><span class="dv">2</span><span class="er">@@</span>std<span class="er">@@@</span>Z) referenced in function <span class="st">&quot;public: __thiscall InputField::InputField(class std::basic_stringstream&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &amp;)&quot;</span> (??<span class="dv">0</span><span class="er">InputField@@</span>QAE<span class="er">@</span>AAV?<span class="er">$</span>basic_stringstream<span class="er">@</span>DU?<span class="er">$</span>char_traits<span class="er">@</span>D<span class="er">@</span>std<span class="er">@@</span>V?<span class="er">$</span>allocator<span class="er">@</span>D<span class="er">@</span><span class="dv">2</span><span class="er">@@</span>std<span class="er">@@@</span>Z)</span>
<span id="cb490-3"><a href="#cb490-3" aria-hidden="true"></a><span class="dv">1</span>&gt;Form.obj : error LNK2001: unresolved external symbol <span class="st">&quot;public: virtual void __thiscall Field::prompt(void)&quot;</span> (?prompt<span class="er">@</span>Field<span class="er">@@</span>UAEXXZ)</span>
<span id="cb490-4"><a href="#cb490-4" aria-hidden="true"></a><span class="dv">1</span>&gt;Form.obj : error LNK2001: unresolved external symbol <span class="st">&quot;public: virtual class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; __thiscall Field::getName(void)&quot;</span> (?getName<span class="er">@</span>Field<span class="er">@@</span>UAE?AV?<span class="er">$</span>basic_string<span class="er">@</span>DU?<span class="er">$</span>char_traits<span class="er">@</span>D<span class="er">@</span>std<span class="er">@@</span>V?<span class="er">$</span>allocator<span class="er">@</span>D<span class="er">@</span><span class="dv">2</span><span class="er">@@</span>std<span class="er">@@</span>XZ)</span>
<span id="cb490-5"><a href="#cb490-5" aria-hidden="true"></a><span class="dv">1</span>&gt;Form.obj : error LNK2001: unresolved external symbol <span class="st">&quot;public: virtual class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; __thiscall Field::getType(void)&quot;</span> (?getType<span class="er">@</span>Field<span class="er">@@</span>UAE?AV?<span class="er">$</span>basic_string<span class="er">@</span>DU?<span class="er">$</span>char_traits<span class="er">@</span>D<span class="er">@</span>std<span class="er">@@</span>V?<span class="er">$</span>allocator<span class="er">@</span>D<span class="er">@</span><span class="dv">2</span><span class="er">@@</span>std<span class="er">@@</span>XZ)</span>
<span id="cb490-6"><a href="#cb490-6" aria-hidden="true"></a><span class="dv">1</span>&gt;Form.obj : error LNK2001: unresolved external symbol <span class="st">&quot;public: virtual void __thiscall Field::describe(void)&quot;</span> (?describe<span class="er">@</span>Field<span class="er">@@</span>UAEXXZ)</span>
<span id="cb490-7"><a href="#cb490-7" aria-hidden="true"></a><span class="dv">1</span>&gt;C:\Users\tomy\Documents\Visual Studio <span class="dv">2010</span>\Projects\zapoctovkac++\Debug\zapoctovkac++.exe : fatal error LNK1120: <span class="dv">6</span> unresolved externals</span></code></pre></div>
</section>
<section id="answer-accepted-score-286" class="level4">
<h4>Answer accepted (score 286)</h4>
<p>This error often means that some function has a declaration, but not a definition.</p>
<p>Example:</p>
<div class="sourceCode" id="cb491"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb491-1"><a href="#cb491-1" aria-hidden="true"></a><span class="co">// A.hpp</span></span>
<span id="cb491-2"><a href="#cb491-2" aria-hidden="true"></a><span class="kw">class</span> A</span>
<span id="cb491-3"><a href="#cb491-3" aria-hidden="true"></a>{</span>
<span id="cb491-4"><a href="#cb491-4" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb491-5"><a href="#cb491-5" aria-hidden="true"></a>  <span class="dt">void</span> myFunc(); <span class="co">// Function declaration</span></span>
<span id="cb491-6"><a href="#cb491-6" aria-hidden="true"></a>};</span>
<span id="cb491-7"><a href="#cb491-7" aria-hidden="true"></a></span>
<span id="cb491-8"><a href="#cb491-8" aria-hidden="true"></a><span class="co">// A.cpp</span></span>
<span id="cb491-9"><a href="#cb491-9" aria-hidden="true"></a></span>
<span id="cb491-10"><a href="#cb491-10" aria-hidden="true"></a><span class="co">// Function definition</span></span>
<span id="cb491-11"><a href="#cb491-11" aria-hidden="true"></a><span class="dt">void</span> A::myFunc()</span>
<span id="cb491-12"><a href="#cb491-12" aria-hidden="true"></a>{</span>
<span id="cb491-13"><a href="#cb491-13" aria-hidden="true"></a>  <span class="co">// do stuff</span></span>
<span id="cb491-14"><a href="#cb491-14" aria-hidden="true"></a>}</span></code></pre></div>
<p><strong>In your case, the definition cannot be found.</strong> The issue could be that you are including a header file, which brings in some function declarations, but you either:</p>
<ol>
<li>
do not define the functions in your cpp file (if you wrote this code yourself)
</li>
<li>
do not include the lib/dll file that contains the definitions
</li>
</ol>
<p>A common mistake is that you define a function as a standalone and forget the class selector, e.g. <code>A::</code>, in your <em>.cpp</em> file:</p>
<p>
<strong>Wrong:</strong> <code>void myFunc() { /* do stuff */ }</code> <br><strong>Right:</strong> <code>void A::myFunc() { /* do stuff */ }</code>
</p>
</section>
<section id="answer-2-score-24" class="level4">
<h4>Answer 2 (score 24)</h4>
<p>Check you are including all the source files within your solution that you are referencing.</p>
<p>If you are not including the source file (and thus the implementation) for the class <code>Field</code> in your project it won’t be built and you will be unable to link during compilation.</p>
<p>Alternatively, perhaps you are using a static or dynamic library and have forgotten to tell the linker about the <code>.lib</code>s?</p>
</section>
<section id="answer-3-score-11" class="level4">
<h4>Answer 3 (score 11)</h4>
<p>It looks to be missing a library or include, you can try to figure out what class of your library that have getName, getType etc … and put that in the header file or using <code>#include</code>.</p>
<p>Also if these happen to be from an external library, make sure you reference to them on your project file. For example, if this class belongs to an abc.lib then in your Visual Studio</p>
<ol>
<li>
Click on Project Properties.
</li>
<li>
Go to Configuration Properties, C/C++, Generate, verify you point to the abc.lib location under Additional Include Directories. Under Linker, Input, make sure you have the abc.lib under Additional Dependencies.
</li>
</ol>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="what-is-the-difference-between-const-int-const-int-const-and-int-const-score-459578-in-2017" class="level3">
<h3>79: What is the difference between const int<em>, const int </em> const, and int const *? (score <a href="https://stackoverflow.com/q/1143262.html">459578</a> in 2017)</h3>
<section id="question-76" class="level4">
<h4>Question</h4>
<p>I always mess up how to use <code>const int*</code>, <code>const int * const</code>, and <code>int const *</code> correctly. Is there a set of rules defining what you can and cannot do?</p>
<p>I want to know all the do’s and all don’ts in terms of assignments, passing to the functions, etc.</p>
</section>
<section id="answer-accepted-score-2072" class="level4">
<h4>Answer accepted (score 2072)</h4>
<p>Read it backwards (as driven by <a href="http://c-faq.com/decl/spiral.anderson.html" rel="noreferrer">Clockwise/Spiral Rule</a>):</p>
<ul>
<li>
<code>int*</code> - pointer to int
</li>
<li>
<code>int const *</code> - pointer to const int
</li>
<li>
<code>int * const</code> - const pointer to int
</li>
<li>
<code>int const * const</code> - const pointer to const int
</li>
</ul>
<p>Now the first <code>const</code> can be on either side of the type so:</p>
<ul>
<li>
<code>const int *</code> == <code>int const *</code>
</li>
<li>
<code>const int * const</code> == <code>int const * const</code>
</li>
</ul>
<p>If you want to go really crazy you can do things like this:</p>
<ul>
<li>
<code>int **</code> - pointer to pointer to int
</li>
<li>
<code>int ** const</code> - a const pointer to a pointer to an int
</li>
<li>
<code>int * const *</code> - a pointer to a const pointer to an int
</li>
<li>
<code>int const **</code> - a pointer to a pointer to a const int
</li>
<li>
<code>int * const * const</code> - a const pointer to a const pointer to an int
</li>
<li>
…
</li>
</ul>
<p>And to make sure we are clear on the meaning of const</p>
<div class="sourceCode" id="cb492"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb492-1"><a href="#cb492-1" aria-hidden="true"></a><span class="at">const</span> <span class="dt">int</span>* foo;</span>
<span id="cb492-2"><a href="#cb492-2" aria-hidden="true"></a><span class="dt">int</span> *<span class="at">const</span> bar; <span class="co">//note, you actually need to set the pointer </span></span>
<span id="cb492-3"><a href="#cb492-3" aria-hidden="true"></a>                <span class="co">//here because you can&#39;t change it later ;)</span></span></code></pre></div>
<p><code>foo</code> is a variable pointer to a constant integer. This lets you change what you point to but not the value that you point to. Most often this is seen with C-style strings where you have a pointer to a <code>const char</code>. You may change which string you point to but you can’t change the content of these strings. This is important when the string itself is in the data segment of a program and shouldn’t be changed.</p>
<p><code>bar</code> is a constant or fixed pointer to a value that can be changed. This is like a reference without the extra syntactic sugar. Because of this fact, usually you would use a reference where you would use a <code>T* const</code> pointer unless you need to allow <code>NULL</code> pointers.</p>
</section>
<section id="answer-2-score-322" class="level4">
<h4>Answer 2 (score 322)</h4>
<p>
For those who don’t know about Clockwise/Spiral Rule: Start from the name of the variable, move clockwisely (in this case, move backward) to the next <strong>pointer</strong> or <strong>type</strong>. Repeat until expression ends.
</p>
<p>Here is a demo:</p>
<p><img src="https://i.stack.imgur.com/sT6ng.png" alt="pointer to int"></p>
<p><img src="https://i.stack.imgur.com/Zt0G2.png" alt="const pointer to int const"></p>
<p><img src="https://i.stack.imgur.com/kXH8P.png" alt="pointer to int const"></p>
<p><img src="https://i.stack.imgur.com/UeqZO.png" alt="pointer to const int"></p>
<p><img src="https://i.stack.imgur.com/f5ftV.png" alt="const pointer to int"></p>
</section>
<section id="answer-3-score-137" class="level4">
<h4>Answer 3 (score 137)</h4>
<p>I think everything is answered here already, but I just want to add that you should beware of <code>typedef</code>s! They’re NOT just text replacements.</p>
<p>For example:</p>
<div class="sourceCode" id="cb493"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb493-1"><a href="#cb493-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="dt">char</span> *ASTRING;</span>
<span id="cb493-2"><a href="#cb493-2" aria-hidden="true"></a><span class="at">const</span> ASTRING astring;</span></code></pre></div>
<p>The type of <code>astring</code> is <code>char * const</code>, not <code>const char *</code>. This is one reason I always tend to put <code>const</code> to the right of the type, and never at the start.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="undefined-reference-to-vtable-score-455622-in-2019" class="level3">
<h3>80: Undefined reference to vtable (score <a href="https://stackoverflow.com/q/3065154.html">455622</a> in 2019)</h3>
<section id="question-77" class="level4">
<h4>Question</h4>
<p>When building my C++ program, I’m getting the error message</p>
<blockquote>
undefined reference to ’vtable…
</blockquote>
<p>What is the cause of this problem? How do I fix it?</p>
<hr>
<p>It so happens that I’m getting the error for the following code (The class in question is CGameModule.) and I cannot for the life of me understand what the problem is. At first, I thought it was related to forgetting to give a virtual function a body, but as far as I understand, everything is all here. The inheritance chain is a little long, but here is the related source code. I’m not sure what other information I should provide.</p>
<p>Note: The constructor is where this error is happening, it’d seem.</p>
<p>My code:</p>
<div class="sourceCode" id="cb494"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb494-1"><a href="#cb494-1" aria-hidden="true"></a><span class="kw">class</span> CGameModule : <span class="kw">public</span> CDasherModule {</span>
<span id="cb494-2"><a href="#cb494-2" aria-hidden="true"></a> <span class="kw">public</span>:</span>
<span id="cb494-3"><a href="#cb494-3" aria-hidden="true"></a>  CGameModule(Dasher::CEventHandler *pEventHandler, CSettingsStore *pSettingsStore, CDasherInterfaceBase *pInterface, <span class="dt">ModuleID_t</span> iID, <span class="at">const</span> <span class="dt">char</span> *szName)</span>
<span id="cb494-4"><a href="#cb494-4" aria-hidden="true"></a>  : CDasherModule(pEventHandler, pSettingsStore, iID, <span class="dv">0</span>, szName)</span>
<span id="cb494-5"><a href="#cb494-5" aria-hidden="true"></a>  { </span>
<span id="cb494-6"><a href="#cb494-6" aria-hidden="true"></a>      <span class="va">g_pLogger</span>-&gt;Log(<span class="st">&quot;Inside game module constructor&quot;</span>);   </span>
<span id="cb494-7"><a href="#cb494-7" aria-hidden="true"></a>      <span class="va">m_pInterface</span> = pInterface; </span>
<span id="cb494-8"><a href="#cb494-8" aria-hidden="true"></a>  }</span>
<span id="cb494-9"><a href="#cb494-9" aria-hidden="true"></a></span>
<span id="cb494-10"><a href="#cb494-10" aria-hidden="true"></a>  <span class="kw">virtual</span> ~CGameModule() {};</span>
<span id="cb494-11"><a href="#cb494-11" aria-hidden="true"></a></span>
<span id="cb494-12"><a href="#cb494-12" aria-hidden="true"></a>  <span class="bu">std::</span>string GetTypedTarget();</span>
<span id="cb494-13"><a href="#cb494-13" aria-hidden="true"></a></span>
<span id="cb494-14"><a href="#cb494-14" aria-hidden="true"></a>  <span class="bu">std::</span>string GetUntypedTarget();</span>
<span id="cb494-15"><a href="#cb494-15" aria-hidden="true"></a></span>
<span id="cb494-16"><a href="#cb494-16" aria-hidden="true"></a>  <span class="dt">bool</span> DecorateView(CDasherView *pView) {</span>
<span id="cb494-17"><a href="#cb494-17" aria-hidden="true"></a>      <span class="co">//g_pLogger-&gt;Log(&quot;Decorating the view&quot;);</span></span>
<span id="cb494-18"><a href="#cb494-18" aria-hidden="true"></a>      <span class="cf">return</span> <span class="kw">false</span>;</span>
<span id="cb494-19"><a href="#cb494-19" aria-hidden="true"></a>  }</span>
<span id="cb494-20"><a href="#cb494-20" aria-hidden="true"></a></span>
<span id="cb494-21"><a href="#cb494-21" aria-hidden="true"></a>  <span class="dt">void</span> SetDasherModel(CDasherModel *pModel) { <span class="va">m_pModel</span> = pModel; }</span>
<span id="cb494-22"><a href="#cb494-22" aria-hidden="true"></a></span>
<span id="cb494-23"><a href="#cb494-23" aria-hidden="true"></a></span>
<span id="cb494-24"><a href="#cb494-24" aria-hidden="true"></a>  <span class="kw">virtual</span> <span class="dt">void</span> HandleEvent(Dasher::CEvent *pEvent); </span>
<span id="cb494-25"><a href="#cb494-25" aria-hidden="true"></a></span>
<span id="cb494-26"><a href="#cb494-26" aria-hidden="true"></a> <span class="kw">private</span>:</span>
<span id="cb494-27"><a href="#cb494-27" aria-hidden="true"></a></span>
<span id="cb494-28"><a href="#cb494-28" aria-hidden="true"></a></span>
<span id="cb494-29"><a href="#cb494-29" aria-hidden="true"></a></span>
<span id="cb494-30"><a href="#cb494-30" aria-hidden="true"></a>  CDasherNode *pLastTypedNode;</span>
<span id="cb494-31"><a href="#cb494-31" aria-hidden="true"></a></span>
<span id="cb494-32"><a href="#cb494-32" aria-hidden="true"></a></span>
<span id="cb494-33"><a href="#cb494-33" aria-hidden="true"></a>  CDasherNode *pNextTargetNode;</span>
<span id="cb494-34"><a href="#cb494-34" aria-hidden="true"></a></span>
<span id="cb494-35"><a href="#cb494-35" aria-hidden="true"></a></span>
<span id="cb494-36"><a href="#cb494-36" aria-hidden="true"></a>  <span class="bu">std::</span>string <span class="va">m_sTargetString</span>;</span>
<span id="cb494-37"><a href="#cb494-37" aria-hidden="true"></a></span>
<span id="cb494-38"><a href="#cb494-38" aria-hidden="true"></a></span>
<span id="cb494-39"><a href="#cb494-39" aria-hidden="true"></a>  <span class="dt">size_t</span> <span class="va">m_stCurrentStringPos</span>;</span>
<span id="cb494-40"><a href="#cb494-40" aria-hidden="true"></a></span>
<span id="cb494-41"><a href="#cb494-41" aria-hidden="true"></a></span>
<span id="cb494-42"><a href="#cb494-42" aria-hidden="true"></a>  CDasherModel *<span class="va">m_pModel</span>;</span>
<span id="cb494-43"><a href="#cb494-43" aria-hidden="true"></a></span>
<span id="cb494-44"><a href="#cb494-44" aria-hidden="true"></a></span>
<span id="cb494-45"><a href="#cb494-45" aria-hidden="true"></a>  CDasherInterfaceBase *<span class="va">m_pInterface</span>;</span>
<span id="cb494-46"><a href="#cb494-46" aria-hidden="true"></a>};</span></code></pre></div>
<p>Inherits from…</p>
<div class="sourceCode" id="cb495"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb495-1"><a href="#cb495-1" aria-hidden="true"></a><span class="kw">class</span> CDasherModule;</span>
<span id="cb495-2"><a href="#cb495-2" aria-hidden="true"></a><span class="kw">typedef</span> <span class="bu">std::</span>vector&lt;CDasherModule*&gt;::<span class="dt">size_type</span> <span class="dt">ModuleID_t</span>;</span>
<span id="cb495-3"><a href="#cb495-3" aria-hidden="true"></a></span>
<span id="cb495-4"><a href="#cb495-4" aria-hidden="true"></a><span class="co">/// </span><span class="an">\ingroup</span><span class="co"> </span><span class="do">Core</span></span>
<span id="cb495-5"><a href="#cb495-5" aria-hidden="true"></a><span class="co">/// </span><span class="an">@{</span></span>
<span id="cb495-6"><a href="#cb495-6" aria-hidden="true"></a><span class="kw">class</span> CDasherModule : <span class="kw">public</span> Dasher::CDasherComponent {</span>
<span id="cb495-7"><a href="#cb495-7" aria-hidden="true"></a> <span class="kw">public</span>:</span>
<span id="cb495-8"><a href="#cb495-8" aria-hidden="true"></a>  CDasherModule(Dasher::CEventHandler * pEventHandler, CSettingsStore * pSettingsStore, <span class="dt">ModuleID_t</span> iID, <span class="dt">int</span> iType, <span class="at">const</span> <span class="dt">char</span> *szName);</span>
<span id="cb495-9"><a href="#cb495-9" aria-hidden="true"></a></span>
<span id="cb495-10"><a href="#cb495-10" aria-hidden="true"></a>  <span class="kw">virtual</span> <span class="dt">ModuleID_t</span> GetID();</span>
<span id="cb495-11"><a href="#cb495-11" aria-hidden="true"></a>  <span class="kw">virtual</span> <span class="dt">void</span> SetID(<span class="dt">ModuleID_t</span>);</span>
<span id="cb495-12"><a href="#cb495-12" aria-hidden="true"></a>  <span class="kw">virtual</span> <span class="dt">int</span> GetType();</span>
<span id="cb495-13"><a href="#cb495-13" aria-hidden="true"></a>  <span class="kw">virtual</span> <span class="at">const</span> <span class="dt">char</span> *GetName();</span>
<span id="cb495-14"><a href="#cb495-14" aria-hidden="true"></a></span>
<span id="cb495-15"><a href="#cb495-15" aria-hidden="true"></a>  <span class="kw">virtual</span> <span class="dt">bool</span> GetSettings(SModuleSettings **pSettings, <span class="dt">int</span> *iCount) {</span>
<span id="cb495-16"><a href="#cb495-16" aria-hidden="true"></a>    <span class="cf">return</span> <span class="kw">false</span>;</span>
<span id="cb495-17"><a href="#cb495-17" aria-hidden="true"></a>  };</span>
<span id="cb495-18"><a href="#cb495-18" aria-hidden="true"></a></span>
<span id="cb495-19"><a href="#cb495-19" aria-hidden="true"></a> <span class="kw">private</span>:</span>
<span id="cb495-20"><a href="#cb495-20" aria-hidden="true"></a>  <span class="dt">ModuleID_t</span> <span class="va">m_iID</span>;</span>
<span id="cb495-21"><a href="#cb495-21" aria-hidden="true"></a>  <span class="dt">int</span> <span class="va">m_iType</span>;</span>
<span id="cb495-22"><a href="#cb495-22" aria-hidden="true"></a>  <span class="at">const</span> <span class="dt">char</span> *<span class="va">m_szName</span>;</span>
<span id="cb495-23"><a href="#cb495-23" aria-hidden="true"></a>};</span></code></pre></div>
<p>Which inherits from….</p>
<div class="sourceCode" id="cb496"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb496-1"><a href="#cb496-1" aria-hidden="true"></a><span class="kw">namespace</span> Dasher {</span>
<span id="cb496-2"><a href="#cb496-2" aria-hidden="true"></a>  <span class="kw">class</span> CEvent;</span>
<span id="cb496-3"><a href="#cb496-3" aria-hidden="true"></a>  <span class="kw">class</span> CEventHandler;</span>
<span id="cb496-4"><a href="#cb496-4" aria-hidden="true"></a>  <span class="kw">class</span> CDasherComponent;</span>
<span id="cb496-5"><a href="#cb496-5" aria-hidden="true"></a>};</span>
<span id="cb496-6"><a href="#cb496-6" aria-hidden="true"></a></span>
<span id="cb496-7"><a href="#cb496-7" aria-hidden="true"></a><span class="co">/// </span><span class="an">\ingroup</span><span class="co"> </span><span class="do">Core</span></span>
<span id="cb496-8"><a href="#cb496-8" aria-hidden="true"></a><span class="co">/// </span><span class="an">@{</span></span>
<span id="cb496-9"><a href="#cb496-9" aria-hidden="true"></a><span class="kw">class</span> Dasher::CDasherComponent {</span>
<span id="cb496-10"><a href="#cb496-10" aria-hidden="true"></a> <span class="kw">public</span>:</span>
<span id="cb496-11"><a href="#cb496-11" aria-hidden="true"></a>  CDasherComponent(Dasher::CEventHandler* pEventHandler, CSettingsStore* pSettingsStore);</span>
<span id="cb496-12"><a href="#cb496-12" aria-hidden="true"></a>  <span class="kw">virtual</span> ~CDasherComponent();</span>
<span id="cb496-13"><a href="#cb496-13" aria-hidden="true"></a></span>
<span id="cb496-14"><a href="#cb496-14" aria-hidden="true"></a>  <span class="dt">void</span> InsertEvent(Dasher::CEvent * pEvent);</span>
<span id="cb496-15"><a href="#cb496-15" aria-hidden="true"></a>  <span class="kw">virtual</span> <span class="dt">void</span> HandleEvent(Dasher::CEvent * pEvent) {};</span>
<span id="cb496-16"><a href="#cb496-16" aria-hidden="true"></a></span>
<span id="cb496-17"><a href="#cb496-17" aria-hidden="true"></a>  <span class="dt">bool</span> GetBoolParameter(<span class="dt">int</span> iParameter) <span class="at">const</span>;</span>
<span id="cb496-18"><a href="#cb496-18" aria-hidden="true"></a>  <span class="dt">void</span> SetBoolParameter(<span class="dt">int</span> iParameter, <span class="dt">bool</span> bValue) <span class="at">const</span>;</span>
<span id="cb496-19"><a href="#cb496-19" aria-hidden="true"></a></span>
<span id="cb496-20"><a href="#cb496-20" aria-hidden="true"></a>  <span class="dt">long</span> GetLongParameter(<span class="dt">int</span> iParameter) <span class="at">const</span>;</span>
<span id="cb496-21"><a href="#cb496-21" aria-hidden="true"></a>  <span class="dt">void</span> SetLongParameter(<span class="dt">int</span> iParameter, <span class="dt">long</span> lValue) <span class="at">const</span>;</span>
<span id="cb496-22"><a href="#cb496-22" aria-hidden="true"></a></span>
<span id="cb496-23"><a href="#cb496-23" aria-hidden="true"></a>  <span class="bu">std::</span>string GetStringParameter(<span class="dt">int</span> iParameter) <span class="at">const</span>;</span>
<span id="cb496-24"><a href="#cb496-24" aria-hidden="true"></a>  <span class="dt">void</span>        SetStringParameter(<span class="dt">int</span> iParameter, <span class="at">const</span> <span class="bu">std::</span>string &amp; sValue) <span class="at">const</span>;</span>
<span id="cb496-25"><a href="#cb496-25" aria-hidden="true"></a></span>
<span id="cb496-26"><a href="#cb496-26" aria-hidden="true"></a>  ParameterType   GetParameterType(<span class="dt">int</span> iParameter) <span class="at">const</span>;</span>
<span id="cb496-27"><a href="#cb496-27" aria-hidden="true"></a>  <span class="bu">std::</span>string     GetParameterName(<span class="dt">int</span> iParameter) <span class="at">const</span>;</span>
<span id="cb496-28"><a href="#cb496-28" aria-hidden="true"></a></span>
<span id="cb496-29"><a href="#cb496-29" aria-hidden="true"></a> <span class="kw">protected</span>:</span>
<span id="cb496-30"><a href="#cb496-30" aria-hidden="true"></a>  Dasher::CEventHandler *<span class="va">m_pEventHandler</span>;</span>
<span id="cb496-31"><a href="#cb496-31" aria-hidden="true"></a>  CSettingsStore *<span class="va">m_pSettingsStore</span>;</span>
<span id="cb496-32"><a href="#cb496-32" aria-hidden="true"></a>};</span>
<span id="cb496-33"><a href="#cb496-33" aria-hidden="true"></a><span class="co">/// </span><span class="an">@}</span></span>
<span id="cb496-34"><a href="#cb496-34" aria-hidden="true"></a></span>
<span id="cb496-35"><a href="#cb496-35" aria-hidden="true"></a></span>
<span id="cb496-36"><a href="#cb496-36" aria-hidden="true"></a></span>
<span id="cb496-37"><a href="#cb496-37" aria-hidden="true"></a><span class="pp">#endif</span></span></code></pre></div>
</section>
<section id="answer-accepted-score-52" class="level4">
<h4>Answer accepted (score 52)</h4>
<p>So, I’ve figured out the issue and it was a combination of bad logic and not being totally familiar with the automake/autotools world. I was adding the correct files to my Makefile.am template, but I wasn’t sure which step in our build process actually created the makefile itself. So, I was compiling with an old makefile that had no idea about my new files whatsoever.</p>
<p>Thanks for the responses and the link to the GCC FAQ. I will be sure to read that to avoid this problem occurring for a real reason.</p>
</section>
<section id="answer-2-score-380" class="level4">
<h4>Answer 2 (score 380)</h4>
<p>The <a href="http://gcc.gnu.org/faq.html
#vtables" rel="noreferrer">GCC FAQ</a> has an entry on it:</p>
<blockquote>
The solution is to ensure that all virtual methods that are not pure are defined. Note that a destructor must be defined even if it is declared pure-virtual [class.dtor]/7.
</blockquote>
</section>
<section id="answer-3-score-150" class="level4">
<h4>Answer 3 (score 150)</h4>
<p>For what it is worth, forgetting a body on a virtual destructor generates the following:</p>
<blockquote>
undefined reference to `vtable for CYourClass’.
</blockquote>
<p>I am adding a note because the error message is deceptive. (This was with gcc version 4.6.3.)</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-do-you-declare-an-interface-in-c-score-455244-in-2009" class="level3">
<h3>81: How do you declare an interface in C++? (score <a href="https://stackoverflow.com/q/318064.html">455244</a> in 2009)</h3>
<section id="question-78" class="level4">
<h4>Question</h4>
<p>How do I setup a class that represents an interface? Is this just an abstract base class?</p>
</section>
<section id="answer-accepted-score-670" class="level4">
<h4>Answer accepted (score 670)</h4>
<p>To expand on the answer by <a href="https://stackoverflow.com/questions/318064/how-do-you-declare-an-interface-in-c
#318084">bradtgmurray</a>, you may want to make one exception to the pure virtual method list of your interface by adding a virtual destructor. This allows you to pass pointer ownership to another party without exposing the concrete derived class. The destructor doesn’t have to do anything, because the interface doesn’t have any concrete members. It might seem contradictory to define a function as both virtual and inline, but trust me - it isn’t.</p>
<div class="sourceCode" id="cb497"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb497-1"><a href="#cb497-1" aria-hidden="true"></a><span class="kw">class</span> IDemo</span>
<span id="cb497-2"><a href="#cb497-2" aria-hidden="true"></a>{</span>
<span id="cb497-3"><a href="#cb497-3" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb497-4"><a href="#cb497-4" aria-hidden="true"></a>        <span class="kw">virtual</span> ~IDemo() {}</span>
<span id="cb497-5"><a href="#cb497-5" aria-hidden="true"></a>        <span class="kw">virtual</span> <span class="dt">void</span> OverrideMe() = <span class="dv">0</span>;</span>
<span id="cb497-6"><a href="#cb497-6" aria-hidden="true"></a>};</span>
<span id="cb497-7"><a href="#cb497-7" aria-hidden="true"></a></span>
<span id="cb497-8"><a href="#cb497-8" aria-hidden="true"></a><span class="kw">class</span> Parent</span>
<span id="cb497-9"><a href="#cb497-9" aria-hidden="true"></a>{</span>
<span id="cb497-10"><a href="#cb497-10" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb497-11"><a href="#cb497-11" aria-hidden="true"></a>        <span class="kw">virtual</span> ~Parent();</span>
<span id="cb497-12"><a href="#cb497-12" aria-hidden="true"></a>};</span>
<span id="cb497-13"><a href="#cb497-13" aria-hidden="true"></a></span>
<span id="cb497-14"><a href="#cb497-14" aria-hidden="true"></a><span class="kw">class</span> Child : <span class="kw">public</span> Parent, <span class="kw">public</span> IDemo</span>
<span id="cb497-15"><a href="#cb497-15" aria-hidden="true"></a>{</span>
<span id="cb497-16"><a href="#cb497-16" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb497-17"><a href="#cb497-17" aria-hidden="true"></a>        <span class="kw">virtual</span> <span class="dt">void</span> OverrideMe()</span>
<span id="cb497-18"><a href="#cb497-18" aria-hidden="true"></a>        {</span>
<span id="cb497-19"><a href="#cb497-19" aria-hidden="true"></a>            <span class="co">//do stuff</span></span>
<span id="cb497-20"><a href="#cb497-20" aria-hidden="true"></a>        }</span>
<span id="cb497-21"><a href="#cb497-21" aria-hidden="true"></a>};</span></code></pre></div>
<p>You don’t have to include a body for the virtual destructor - it turns out some compilers have trouble optimizing an empty destructor and you’re better off using the default.</p>
</section>
<section id="answer-2-score-236" class="level4">
<h4>Answer 2 (score 236)</h4>
<p>Make a class with pure virtual methods. Use the interface by creating another class that overrides those virtual methods.</p>
<p>A pure virtual method is a class method that is defined as virtual and assigned to 0.</p>
<div class="sourceCode" id="cb498"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb498-1"><a href="#cb498-1" aria-hidden="true"></a><span class="kw">class</span> IDemo</span>
<span id="cb498-2"><a href="#cb498-2" aria-hidden="true"></a>{</span>
<span id="cb498-3"><a href="#cb498-3" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb498-4"><a href="#cb498-4" aria-hidden="true"></a>        <span class="kw">virtual</span> ~IDemo() {}</span>
<span id="cb498-5"><a href="#cb498-5" aria-hidden="true"></a>        <span class="kw">virtual</span> <span class="dt">void</span> OverrideMe() = <span class="dv">0</span>;</span>
<span id="cb498-6"><a href="#cb498-6" aria-hidden="true"></a>};</span>
<span id="cb498-7"><a href="#cb498-7" aria-hidden="true"></a></span>
<span id="cb498-8"><a href="#cb498-8" aria-hidden="true"></a><span class="kw">class</span> Child : <span class="kw">public</span> IDemo</span>
<span id="cb498-9"><a href="#cb498-9" aria-hidden="true"></a>{</span>
<span id="cb498-10"><a href="#cb498-10" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb498-11"><a href="#cb498-11" aria-hidden="true"></a>        <span class="kw">virtual</span> <span class="dt">void</span> OverrideMe()</span>
<span id="cb498-12"><a href="#cb498-12" aria-hidden="true"></a>        {</span>
<span id="cb498-13"><a href="#cb498-13" aria-hidden="true"></a>            <span class="co">//do stuff</span></span>
<span id="cb498-14"><a href="#cb498-14" aria-hidden="true"></a>        }</span>
<span id="cb498-15"><a href="#cb498-15" aria-hidden="true"></a>};</span></code></pre></div>
</section>
<section id="answer-3-score-144" class="level4">
<h4>Answer 3 (score 144)</h4>
<p>The whole reason you have a special Interface type-category in addition to abstract base classes in C #/<a href="https://stackoverflow.com/questions/1321122/what-is-an-interface-in-java">Java</a> is because C#/Java do not support multiple inheritance.</p>
<p>C++ supports multiple inheritance, and so a special type isn’t needed. An abstract base class with no non-abstract (pure virtual) methods is functionally equivalent to a C #/Java interface.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="what-is-the-c-function-to-raise-a-number-to-a-power-score-452219-in-2009" class="level3">
<h3>82: What is the C++ function to raise a number to a power? (score <a href="https://stackoverflow.com/q/845912.html">452219</a> in 2009)</h3>
<section id="question-79" class="level4">
<h4>Question</h4>
<p>How do I raise a number to a power?</p>
<div class="sourceCode" id="cb499"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb499-1"><a href="#cb499-1" aria-hidden="true"></a><span class="dv">2</span>^<span class="dv">1</span></span>
<span id="cb499-2"><a href="#cb499-2" aria-hidden="true"></a></span>
<span id="cb499-3"><a href="#cb499-3" aria-hidden="true"></a><span class="dv">2</span>^<span class="dv">2</span></span>
<span id="cb499-4"><a href="#cb499-4" aria-hidden="true"></a></span>
<span id="cb499-5"><a href="#cb499-5" aria-hidden="true"></a><span class="dv">2</span>^<span class="dv">3</span></span></code></pre></div>
<p>etc…</p>
</section>
<section id="answer-accepted-score-132" class="level4">
<h4>Answer accepted (score 132)</h4>
<p>
pow() in the cmath library. More info <a href="http://en.cppreference.com/w/cpp/numeric/math/pow" rel="noreferrer">here</a>. Don’t forget to put <code>#include&amp;lt;cmath&amp;gt;</code> at the top of the file.
</p>
</section>
<section id="answer-2-score-90-1" class="level4">
<h4>Answer 2 (score 90)</h4>
<p><code>std::pow</code> in the <code>&amp;lt;cmath&amp;gt;</code> header has these overloads:</p>
<div class="sourceCode" id="cb500"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb500-1"><a href="#cb500-1" aria-hidden="true"></a>pow(<span class="dt">float</span>, <span class="dt">float</span>);</span>
<span id="cb500-2"><a href="#cb500-2" aria-hidden="true"></a>pow(<span class="dt">float</span>, <span class="dt">int</span>);</span>
<span id="cb500-3"><a href="#cb500-3" aria-hidden="true"></a>pow(<span class="dt">double</span>, <span class="dt">double</span>); <span class="co">// taken over from C</span></span>
<span id="cb500-4"><a href="#cb500-4" aria-hidden="true"></a>pow(<span class="dt">double</span>, <span class="dt">int</span>);</span>
<span id="cb500-5"><a href="#cb500-5" aria-hidden="true"></a>pow(<span class="dt">long</span> <span class="dt">double</span>, <span class="dt">long</span> <span class="dt">double</span>);</span>
<span id="cb500-6"><a href="#cb500-6" aria-hidden="true"></a>pow(<span class="dt">long</span> <span class="dt">double</span>, <span class="dt">int</span>);</span></code></pre></div>
<p>Now you can’t just do</p>
<div class="sourceCode" id="cb501"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb501-1"><a href="#cb501-1" aria-hidden="true"></a>pow(<span class="dv">2</span>, N)</span></code></pre></div>
<p>with N being an int, because it doesn’t know which of <code>float</code>, <code>double</code>, or <code>long double</code> version it should take, and you would get an ambiguity error. All three would need a conversion from int to floating point, and all three are equally costly!</p>
<p>Therefore, be sure to have the first argument typed so it matches one of those three perfectly. I usually use <code>double</code></p>
<div class="sourceCode" id="cb502"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb502-1"><a href="#cb502-1" aria-hidden="true"></a>pow(<span class="fl">2.0</span>, N)</span></code></pre></div>
<p>Some lawyer crap from me again. I’ve often fallen in this pitfall myself, so I’m going to warn you about it.</p>
</section>
<section id="answer-3-score-19-1" class="level4">
<h4>Answer 3 (score 19)</h4>
<p>In C++ the “^” operator is a bitwise OR. It does not work for raising to a power. The x &lt;&lt; n is a left shift of the binary number which is the same as multiplying x by 2 n number of times and that can only be used when raising 2 to a power. The POW function is a math function that will work generically.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="why-can-templates-only-be-implemented-in-the-header-file-score-450124-in-2019" class="level3">
<h3>83: Why can templates only be implemented in the header file? (score <a href="https://stackoverflow.com/q/495021.html">450124</a> in 2019)</h3>
<section id="question-80" class="level4">
<h4>Question</h4>
<p>Quote from <a href="http://books.google.com/books?id=n9VEG2Gp5pkC&amp;pg=PA10&amp;lpg=PA10&amp;dq=%22The%20only%20portable%20way%20of%20using%20templates%20at%20the%20moment%20is%20to%20implement%20them%20in%20header%20files%20by%20using%20inline%20functions.%22&amp;source=bl&amp;ots=Ref8pl8dPX&amp;sig=t4K5gvxtBblpcujNxodpwMfei8I&amp;hl=en&amp;ei=qkR6TvbiGojE0AHq4IzqAg&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=3&amp;ved=0CC8Q6AEwAg
#v=onepage&amp;q=%22The%20only%20portable%20way%20of%20using%20templates%20at%20the%20moment%20is%20to%20implement%20them%20in%20header%20files%20by%20using%20inline%20functions.%22&amp;f=false" rel="noreferrer">The C++ standard library: a tutorial and handbook</a>:</p>
<blockquote>
The only portable way of using templates at the moment is to implement them in header files by using inline functions.
</blockquote>
<p>Why is this?</p>
<p>(Clarification: header files are not the <em>only</em> portable solution. But they are the most convenient portable solution.)</p>
</section>
<section id="answer-accepted-score-1437" class="level4">
<h4>Answer accepted (score 1437)</h4>
<p>It is <em>not</em> necessary to put the implementation in the header file, see the alternative solution at the end of this answer.</p>
<p>Anyway, the reason your code is failing is that, when instantiating a template, the compiler creates a new class with the given template argument. For example:</p>
<div class="sourceCode" id="cb503"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb503-1"><a href="#cb503-1" aria-hidden="true"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb503-2"><a href="#cb503-2" aria-hidden="true"></a><span class="kw">struct</span> Foo</span>
<span id="cb503-3"><a href="#cb503-3" aria-hidden="true"></a>{</span>
<span id="cb503-4"><a href="#cb503-4" aria-hidden="true"></a>    T bar;</span>
<span id="cb503-5"><a href="#cb503-5" aria-hidden="true"></a>    <span class="dt">void</span> doSomething(T param) {<span class="co">/* do stuff using T */</span>}</span>
<span id="cb503-6"><a href="#cb503-6" aria-hidden="true"></a>};</span>
<span id="cb503-7"><a href="#cb503-7" aria-hidden="true"></a></span>
<span id="cb503-8"><a href="#cb503-8" aria-hidden="true"></a><span class="co">// somewhere in a .cpp</span></span>
<span id="cb503-9"><a href="#cb503-9" aria-hidden="true"></a>Foo&lt;<span class="dt">int</span>&gt; f; </span></code></pre></div>
<p>When reading this line, the compiler will create a new class (let’s call it <code>FooInt</code>), which is equivalent to the following:</p>
<div class="sourceCode" id="cb504"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb504-1"><a href="#cb504-1" aria-hidden="true"></a><span class="kw">struct</span> FooInt</span>
<span id="cb504-2"><a href="#cb504-2" aria-hidden="true"></a>{</span>
<span id="cb504-3"><a href="#cb504-3" aria-hidden="true"></a>    <span class="dt">int</span> bar;</span>
<span id="cb504-4"><a href="#cb504-4" aria-hidden="true"></a>    <span class="dt">void</span> doSomething(<span class="dt">int</span> param) {<span class="co">/* do stuff using int */</span>}</span>
<span id="cb504-5"><a href="#cb504-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>Consequently, the compiler needs to have access to the implementation of the methods, to instantiate them with the template argument (in this case <code>int</code>). If these implementations were not in the header, they wouldn’t be accessible, and therefore the compiler wouldn’t be able to instantiate the template.</p>
<p>A common solution to this is to write the template declaration in a header file, then implement the class in an implementation file (for example .tpp), and include this implementation file at the end of the header.</p>
<div class="sourceCode" id="cb505"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb505-1"><a href="#cb505-1" aria-hidden="true"></a><span class="co">// Foo.h</span></span>
<span id="cb505-2"><a href="#cb505-2" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb505-3"><a href="#cb505-3" aria-hidden="true"></a><span class="kw">struct</span> Foo</span>
<span id="cb505-4"><a href="#cb505-4" aria-hidden="true"></a>{</span>
<span id="cb505-5"><a href="#cb505-5" aria-hidden="true"></a>    <span class="dt">void</span> doSomething(T param);</span>
<span id="cb505-6"><a href="#cb505-6" aria-hidden="true"></a>};</span>
<span id="cb505-7"><a href="#cb505-7" aria-hidden="true"></a></span>
<span id="cb505-8"><a href="#cb505-8" aria-hidden="true"></a></span>
<span id="cb505-9"><a href="#cb505-9" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;Foo.tpp&quot;</span></span>
<span id="cb505-10"><a href="#cb505-10" aria-hidden="true"></a></span>
<span id="cb505-11"><a href="#cb505-11" aria-hidden="true"></a><span class="co">// Foo.tpp</span></span>
<span id="cb505-12"><a href="#cb505-12" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb505-13"><a href="#cb505-13" aria-hidden="true"></a><span class="dt">void</span> Foo&lt;T&gt;::doSomething(T param)</span>
<span id="cb505-14"><a href="#cb505-14" aria-hidden="true"></a>{</span>
<span id="cb505-15"><a href="#cb505-15" aria-hidden="true"></a>    <span class="co">//implementation</span></span>
<span id="cb505-16"><a href="#cb505-16" aria-hidden="true"></a>}</span></code></pre></div>
<p>This way, implementation is still separated from declaration, but is accessible to the compiler.</p>
<p>Another solution is to keep the implementation separated, and explicitly instantiate all the template instances you’ll need:</p>
<div class="sourceCode" id="cb506"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb506-1"><a href="#cb506-1" aria-hidden="true"></a><span class="co">// Foo.h</span></span>
<span id="cb506-2"><a href="#cb506-2" aria-hidden="true"></a></span>
<span id="cb506-3"><a href="#cb506-3" aria-hidden="true"></a><span class="co">// no implementation</span></span>
<span id="cb506-4"><a href="#cb506-4" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt; <span class="kw">struct</span> Foo { ... };</span>
<span id="cb506-5"><a href="#cb506-5" aria-hidden="true"></a></span>
<span id="cb506-6"><a href="#cb506-6" aria-hidden="true"></a><span class="co">//----------------------------------------    </span></span>
<span id="cb506-7"><a href="#cb506-7" aria-hidden="true"></a><span class="co">// Foo.cpp</span></span>
<span id="cb506-8"><a href="#cb506-8" aria-hidden="true"></a></span>
<span id="cb506-9"><a href="#cb506-9" aria-hidden="true"></a><span class="co">// implementation of Foo&#39;s methods</span></span>
<span id="cb506-10"><a href="#cb506-10" aria-hidden="true"></a></span>
<span id="cb506-11"><a href="#cb506-11" aria-hidden="true"></a><span class="co">// explicit instantiations</span></span>
<span id="cb506-12"><a href="#cb506-12" aria-hidden="true"></a><span class="kw">template</span> <span class="kw">class</span> Foo&lt;<span class="dt">int</span>&gt;;</span>
<span id="cb506-13"><a href="#cb506-13" aria-hidden="true"></a><span class="kw">template</span> <span class="kw">class</span> Foo&lt;<span class="dt">float</span>&gt;;</span>
<span id="cb506-14"><a href="#cb506-14" aria-hidden="true"></a><span class="co">// You will only be able to use Foo with int or float</span></span></code></pre></div>
<p>If my explanation isn’t clear enough, you can have a look at the <a href="https://isocpp.org/wiki/faq/templates
#templates-defn-vs-decl" rel="noreferrer">C++ Super-FAQ on this subject</a>.</p>
</section>
<section id="answer-2-score-235" class="level4">
<h4>Answer 2 (score 235)</h4>
<p>Plenty correct answers here, but I wanted to add this (for completeness):</p>
<p>If you, at the bottom of the implementation cpp file, do explicit instantiation of all the types the template will be used with, the linker will be able to find them as usual.</p>
<p>Edit: Adding example of explicit template instantiation. Used after the template has been defined, and all member functions has been defined.</p>
<div class="sourceCode" id="cb507"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb507-1"><a href="#cb507-1" aria-hidden="true"></a><span class="kw">template</span> <span class="kw">class</span> vector&lt;<span class="dt">int</span>&gt;;</span></code></pre></div>
<p>This will instantiate (and thus make available to the linker) the class and all its member functions (only). Similar syntax works for template functions, so if you have non-member operator overloads you may need to do the same for those.</p>
<p>The above example is fairly useless since vector is fully defined in headers, except when a common include file (precompiled header?) uses <code>extern template class vector&amp;lt;int&amp;gt;</code> so as to keep it from instantiating it in all the <em>other</em> (1000?) files that use vector.</p>
</section>
<section id="answer-3-score-225" class="level4">
<h4>Answer 3 (score 225)</h4>
<p>It’s because of the requirement for separate compilation and because templates are instantiation-style polymorphism.</p>
<p>Lets get a little closer to concrete for an explanation. Say I’ve got the following files:</p>
<ul>
<li>
foo.h
<ul>
<li>
declares the interface of <code>class MyClass&amp;lt;T&amp;gt;</code>
</li>
</ul>
</li>
<li>
foo.cpp
<ul>
<li>
defines the implementation of <code>class MyClass&amp;lt;T&amp;gt;</code>
</li>
</ul>
</li>
<li>
bar.cpp
<ul>
<li>
uses <code>MyClass&amp;lt;int&amp;gt;</code>
</li>
</ul>
</li>
</ul>
<p>Separate compilation means I should be able to compile <strong>foo.cpp</strong> independently from <strong>bar.cpp</strong>. The compiler does all the hard work of analysis, optimization, and code generation on each compilation unit completely independently; we don’t need to do whole-program analysis. It’s only the linker that needs to handle the entire program at once, and the linker’s job is substantially easier.</p>
<p><strong>bar.cpp</strong> doesn’t even need to exist when I compile <strong>foo.cpp</strong>, but I should still be able to link the <strong>foo.o</strong> I already had together with the <strong>bar.o</strong> I’ve only just produced, without needing to recompile <strong>foo.cpp</strong>. <strong>foo.cpp</strong> could even be compiled into a dynamic library, distributed somewhere else without <strong>foo.cpp</strong>, and linked with code they write years after I wrote <strong>foo.cpp</strong>.</p>
<p>“Instantiation-style polymorphism” means that the template <code>MyClass&amp;lt;T&amp;gt;</code> isn’t really a generic class that can be compiled to code that can work for any value of <code>T</code>. That would add overhead such as boxing, needing to pass function pointers to allocators and constructors, etc. The intention of C++ templates is to avoid having to write nearly identical <code>class MyClass_int</code>, <code>class MyClass_float</code>, etc, but to still be able to end up with compiled code that is mostly as if we <em>had</em> written each version separately. So a template is <em>literally</em> a template; a class template is <em>not</em> a class, it’s a recipe for creating a new class for each <code>T</code> we encounter. A template cannot be compiled into code, only the result of instantiating the template can be compiled.</p>
<p>So when <strong>foo.cpp</strong> is compiled, the compiler can’t see <strong>bar.cpp</strong> to know that <code>MyClass&amp;lt;int&amp;gt;</code> is needed. It can see the template <code>MyClass&amp;lt;T&amp;gt;</code>, but it can’t emit code for that (it’s a template, not a class). And when <strong>bar.cpp</strong> is compiled, the compiler can see that it needs to create a <code>MyClass&amp;lt;int&amp;gt;</code>, but it can’t see the template <code>MyClass&amp;lt;T&amp;gt;</code> (only its interface in <strong>foo.h</strong>) so it can’t create it.</p>
<p>If <strong>foo.cpp</strong> itself uses <code>MyClass&amp;lt;int&amp;gt;</code>, then code for that will be generated while compiling <strong>foo.cpp</strong>, so when <strong>bar.o</strong> is linked to <strong>foo.o</strong> they can be hooked up and will work. We can use that fact to allow a finite set of template instantiations to be implemented in a .cpp file by writing a single template. But there’s no way for <strong>bar.cpp</strong> to use the template <em>as a template</em> and instantiate it on whatever types it likes; it can only use pre-existing versions of the templated class that the author of <strong>foo.cpp</strong> thought to provide.</p>
<p>You might think that when compiling a template the compiler should “generate all versions”, with the ones that are never used being filtered out during linking. Aside from the huge overhead and the extreme difficulties such an approach would face because “type modifier” features like pointers and arrays allow even just the built-in types to give rise to an infinite number of types, what happens when I now extend my program by adding:</p>
<ul>
<li>
baz.cpp
<ul>
<li>
declares and implements <code>class BazPrivate</code>, and uses <code>MyClass&amp;lt;BazPrivate&amp;gt;</code>
</li>
</ul>
</li>
</ul>
<p>There is no possible way that this could work unless we either</p>
<ol>
<li>
Have to recompile <strong>foo.cpp</strong> every time we change <em>any other file in the program</em>, in case it added a new novel instantiation of <code>MyClass&amp;lt;T&amp;gt;</code>
</li>
<li>
Require that <strong>baz.cpp</strong> contains (possibly via header includes) the full template of <code>MyClass&amp;lt;T&amp;gt;</code>, so that the compiler can generate <code>MyClass&amp;lt;BazPrivate&amp;gt;</code> during compilation of <strong>baz.cpp</strong>.
</li>
</ol>
<p>Nobody likes (1), because whole-program-analysis compilation systems take <em>forever</em> to compile , and because it makes it impossible to distribute compiled libraries without the source code. So we have (2) instead.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="stdcin-input-with-spaces-score-448215-in-2018" class="level3">
<h3>84: std::cin input with spaces? (score <a href="https://stackoverflow.com/q/5838711.html">448215</a> in 2018)</h3>
<section id="question-81" class="level4">
<h4>Question</h4>
<div class="sourceCode" id="cb508"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb508-1"><a href="#cb508-1" aria-hidden="true"></a></span>
<span id="cb508-2"><a href="#cb508-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb508-3"><a href="#cb508-3" aria-hidden="true"></a></span>
<span id="cb508-4"><a href="#cb508-4" aria-hidden="true"></a><span class="bu">std::</span>string input;</span>
<span id="cb508-5"><a href="#cb508-5" aria-hidden="true"></a><span class="bu">std::</span>cin &gt;&gt; input;</span></code></pre></div>
<p>The user wants to enter “Hello World”. But <code>cin</code> fails at the space between the two words. How can I make <code>cin</code> take in the whole of <code>Hello World</code>?</p>
<p>I’m actually doing this with structs and <code>cin.getline</code> doesn’t seem to work. Here’s my code:</p>
<div class="sourceCode" id="cb509"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb509-1"><a href="#cb509-1" aria-hidden="true"></a><span class="kw">struct</span> cd</span>
<span id="cb509-2"><a href="#cb509-2" aria-hidden="true"></a>{</span>
<span id="cb509-3"><a href="#cb509-3" aria-hidden="true"></a>    <span class="bu">std::</span>string CDTitle[<span class="dv">50</span>];</span>
<span id="cb509-4"><a href="#cb509-4" aria-hidden="true"></a>    <span class="bu">std::</span>string Artist[<span class="dv">50</span>];</span>
<span id="cb509-5"><a href="#cb509-5" aria-hidden="true"></a>    <span class="dt">int</span> number_of_songs[<span class="dv">50</span>];</span>
<span id="cb509-6"><a href="#cb509-6" aria-hidden="true"></a>};</span>
<span id="cb509-7"><a href="#cb509-7" aria-hidden="true"></a></span>
<span id="cb509-8"><a href="#cb509-8" aria-hidden="true"></a><span class="bu">std::</span>cin.getline(library.number_of_songs[libNumber], <span class="dv">250</span>);</span></code></pre></div>
<p>This yields an error. Any ideas?</p>
</section>
<section id="answer-accepted-score-92" class="level4">
<h4>Answer accepted (score 92)</h4>
<p>You have to use <a href="http://en.cppreference.com/w/cpp/io/basic_istream/getline" rel="noreferrer"><code>cin.getline()</code></a>:</p>
<div class="sourceCode" id="cb510"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb510-1"><a href="#cb510-1" aria-hidden="true"></a><span class="dt">char</span> input[<span class="dv">100</span>];</span>
<span id="cb510-2"><a href="#cb510-2" aria-hidden="true"></a>cin.getline(input,<span class="kw">sizeof</span>(input));</span></code></pre></div>
</section>
<section id="answer-2-score-190" class="level4">
<h4>Answer 2 (score 190)</h4>
<p>It doesn’t “fail”; it just stops reading. It sees a lexical token as a “string”.</p>
<p>Use <a href="http://en.cppreference.com/w/cpp/string/basic_string/getline" rel="noreferrer"><code>std::getline</code></a>:</p>
<div class="sourceCode" id="cb511"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb511-1"><a href="#cb511-1" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb511-2"><a href="#cb511-2" aria-hidden="true"></a>{</span>
<span id="cb511-3"><a href="#cb511-3" aria-hidden="true"></a>   <span class="bu">std::</span>string name, title;</span>
<span id="cb511-4"><a href="#cb511-4" aria-hidden="true"></a></span>
<span id="cb511-5"><a href="#cb511-5" aria-hidden="true"></a>   <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Enter your name: &quot;</span>;</span>
<span id="cb511-6"><a href="#cb511-6" aria-hidden="true"></a>   <span class="bu">std::</span>getline(<span class="bu">std::</span>cin, name);</span>
<span id="cb511-7"><a href="#cb511-7" aria-hidden="true"></a></span>
<span id="cb511-8"><a href="#cb511-8" aria-hidden="true"></a>   <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Enter your favourite movie: &quot;</span>;</span>
<span id="cb511-9"><a href="#cb511-9" aria-hidden="true"></a>   <span class="bu">std::</span>getline(<span class="bu">std::</span>cin, title);</span>
<span id="cb511-10"><a href="#cb511-10" aria-hidden="true"></a></span>
<span id="cb511-11"><a href="#cb511-11" aria-hidden="true"></a>   <span class="bu">std::</span>cout &lt;&lt; name &lt;&lt; <span class="st">&quot;&#39;s favourite movie is &quot;</span> &lt;&lt; title;</span>
<span id="cb511-12"><a href="#cb511-12" aria-hidden="true"></a>}</span></code></pre></div>
<p>Note that this is <em>not</em> the same as <code>std::istream::getline</code>, which works with C-style <code>char</code> buffers rather than <code>std::string</code>s.</p>
<p><strong>Update</strong></p>
<p>Your edited question bears little resemblance to the original.</p>
<p>You were trying to <code>getline</code> into an <code>int</code>, not a string or character buffer. The formatting operations of streams only work with <code>operator&amp;lt;&amp;lt;</code> and <code>operator&amp;gt;&amp;gt;</code>. Either use one of them (and tweak accordingly for multi-word input), or use <code>getline</code> and lexically convert to <code>int</code> after-the-fact.</p>
</section>
<section id="answer-3-score-24" class="level4">
<h4>Answer 3 (score 24)</h4>
<p>Use :</p>
<div class="sourceCode" id="cb512"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb512-1"><a href="#cb512-1" aria-hidden="true"></a>getline(cin, input);</span></code></pre></div>
<p>the function can be found in</p>
<div class="sourceCode" id="cb513"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb513-1"><a href="#cb513-1" aria-hidden="true"></a></span>
<span id="cb513-2"><a href="#cb513-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-to-replace-all-occurrences-of-a-character-in-string-score-446818-in-2016" class="level3">
<h3>85: How to replace all occurrences of a character in string? (score <a href="https://stackoverflow.com/q/2896600.html">446818</a> in 2016)</h3>
<section id="question-82" class="level4">
<h4>Question</h4>
<p>What is the effective way to replace all occurrences of a character with another character in <code>std::string</code>?</p>
</section>
<section id="answer-accepted-score-682" class="level4">
<h4>Answer accepted (score 682)</h4>
<p><code>std::string</code> doesn’t contain such function but you could use stand-alone <code>replace</code> function from <code>algorithm</code> header.</p>
<div class="sourceCode" id="cb514"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb514-1"><a href="#cb514-1" aria-hidden="true"></a></span>
<span id="cb514-2"><a href="#cb514-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb514-3"><a href="#cb514-3" aria-hidden="true"></a></span>
<span id="cb514-4"><a href="#cb514-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb514-5"><a href="#cb514-5" aria-hidden="true"></a></span>
<span id="cb514-6"><a href="#cb514-6" aria-hidden="true"></a><span class="dt">void</span> some_func() {</span>
<span id="cb514-7"><a href="#cb514-7" aria-hidden="true"></a>  <span class="bu">std::</span>string s = <span class="st">&quot;example string&quot;</span>;</span>
<span id="cb514-8"><a href="#cb514-8" aria-hidden="true"></a>  <span class="bu">std::</span>replace( s.begin(), s.end(), <span class="ch">&#39;x&#39;</span>, <span class="ch">&#39;y&#39;</span>); <span class="co">// replace all &#39;x&#39; to &#39;y&#39;</span></span>
<span id="cb514-9"><a href="#cb514-9" aria-hidden="true"></a>}</span></code></pre></div>
</section>
<section id="answer-2-score-125" class="level4">
<h4>Answer 2 (score 125)</h4>
<p>I thought I’d toss in the <a href="http://www.boost.org/doc/libs/release/libs/algorithm/string">boost solution</a> as well:</p>
<div class="sourceCode" id="cb515"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb515-1"><a href="#cb515-1" aria-hidden="true"></a></span>
<span id="cb515-2"><a href="#cb515-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;boost/algorithm/string/replace.hpp&gt;</span></span>
<span id="cb515-3"><a href="#cb515-3" aria-hidden="true"></a></span>
<span id="cb515-4"><a href="#cb515-4" aria-hidden="true"></a><span class="co">// in place</span></span>
<span id="cb515-5"><a href="#cb515-5" aria-hidden="true"></a><span class="bu">std::</span>string in_place = <span class="st">&quot;blah</span></span>
<span id="cb515-6"><a href="#cb515-6" aria-hidden="true"></a><span class="pp">#</span><span class="er">blah&quot;;</span></span>
<span id="cb515-7"><a href="#cb515-7" aria-hidden="true"></a><span class="ex">boost::</span>replace_all(in_place, <span class="st">&quot;</span></span>
<span id="cb515-8"><a href="#cb515-8" aria-hidden="true"></a><span class="pp">#</span><span class="er">&quot;, &quot;@&quot;);</span></span>
<span id="cb515-9"><a href="#cb515-9" aria-hidden="true"></a></span>
<span id="cb515-10"><a href="#cb515-10" aria-hidden="true"></a><span class="co">// copy</span></span>
<span id="cb515-11"><a href="#cb515-11" aria-hidden="true"></a><span class="at">const</span> <span class="bu">std::</span>string input = <span class="st">&quot;blah</span></span>
<span id="cb515-12"><a href="#cb515-12" aria-hidden="true"></a><span class="pp">#</span><span class="er">blah&quot;;</span></span>
<span id="cb515-13"><a href="#cb515-13" aria-hidden="true"></a><span class="bu">std::</span>string output = <span class="ex">boost::</span>replace_all_copy(input, <span class="st">&quot;</span></span>
<span id="cb515-14"><a href="#cb515-14" aria-hidden="true"></a><span class="pp">#</span><span class="er">&quot;, &quot;@&quot;);</span></span></code></pre></div>
</section>
<section id="answer-3-score-112" class="level4">
<h4>Answer 3 (score 112)</h4>
<p>The question is centered on <code>character</code> replacement, but, as I found this page very useful (especially <a href="https://stackoverflow.com/users/18664/konrad">Konrad</a>’s remark), I’d like to share this more generalized implementation, which allows to deal with <code>substrings</code> as well:</p>
<div class="sourceCode" id="cb516"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb516-1"><a href="#cb516-1" aria-hidden="true"></a><span class="bu">std::</span>string ReplaceAll(<span class="bu">std::</span>string str, <span class="at">const</span> <span class="bu">std::</span>string&amp; from, <span class="at">const</span> <span class="bu">std::</span>string&amp; to) {</span>
<span id="cb516-2"><a href="#cb516-2" aria-hidden="true"></a>    <span class="dt">size_t</span> start_pos = <span class="dv">0</span>;</span>
<span id="cb516-3"><a href="#cb516-3" aria-hidden="true"></a>    <span class="cf">while</span>((start_pos = str.find(from, start_pos)) != <span class="bu">std::</span>string<span class="bu">::</span>npos) {</span>
<span id="cb516-4"><a href="#cb516-4" aria-hidden="true"></a>        str.replace(start_pos, from.length(), to);</span>
<span id="cb516-5"><a href="#cb516-5" aria-hidden="true"></a>        start_pos += to.length(); <span class="co">// Handles case where &#39;to&#39; is a substring of &#39;from&#39;</span></span>
<span id="cb516-6"><a href="#cb516-6" aria-hidden="true"></a>    }</span>
<span id="cb516-7"><a href="#cb516-7" aria-hidden="true"></a>    <span class="cf">return</span> str;</span>
<span id="cb516-8"><a href="#cb516-8" aria-hidden="true"></a>}</span></code></pre></div>
<p>Usage:</p>
<div class="sourceCode" id="cb517"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb517-1"><a href="#cb517-1" aria-hidden="true"></a><span class="bu">std::</span>cout &lt;&lt; ReplaceAll(string(<span class="st">&quot;Number Of Beans&quot;</span>), <span class="bu">std::</span>string(<span class="st">&quot; &quot;</span>), <span class="bu">std::</span>string(<span class="st">&quot;_&quot;</span>)) &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb517-2"><a href="#cb517-2" aria-hidden="true"></a><span class="bu">std::</span>cout &lt;&lt; ReplaceAll(string(<span class="st">&quot;ghghjghugtghty&quot;</span>), <span class="bu">std::</span>string(<span class="st">&quot;gh&quot;</span>), <span class="bu">std::</span>string(<span class="st">&quot;X&quot;</span>)) &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb517-3"><a href="#cb517-3" aria-hidden="true"></a><span class="bu">std::</span>cout &lt;&lt; ReplaceAll(string(<span class="st">&quot;ghghjghugtghty&quot;</span>), <span class="bu">std::</span>string(<span class="st">&quot;gh&quot;</span>), <span class="bu">std::</span>string(<span class="st">&quot;h&quot;</span>)) &lt;&lt; <span class="bu">std::</span>endl;</span></code></pre></div>
<p>Outputs:</p>
<blockquote>
<p>Number_Of_Beans</p>
<p>XXjXugtXty</p>
hhjhugthty
</blockquote>
<hr>
<p><strong>EDIT:</strong></p>
<p><em>The above can be implemented in a more suitable way, in case performances are of your concern, by returning nothing (<code>void</code>) and performing the changes directly on the string <code>str</code> given as argument, passed <strong>by address</strong> instead of <strong>by value</strong>. This would avoid useless and costly copy of the original string, while returning the result. Your call, then…</em></p>
<p><em>Code :</em></p>
<div class="sourceCode" id="cb518"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb518-1"><a href="#cb518-1" aria-hidden="true"></a><span class="at">static</span> <span class="kw">inline</span> <span class="dt">void</span> ReplaceAll2(<span class="bu">std::</span>string &amp;str, <span class="at">const</span> <span class="bu">std::</span>string&amp; from, <span class="at">const</span> <span class="bu">std::</span>string&amp; to)</span>
<span id="cb518-2"><a href="#cb518-2" aria-hidden="true"></a>{</span>
<span id="cb518-3"><a href="#cb518-3" aria-hidden="true"></a>    <span class="co">// Same inner code...</span></span>
<span id="cb518-4"><a href="#cb518-4" aria-hidden="true"></a>    <span class="co">// No return statement</span></span>
<span id="cb518-5"><a href="#cb518-5" aria-hidden="true"></a>}</span></code></pre></div>
<hr>
<p>Hope this will be helpful for some others…</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="what-is-a-lambda-expression-in-c11-score-445636-in-2011" class="level3">
<h3>86: What is a lambda expression in C++11? (score <a href="https://stackoverflow.com/q/7627098.html">445636</a> in 2011)</h3>
<section id="question-83" class="level4">
<h4>Question</h4>
<p>What is a lambda expression in C++11? When would I use one? What class of problem do they solve that wasn’t possible prior to their introduction?</p>
<p>A few examples, and use cases would be useful.</p>
</section>
<section id="answer-accepted-score-1412" class="level4">
<h4>Answer accepted (score 1412)</h4>
<h5>
The problem
</h1>
<p>C++ includes useful generic functions like <code>std::for_each</code> and <code>std::transform</code>, which can be very handy. Unfortunately they can also be quite cumbersome to use, particularly if the <a href="https://stackoverflow.com/questions/356950/c-functors-and-their-uses">functor</a> you would like to apply is unique to the particular function.</p>
<div class="sourceCode" id="cb519"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb519-1"><a href="#cb519-1" aria-hidden="true"></a></span>
<span id="cb519-2"><a href="#cb519-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb519-3"><a href="#cb519-3" aria-hidden="true"></a></span>
<span id="cb519-4"><a href="#cb519-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb519-5"><a href="#cb519-5" aria-hidden="true"></a></span>
<span id="cb519-6"><a href="#cb519-6" aria-hidden="true"></a><span class="kw">namespace</span> {</span>
<span id="cb519-7"><a href="#cb519-7" aria-hidden="true"></a>  <span class="kw">struct</span> f {</span>
<span id="cb519-8"><a href="#cb519-8" aria-hidden="true"></a>    <span class="dt">void</span> <span class="kw">operator</span>()(<span class="dt">int</span>) {</span>
<span id="cb519-9"><a href="#cb519-9" aria-hidden="true"></a>      <span class="co">// do something</span></span>
<span id="cb519-10"><a href="#cb519-10" aria-hidden="true"></a>    }</span>
<span id="cb519-11"><a href="#cb519-11" aria-hidden="true"></a>  };</span>
<span id="cb519-12"><a href="#cb519-12" aria-hidden="true"></a>}</span>
<span id="cb519-13"><a href="#cb519-13" aria-hidden="true"></a></span>
<span id="cb519-14"><a href="#cb519-14" aria-hidden="true"></a><span class="dt">void</span> func(<span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;&amp; v) {</span>
<span id="cb519-15"><a href="#cb519-15" aria-hidden="true"></a>  f f;</span>
<span id="cb519-16"><a href="#cb519-16" aria-hidden="true"></a>  <span class="bu">std::</span>for_each(v.begin(), v.end(), f);</span>
<span id="cb519-17"><a href="#cb519-17" aria-hidden="true"></a>}</span></code></pre></div>
<p>If you only use <code>f</code> once and in that specific place it seems overkill to be writing a whole class just to do something trivial and one off.</p>
<p>In C++03 you might be tempted to write something like the following, to keep the functor local:</p>
<div class="sourceCode" id="cb520"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb520-1"><a href="#cb520-1" aria-hidden="true"></a><span class="dt">void</span> func2(<span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;&amp; v) {</span>
<span id="cb520-2"><a href="#cb520-2" aria-hidden="true"></a>  <span class="kw">struct</span> {</span>
<span id="cb520-3"><a href="#cb520-3" aria-hidden="true"></a>    <span class="dt">void</span> <span class="kw">operator</span>()(<span class="dt">int</span>) {</span>
<span id="cb520-4"><a href="#cb520-4" aria-hidden="true"></a>       <span class="co">// do something</span></span>
<span id="cb520-5"><a href="#cb520-5" aria-hidden="true"></a>    }</span>
<span id="cb520-6"><a href="#cb520-6" aria-hidden="true"></a>  } f;</span>
<span id="cb520-7"><a href="#cb520-7" aria-hidden="true"></a>  <span class="bu">std::</span>for_each(v.begin(), v.end(), f);</span>
<span id="cb520-8"><a href="#cb520-8" aria-hidden="true"></a>}</span></code></pre></div>
<p>however this is not allowed, <code>f</code> cannot be passed to a <a href="https://en.cppreference.com/w/cpp/language/function_template" rel="noreferrer">template</a> function in C++03.</p>
<h5>
The new solution
</h1>
<p>C++11 introduces lambdas allow you to write an inline, anonymous functor to replace the <code>struct f</code>. For small simple examples this can be cleaner to read (it keeps everything in one place) and potentially simpler to maintain, for example in the simplest form:</p>
<div class="sourceCode" id="cb521"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb521-1"><a href="#cb521-1" aria-hidden="true"></a><span class="dt">void</span> func3(<span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;&amp; v) {</span>
<span id="cb521-2"><a href="#cb521-2" aria-hidden="true"></a>  <span class="bu">std::</span>for_each(v.begin(), v.end(), [](<span class="dt">int</span>) { <span class="co">/* do something here*/</span> });</span>
<span id="cb521-3"><a href="#cb521-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>Lambda functions are just syntactic sugar for anonymous functors.</p>
<h5>
Return types
</h2>
<p>In simple cases the return type of the lambda is deduced for you, e.g.:</p>
<div class="sourceCode" id="cb522"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb522-1"><a href="#cb522-1" aria-hidden="true"></a><span class="dt">void</span> func4(<span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt;&amp; v) {</span>
<span id="cb522-2"><a href="#cb522-2" aria-hidden="true"></a>  <span class="bu">std::</span>transform(v.begin(), v.end(), v.begin(),</span>
<span id="cb522-3"><a href="#cb522-3" aria-hidden="true"></a>                 [](<span class="dt">double</span> d) { <span class="cf">return</span> d &lt; <span class="fl">0.00001</span> ? <span class="dv">0</span> : d; }</span>
<span id="cb522-4"><a href="#cb522-4" aria-hidden="true"></a>                 );</span>
<span id="cb522-5"><a href="#cb522-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>however when you start to write more complex lambdas you will quickly encounter cases where the return type cannot be deduced by the compiler, e.g.:</p>
<div class="sourceCode" id="cb523"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb523-1"><a href="#cb523-1" aria-hidden="true"></a><span class="dt">void</span> func4(<span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt;&amp; v) {</span>
<span id="cb523-2"><a href="#cb523-2" aria-hidden="true"></a>    <span class="bu">std::</span>transform(v.begin(), v.end(), v.begin(),</span>
<span id="cb523-3"><a href="#cb523-3" aria-hidden="true"></a>        [](<span class="dt">double</span> d) {</span>
<span id="cb523-4"><a href="#cb523-4" aria-hidden="true"></a>            <span class="cf">if</span> (d &lt; <span class="fl">0.0001</span>) {</span>
<span id="cb523-5"><a href="#cb523-5" aria-hidden="true"></a>                <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb523-6"><a href="#cb523-6" aria-hidden="true"></a>            } <span class="cf">else</span> {</span>
<span id="cb523-7"><a href="#cb523-7" aria-hidden="true"></a>                <span class="cf">return</span> d;</span>
<span id="cb523-8"><a href="#cb523-8" aria-hidden="true"></a>            }</span>
<span id="cb523-9"><a href="#cb523-9" aria-hidden="true"></a>        });</span>
<span id="cb523-10"><a href="#cb523-10" aria-hidden="true"></a>}</span></code></pre></div>
<p>To resolve this you are allowed to explicitly specify a return type for a lambda function, using <code>-&amp;gt; T</code>:</p>
<div class="sourceCode" id="cb524"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb524-1"><a href="#cb524-1" aria-hidden="true"></a><span class="dt">void</span> func4(<span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt;&amp; v) {</span>
<span id="cb524-2"><a href="#cb524-2" aria-hidden="true"></a>    <span class="bu">std::</span>transform(v.begin(), v.end(), v.begin(),</span>
<span id="cb524-3"><a href="#cb524-3" aria-hidden="true"></a>        [](<span class="dt">double</span> d) -&gt; <span class="dt">double</span> {</span>
<span id="cb524-4"><a href="#cb524-4" aria-hidden="true"></a>            <span class="cf">if</span> (d &lt; <span class="fl">0.0001</span>) {</span>
<span id="cb524-5"><a href="#cb524-5" aria-hidden="true"></a>                <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb524-6"><a href="#cb524-6" aria-hidden="true"></a>            } <span class="cf">else</span> {</span>
<span id="cb524-7"><a href="#cb524-7" aria-hidden="true"></a>                <span class="cf">return</span> d;</span>
<span id="cb524-8"><a href="#cb524-8" aria-hidden="true"></a>            }</span>
<span id="cb524-9"><a href="#cb524-9" aria-hidden="true"></a>        });</span>
<span id="cb524-10"><a href="#cb524-10" aria-hidden="true"></a>}</span></code></pre></div>
<h5>
“Capturing” variables
</h2>
<p>So far we’ve not used anything other than what was passed to the lambda within it, but we can also use other variables, within the lambda. If you want to access other variables you can use the capture clause (the <code>[]</code> of the expression), which has so far been unused in these examples, e.g.:</p>
<div class="sourceCode" id="cb525"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb525-1"><a href="#cb525-1" aria-hidden="true"></a><span class="dt">void</span> func5(<span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt;&amp; v, <span class="at">const</span> <span class="dt">double</span>&amp; epsilon) {</span>
<span id="cb525-2"><a href="#cb525-2" aria-hidden="true"></a>    <span class="bu">std::</span>transform(v.begin(), v.end(), v.begin(),</span>
<span id="cb525-3"><a href="#cb525-3" aria-hidden="true"></a>        [epsilon](<span class="dt">double</span> d.html) -&gt; <span class="dt">double</span> {</span>
<span id="cb525-4"><a href="#cb525-4" aria-hidden="true"></a>            <span class="cf">if</span> (d &lt; epsilon) {</span>
<span id="cb525-5"><a href="#cb525-5" aria-hidden="true"></a>                <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb525-6"><a href="#cb525-6" aria-hidden="true"></a>            } <span class="cf">else</span> {</span>
<span id="cb525-7"><a href="#cb525-7" aria-hidden="true"></a>                <span class="cf">return</span> d;</span>
<span id="cb525-8"><a href="#cb525-8" aria-hidden="true"></a>            }</span>
<span id="cb525-9"><a href="#cb525-9" aria-hidden="true"></a>        });</span>
<span id="cb525-10"><a href="#cb525-10" aria-hidden="true"></a>}</span></code></pre></div>
<p>You can capture by both reference and value, which you can specify using <code>&amp;amp;</code> and <code>=</code> respectively:</p>
<ul>
<li>
<code>[&amp;amp;epsilon]</code> capture by reference
</li>
<li>
<code>[&amp;amp;]</code> captures all variables used in the lambda by reference
</li>
<li>
<code>[=]</code> captures all variables used in the lambda by value
</li>
<li>
<code>[&amp;amp;, epsilon]</code> captures variables like with [&amp;], but epsilon by value
</li>
<li>
<code>[=, &amp;amp;epsilon]</code> captures variables like with [=], but epsilon by reference
</li>
</ul>
<p>The generated <code>operator()</code> is <code>const</code> by default, with the implication that captures will be <code>const</code> when you access them by default. This has the effect that each call with the same input would produce the same result, however you can <a href="https://stackoverflow.com/questions/5501959/why-does-c0xs-lambda-require-mutable-keyword-for-capture-by-value-by-defaul">mark the lambda as <code>mutable</code></a> to request that the <code>operator()</code> that is produced is not <code>const</code>.</p>
</section>
<section id="answer-2-score-799" class="level4">
<h4>Answer 2 (score 799)</h4>
<h5>
What is a lambda function?
</h1>
<p>The C++ concept of a lambda function originates in the lambda calculus and functional programming. A lambda is an unnamed function that is useful (in actual programming, not theory) for short snippets of code that are impossible to reuse and are not worth naming.</p>
<p>In C++ a lambda function is defined like this</p>
<div class="sourceCode" id="cb526"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb526-1"><a href="#cb526-1" aria-hidden="true"></a>[]() { } <span class="co">// barebone lambda</span></span></code></pre></div>
<p>or in all its glory</p>
<div class="sourceCode" id="cb527"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb527-1"><a href="#cb527-1" aria-hidden="true"></a>[]() <span class="at">mutable</span> -&gt; T { } <span class="co">// T is the return type, still lacking throw()</span></span></code></pre></div>
<p><code>[]</code> is the capture list, <code>()</code> the argument list and <code>{}</code> the function body.</p>
<h5>
The capture list
</h2>
<p>
The capture list defines what from the outside of the lambda should be available inside the function body and how. It can be either:
</p>
<ol>
<li>
a value: [x]
</li>
<li>
a reference [&amp;x]
</li>
<li>
any variable currently in scope by reference [&amp;]
</li>
<li>
same as 3, but by value [=]
</li>
</ol>
<p>You can mix any of the above in a comma separated list <code>[x, &amp;amp;y]</code>.</p>
<h5>
The argument list
</h2>
<p>The argument list is the same as in any other C++ function.</p>
<h5>
The function body
</h2>
<p>The code that will be executed when the lambda is actually called.</p>
<h5>
Return type deduction
</h2>
<p>If a lambda has only one return statement, the return type can be omitted and has the implicit type of <code>decltype(return_statement)</code>.</p>
<h5>
Mutable
</h2>
<p>If a lambda is marked mutable (e.g. <code>[]() mutable { }</code>) it is allowed to mutate the values that have been captured by value.</p>
<h5>
Use cases
</h1>
<p>The library defined by the ISO standard benefits heavily from lambdas and raises the usability several bars as now users don’t have to clutter their code with small functors in some accessible scope.</p>
<h5>
C++14
</h1>
<p>In C++14 lambdas have been extended by various proposals.</p>
<h5>
Initialized Lambda Captures
</h2>
<p>An element of the capture list can now be initialized with <code>=</code>. This allows renaming of variables and to capture by moving. An example taken from the standard:</p>
<div class="sourceCode" id="cb528"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb528-1"><a href="#cb528-1" aria-hidden="true"></a><span class="dt">int</span> x = <span class="dv">4</span>;</span>
<span id="cb528-2"><a href="#cb528-2" aria-hidden="true"></a><span class="kw">auto</span> y = [&amp;r = x, x = x+<span class="dv">1</span>]()-&gt;<span class="dt">int</span> {</span>
<span id="cb528-3"><a href="#cb528-3" aria-hidden="true"></a>            r += <span class="dv">2</span>;</span>
<span id="cb528-4"><a href="#cb528-4" aria-hidden="true"></a>            <span class="cf">return</span> x+<span class="dv">2</span>;</span>
<span id="cb528-5"><a href="#cb528-5" aria-hidden="true"></a>         }();  <span class="co">// Updates ::x to 6, and initializes y to 7.</span></span></code></pre></div>
<p>and one taken from Wikipedia showing how to capture with <code>std::move</code>:</p>
<div class="sourceCode" id="cb529"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb529-1"><a href="#cb529-1" aria-hidden="true"></a><span class="kw">auto</span> ptr = <span class="bu">std::</span>make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">10</span>); <span class="co">// See below for std::make_unique</span></span>
<span id="cb529-2"><a href="#cb529-2" aria-hidden="true"></a><span class="kw">auto</span> lambda = [ptr = <span class="bu">std::</span>move(ptr)] {<span class="cf">return</span> *ptr;};</span></code></pre></div>
<h5>
Generic Lambdas
</h2>
<p>
Lambdas can now be generic (<code>auto</code> would be equivalent to <code>T</code> here if <code>T</code> were a type template argument somewhere in the surrounding scope):
</p>
<div class="sourceCode" id="cb530"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb530-1"><a href="#cb530-1" aria-hidden="true"></a><span class="kw">auto</span> lambda = [](<span class="kw">auto</span> x, <span class="kw">auto</span> y) {<span class="cf">return</span> x + y;};</span></code></pre></div>
<h5>
Improved Return Type Deduction
</h2>
<p>C++14 allows deduced return types for every function and does not restrict it to functions of the form <code>return expression;</code>. This is also extended to lambdas.</p>
</section>
<section id="answer-3-score-165" class="level4">
<h4>Answer 3 (score 165)</h4>
<p>Lambda expressions are typically used to encapsulate algorithms so that they can be passed to another function. However, <strong>it is possible to execute a lambda immediately upon definition</strong>:</p>
<div class="sourceCode" id="cb531"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb531-1"><a href="#cb531-1" aria-hidden="true"></a>[&amp;](){ ...your code... }(); <span class="co">// immediately executed lambda expression</span></span></code></pre></div>
<p>is functionally equivalent to</p>
<div class="sourceCode" id="cb532"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb532-1"><a href="#cb532-1" aria-hidden="true"></a>{ ...your code... } <span class="co">// simple code block</span></span></code></pre></div>
<p>This makes lambda expressions <strong>a powerful tool for refactoring complex functions</strong>. You start by wrapping a code section in a lambda function as shown above. The process of explicit parameterization can then be performed gradually with intermediate testing after each step. Once you have the code-block fully parameterized (as demonstrated by the removal of the <code>&amp;amp;</code>), you can move the code to an external location and make it a normal function.</p>
<p>Similarly, you can use lambda expressions to <strong>initialize variables based on the result of an algorithm</strong>…</p>
<div class="sourceCode" id="cb533"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb533-1"><a href="#cb533-1" aria-hidden="true"></a><span class="dt">int</span> a = []( <span class="dt">int</span> b ){ <span class="dt">int</span> r=<span class="dv">1</span>; <span class="cf">while</span> (b&gt;<span class="dv">0</span>) r*=b--; <span class="cf">return</span> r; }(<span class="dv">5</span>); <span class="co">// 5!</span></span></code></pre></div>
<p>As <strong>a way of partitioning your program logic</strong>, you might even find it useful to pass a lambda expression as an argument to another lambda expression…</p>
<div class="sourceCode" id="cb534"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb534-1"><a href="#cb534-1" aria-hidden="true"></a>[&amp;]( <span class="bu">std::</span>function&lt;<span class="dt">void</span>(.html)&gt; algorithm ) <span class="co">// wrapper section</span></span>
<span id="cb534-2"><a href="#cb534-2" aria-hidden="true"></a>   {</span>
<span id="cb534-3"><a href="#cb534-3" aria-hidden="true"></a>   ...your wrapper code...</span>
<span id="cb534-4"><a href="#cb534-4" aria-hidden="true"></a>   algorithm();</span>
<span id="cb534-5"><a href="#cb534-5" aria-hidden="true"></a>   ...your wrapper code...</span>
<span id="cb534-6"><a href="#cb534-6" aria-hidden="true"></a>   }</span>
<span id="cb534-7"><a href="#cb534-7" aria-hidden="true"></a>([&amp;]() <span class="co">// algorithm section</span></span>
<span id="cb534-8"><a href="#cb534-8" aria-hidden="true"></a>   {</span>
<span id="cb534-9"><a href="#cb534-9" aria-hidden="true"></a>   ...your algorithm code...</span>
<span id="cb534-10"><a href="#cb534-10" aria-hidden="true"></a>   });</span></code></pre></div>
<p>Lambda expressions also let you create named <a href="http://en.wikipedia.org/wiki/Nested_function" rel="noreferrer"><strong>nested functions</strong></a>, which can be a convenient way of avoiding duplicate logic. Using named lambdas also tends to be a little easier on the eyes (compared to anonymous inline lambdas) when passing a non-trivial function as a parameter to another function. <em>Note: don’t forget the semicolon after the closing curly brace.</em></p>
<div class="sourceCode" id="cb535"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb535-1"><a href="#cb535-1" aria-hidden="true"></a><span class="kw">auto</span> algorithm = [&amp;]( <span class="dt">double</span> x, <span class="dt">double</span> m, <span class="dt">double</span> b .html) -&gt; <span class="dt">double</span></span>
<span id="cb535-2"><a href="#cb535-2" aria-hidden="true"></a>   {</span>
<span id="cb535-3"><a href="#cb535-3" aria-hidden="true"></a>   <span class="cf">return</span> m*x+b;</span>
<span id="cb535-4"><a href="#cb535-4" aria-hidden="true"></a>   };</span>
<span id="cb535-5"><a href="#cb535-5" aria-hidden="true"></a></span>
<span id="cb535-6"><a href="#cb535-6" aria-hidden="true"></a><span class="dt">int</span> a=algorithm(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>), b=algorithm(<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>);</span></code></pre></div>
<p>If subsequent profiling reveals significant initialization overhead for the function object, you might choose to rewrite this as a normal function.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="private-and-protected-members-c-score-443439-in-2018" class="level3">
<h3>87: Private and Protected Members : C++ (score <a href="https://stackoverflow.com/q/224966.html">443439</a> in 2018)</h3>
<section id="question-84" class="level4">
<h4>Question</h4>
<p>Can someone enlighten me as to the difference between <code>private</code> and <code>protected</code> members in classes?</p>
<p>I understand from best practice conventions that variables and functions which are not called outside the class should be made <code>private</code> - but looking at my <strong>MFC</strong> project, <strong>MFC</strong> seems to favor <code>protected</code>.</p>
<p>What’s the difference and which should I use?</p>
</section>
<section id="answer-accepted-score-357" class="level4">
<h4>Answer accepted (score 357)</h4>
<p>Private members are only accessible within the class defining them.</p>
<p>Protected members are accessible in the class that defines them and in classes that inherit from that class.</p>
<p>Edit: Both are also accessible by friends of their class, and in the case of protected members, by friends of their derived classes.</p>
<p>Edit 2: Use whatever makes sense in the context of your problem. You should try to make members private whenever you can to reduce coupling and protect the implementation of the base class, but if that’s not possible then use protected members. Check <a href="https://isocpp.org/wiki/faq/basics-of-inheritance" rel="noreferrer">C++ FAQ</a> for a better understanding of the issue. <a href="https://stackoverflow.com/questions/37011/protected-member-variables">This question about protected variables</a> might also help.</p>
</section>
<section id="answer-2-score-130-1" class="level4">
<h4>Answer 2 (score 130)</h4>
<p><strong>Public</strong> members of a class A are accessible for all and everyone.</p>
<p><strong>Protected</strong> members of a class A are not accessible outside of A’s code, but is accessible from the code of any class derived from A.</p>
<p><strong>Private</strong> members of a class A are not accessible outside of A’s code, or from the code of any class derived from A.</p>
<p>So, in the end, choosing between protected or private is answering the following questions: <strong>How much trust are you willing to put into the programmer of the derived class?</strong></p>
<p><strong>By default</strong>, assume the derived class is not to be trusted, and <strong>make your members private</strong>. If you have a very good reason to give free access of the mother class’ internals to its derived classes, then you can make them protected.</p>
</section>
<section id="answer-3-score-60" class="level4">
<h4>Answer 3 (score 60)</h4>
<p>Protected members can be accessed from derived classes. Private ones can’t.</p>
<div class="sourceCode" id="cb536"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb536-1"><a href="#cb536-1" aria-hidden="true"></a><span class="kw">class</span> Base {</span>
<span id="cb536-2"><a href="#cb536-2" aria-hidden="true"></a></span>
<span id="cb536-3"><a href="#cb536-3" aria-hidden="true"></a><span class="kw">private</span>: </span>
<span id="cb536-4"><a href="#cb536-4" aria-hidden="true"></a>  <span class="dt">int</span> MyPrivateInt;</span>
<span id="cb536-5"><a href="#cb536-5" aria-hidden="true"></a><span class="kw">protected</span>: </span>
<span id="cb536-6"><a href="#cb536-6" aria-hidden="true"></a>  <span class="dt">int</span> MyProtectedInt;</span>
<span id="cb536-7"><a href="#cb536-7" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb536-8"><a href="#cb536-8" aria-hidden="true"></a>  <span class="dt">int</span> MyPublicInt;</span>
<span id="cb536-9"><a href="#cb536-9" aria-hidden="true"></a>};</span>
<span id="cb536-10"><a href="#cb536-10" aria-hidden="true"></a></span>
<span id="cb536-11"><a href="#cb536-11" aria-hidden="true"></a><span class="kw">class</span> Derived : Base</span>
<span id="cb536-12"><a href="#cb536-12" aria-hidden="true"></a>{</span>
<span id="cb536-13"><a href="#cb536-13" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb536-14"><a href="#cb536-14" aria-hidden="true"></a>  <span class="dt">int</span> foo1()  { <span class="cf">return</span> MyPrivateInt;} <span class="co">// Won&#39;t compile!</span></span>
<span id="cb536-15"><a href="#cb536-15" aria-hidden="true"></a>  <span class="dt">int</span> foo2()  { <span class="cf">return</span> MyProtectedInt;} <span class="co">// OK  </span></span>
<span id="cb536-16"><a href="#cb536-16" aria-hidden="true"></a>  <span class="dt">int</span> foo3()  { <span class="cf">return</span> MyPublicInt;} <span class="co">// OK</span></span>
<span id="cb536-17"><a href="#cb536-17" aria-hidden="true"></a>};‌‌</span>
<span id="cb536-18"><a href="#cb536-18" aria-hidden="true"></a></span>
<span id="cb536-19"><a href="#cb536-19" aria-hidden="true"></a><span class="kw">class</span> Unrelated </span>
<span id="cb536-20"><a href="#cb536-20" aria-hidden="true"></a>{</span>
<span id="cb536-21"><a href="#cb536-21" aria-hidden="true"></a><span class="kw">private</span>:</span>
<span id="cb536-22"><a href="#cb536-22" aria-hidden="true"></a>  Base B;</span>
<span id="cb536-23"><a href="#cb536-23" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb536-24"><a href="#cb536-24" aria-hidden="true"></a>  <span class="dt">int</span> foo1()  { <span class="cf">return</span> B.MyPrivateInt;} <span class="co">// Won&#39;t compile!</span></span>
<span id="cb536-25"><a href="#cb536-25" aria-hidden="true"></a>  <span class="dt">int</span> foo2()  { <span class="cf">return</span> B.MyProtectedInt;} <span class="co">// Won&#39;t compile</span></span>
<span id="cb536-26"><a href="#cb536-26" aria-hidden="true"></a>  <span class="dt">int</span> foo3()  { <span class="cf">return</span> B.MyPublicInt;} <span class="co">// OK</span></span>
<span id="cb536-27"><a href="#cb536-27" aria-hidden="true"></a>};</span></code></pre></div>
<p>In terms of “best practice”, it depends. If there’s even a faint possibility that someone might want to derive a new class from your existing one and need access to internal members, make them Protected, not Private. If they’re private, your class may become difficult to inherit from easily.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-to-stop-c-console-application-from-exiting-immediately-score-442739-in-2014" class="level3">
<h3>88: How to stop C++ console application from exiting immediately? (score <a href="https://stackoverflow.com/q/2529617.html">442739</a> in 2014)</h3>
<section id="question-85" class="level4">
<h4>Question</h4>
<p>Lately, I’ve been trying to learn C++ from <a href="http://www.cplusplus.com/doc/tutorial/" rel="noreferrer">this website</a>. Unfortunately whenever I try to run one of the code samples, I see that program open for about a half second and then immediately close. Is there a way to stop the program from closing immediately so that I can see the fruits of my effort?</p>
</section>
<section id="answer-accepted-score-118" class="level4">
<h4>Answer accepted (score 118)</h4>
<p><strong>Edit:</strong> As Charles Bailey rightly points out in a comment below, this won’t work if there are characters buffered in <code>stdin</code>, and there’s really no good way to work around that. If you’re running with a debugger attached, <a href="https://stackoverflow.com/questions/2529617/how-to-stop-c-console-application-from-exiting-immediately/2529936
#2529936">John Dibling’s suggested solution</a> is probably the cleanest solution to your problem.</p>
<p>That said, I’ll leave this here and maybe someone else will find it useful. I’ve used it a lot as a quick hack of sorts when writing tests during development.</p>
<hr>
<p>At the end of your <code>main</code> function, you can call <a href="http://en.cppreference.com/w/cpp/io/c/getchar" rel="noreferrer"><code>std::getchar();</code></a></p>
<p>This will get a single character from <code>stdin</code>, thus giving you the “press any key to continue” sort of behavior (if you actually want a “press any key” message, you’ll have to print one yourself).</p>
<p>You need to <code>#include &amp;lt;cstdio&amp;gt;</code> for <code>getchar</code>.</p>
</section>
<section id="answer-2-score-135" class="level4">
<h4>Answer 2 (score 135)</h4>
<p>If you are using Visual Studio and you are starting the console application out of the IDE:</p>
<p>pressing <strong>CTRL-F5</strong> (start without debugging) will start the application and keep the console window open until you press any key.</p>
</section>
<section id="answer-3-score-101" class="level4">
<h4>Answer 3 (score 101)</h4>
<p>The solution by James works for all Platforms.</p>
<p>Alternatively on <code>Windows</code> you can also add the following just before you return from <code>main</code> function:</p>
<div class="sourceCode" id="cb537"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb537-1"><a href="#cb537-1" aria-hidden="true"></a>  system(<span class="st">&quot;pause&quot;</span>);</span></code></pre></div>
<p>This will run the <code>pause</code> command which waits till you press a key and also displays a nice message <code>Press any key to continue . . .</code></p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="case-insensitive-string-comparison-in-c-score-440956-in-2017" class="level3">
<h3>89: Case-insensitive string comparison in C++ (score <a href="https://stackoverflow.com/q/11635.html">440956</a> in 2017)</h3>
<section id="question-86" class="level4">
<h4>Question</h4>
<p>What is the best way of doing case-insensitive string comparison in C++ without transforming a string to all uppercase or all lowercase?</p>
<p>Please indicate whether the methods are Unicode-friendly and how portable they are.</p>
</section>
<section id="answer-accepted-score-309" class="level4">
<h4>Answer accepted (score 309)</h4>
<p>Boost includes a handy algorithm for this:</p>
<div class="sourceCode" id="cb538"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb538-1"><a href="#cb538-1" aria-hidden="true"></a></span>
<span id="cb538-2"><a href="#cb538-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;boost/algorithm/string.hpp&gt;</span></span>
<span id="cb538-3"><a href="#cb538-3" aria-hidden="true"></a><span class="co">// Or, for fewer header dependencies:</span></span>
<span id="cb538-4"><a href="#cb538-4" aria-hidden="true"></a><span class="co">//</span></span>
<span id="cb538-5"><a href="#cb538-5" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;boost/algorithm/string/predicate.hpp&gt;</span></span>
<span id="cb538-6"><a href="#cb538-6" aria-hidden="true"></a></span>
<span id="cb538-7"><a href="#cb538-7" aria-hidden="true"></a><span class="bu">std::</span>string str1 = <span class="st">&quot;hello, world!&quot;</span>;</span>
<span id="cb538-8"><a href="#cb538-8" aria-hidden="true"></a><span class="bu">std::</span>string str2 = <span class="st">&quot;HELLO, WORLD!&quot;</span>;</span>
<span id="cb538-9"><a href="#cb538-9" aria-hidden="true"></a></span>
<span id="cb538-10"><a href="#cb538-10" aria-hidden="true"></a><span class="cf">if</span> (<span class="ex">boost::</span>iequals(str1, str2))</span>
<span id="cb538-11"><a href="#cb538-11" aria-hidden="true"></a>{</span>
<span id="cb538-12"><a href="#cb538-12" aria-hidden="true"></a>    <span class="co">// Strings are identical</span></span>
<span id="cb538-13"><a href="#cb538-13" aria-hidden="true"></a>}</span></code></pre></div>
</section>
<section id="answer-2-score-116" class="level4">
<h4>Answer 2 (score 116)</h4>
<p>Take advantage of the standard <code>char_traits</code>. Recall that a <code>std::string</code> is in fact a typedef for <code>std::basic_string&amp;lt;char&amp;gt;</code>, or more explicitly, <code>std::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;</code>. The <code>char_traits</code> type describes how characters compare, how they copy, how they cast etc. All you need to do is typedef a new string over <code>basic_string</code>, and provide it with your own custom <code>char_traits</code> that compare case insensitively.</p>
<div class="sourceCode" id="cb539"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb539-1"><a href="#cb539-1" aria-hidden="true"></a><span class="kw">struct</span> ci_char_traits : <span class="kw">public</span> char_traits&lt;<span class="dt">char</span>&gt; {</span>
<span id="cb539-2"><a href="#cb539-2" aria-hidden="true"></a>    <span class="at">static</span> <span class="dt">bool</span> eq(<span class="dt">char</span> c1, <span class="dt">char</span> c2) { <span class="cf">return</span> toupper(c1) == toupper(c2); }</span>
<span id="cb539-3"><a href="#cb539-3" aria-hidden="true"></a>    <span class="at">static</span> <span class="dt">bool</span> ne(<span class="dt">char</span> c1, <span class="dt">char</span> c2) { <span class="cf">return</span> toupper(c1) != toupper(c2); }</span>
<span id="cb539-4"><a href="#cb539-4" aria-hidden="true"></a>    <span class="at">static</span> <span class="dt">bool</span> lt(<span class="dt">char</span> c1, <span class="dt">char</span> c2) { <span class="cf">return</span> toupper(c1) &lt;  toupper(c2); }</span>
<span id="cb539-5"><a href="#cb539-5" aria-hidden="true"></a>    <span class="at">static</span> <span class="dt">int</span> compare(<span class="at">const</span> <span class="dt">char</span>* s1, <span class="at">const</span> <span class="dt">char</span>* s2, <span class="dt">size_t</span> n) {</span>
<span id="cb539-6"><a href="#cb539-6" aria-hidden="true"></a>        <span class="cf">while</span>( n-- != <span class="dv">0</span> ) {</span>
<span id="cb539-7"><a href="#cb539-7" aria-hidden="true"></a>            <span class="cf">if</span>( toupper(*s1) &lt; toupper(*s2) ) <span class="cf">return</span> -<span class="dv">1</span>;</span>
<span id="cb539-8"><a href="#cb539-8" aria-hidden="true"></a>            <span class="cf">if</span>( toupper(*s1) &gt; toupper(*s2) ) <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb539-9"><a href="#cb539-9" aria-hidden="true"></a>            ++s1; ++s2;</span>
<span id="cb539-10"><a href="#cb539-10" aria-hidden="true"></a>        }</span>
<span id="cb539-11"><a href="#cb539-11" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb539-12"><a href="#cb539-12" aria-hidden="true"></a>    }</span>
<span id="cb539-13"><a href="#cb539-13" aria-hidden="true"></a>    <span class="at">static</span> <span class="at">const</span> <span class="dt">char</span>* find(<span class="at">const</span> <span class="dt">char</span>* s, <span class="dt">int</span> n, <span class="dt">char</span> a) {</span>
<span id="cb539-14"><a href="#cb539-14" aria-hidden="true"></a>        <span class="cf">while</span>( n-- &gt; <span class="dv">0</span> &amp;&amp; toupper(*s) != toupper(a) ) {</span>
<span id="cb539-15"><a href="#cb539-15" aria-hidden="true"></a>            ++s;</span>
<span id="cb539-16"><a href="#cb539-16" aria-hidden="true"></a>        }</span>
<span id="cb539-17"><a href="#cb539-17" aria-hidden="true"></a>        <span class="cf">return</span> s;</span>
<span id="cb539-18"><a href="#cb539-18" aria-hidden="true"></a>    }</span>
<span id="cb539-19"><a href="#cb539-19" aria-hidden="true"></a>};</span>
<span id="cb539-20"><a href="#cb539-20" aria-hidden="true"></a></span>
<span id="cb539-21"><a href="#cb539-21" aria-hidden="true"></a><span class="kw">typedef</span> <span class="bu">std::</span>basic_string&lt;<span class="dt">char</span>, ci_char_traits&gt; ci_string;</span></code></pre></div>
<p>The details are on <a href="http://www.gotw.ca/gotw/029.htm" rel="noreferrer">Guru of The Week number 29</a>.</p>
</section>
<section id="answer-3-score-71" class="level4">
<h4>Answer 3 (score 71)</h4>
<p>The trouble with boost is that you have to link with and depend on boost. Not easy in some cases (e.g. android).</p>
<p>And using char_traits means <em>all</em> your comparisons are case insensitive, which isn’t usually what you want.</p>
<p>This should suffice. It should be reasonably efficient. Doesn’t handle unicode or anything though.</p>
<div class="sourceCode" id="cb540"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb540-1"><a href="#cb540-1" aria-hidden="true"></a><span class="dt">bool</span> iequals(<span class="at">const</span> string&amp; a, <span class="at">const</span> string&amp; b)</span>
<span id="cb540-2"><a href="#cb540-2" aria-hidden="true"></a>{</span>
<span id="cb540-3"><a href="#cb540-3" aria-hidden="true"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> sz = a.size();</span>
<span id="cb540-4"><a href="#cb540-4" aria-hidden="true"></a>    <span class="cf">if</span> (b.size() != sz)</span>
<span id="cb540-5"><a href="#cb540-5" aria-hidden="true"></a>        <span class="cf">return</span> <span class="kw">false</span>;</span>
<span id="cb540-6"><a href="#cb540-6" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">unsigned</span> <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; sz; ++i)</span>
<span id="cb540-7"><a href="#cb540-7" aria-hidden="true"></a>        <span class="cf">if</span> (tolower(a[i]) != tolower(b[i]))</span>
<span id="cb540-8"><a href="#cb540-8" aria-hidden="true"></a>            <span class="cf">return</span> <span class="kw">false</span>;</span>
<span id="cb540-9"><a href="#cb540-9" aria-hidden="true"></a>    <span class="cf">return</span> <span class="kw">true</span>;</span>
<span id="cb540-10"><a href="#cb540-10" aria-hidden="true"></a>}</span></code></pre></div>
<p>Update: Bonus C++14 version (<code>#include &amp;lt;algorithm&amp;gt;</code>):</p>
<div class="sourceCode" id="cb541"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb541-1"><a href="#cb541-1" aria-hidden="true"></a><span class="dt">bool</span> iequals(<span class="at">const</span> string&amp; a, <span class="at">const</span> string&amp; b)</span>
<span id="cb541-2"><a href="#cb541-2" aria-hidden="true"></a>{</span>
<span id="cb541-3"><a href="#cb541-3" aria-hidden="true"></a>    <span class="cf">return</span> <span class="bu">std::</span>equal(a.begin(), a.end(),</span>
<span id="cb541-4"><a href="#cb541-4" aria-hidden="true"></a>                      b.begin(), b.end(),</span>
<span id="cb541-5"><a href="#cb541-5" aria-hidden="true"></a>                      [](<span class="dt">char</span> a, <span class="dt">char</span> b) {</span>
<span id="cb541-6"><a href="#cb541-6" aria-hidden="true"></a>                          <span class="cf">return</span> tolower(a) == tolower(b);</span>
<span id="cb541-7"><a href="#cb541-7" aria-hidden="true"></a>                      });</span>
<span id="cb541-8"><a href="#cb541-8" aria-hidden="true"></a>}</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="what-are-c-functors-and-their-uses-score-438237-in-2018" class="level3">
<h3>90: What are C++ functors and their uses? (score <a href="https://stackoverflow.com/q/356950.html">438237</a> in 2018)</h3>
<section id="question-87" class="level4">
<h4>Question</h4>
<p>I keep hearing a lot about functors in C++. Can someone give me an overview as to what they are and in what cases they would be useful?</p>
</section>
<section id="answer-accepted-score-978" class="level4">
<h4>Answer accepted (score 978)</h4>
<p>A functor is pretty much just a class which defines the operator(). That lets you create objects which “look like” a function:</p>
<div class="sourceCode" id="cb542"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb542-1"><a href="#cb542-1" aria-hidden="true"></a><span class="co">// this is a functor</span></span>
<span id="cb542-2"><a href="#cb542-2" aria-hidden="true"></a><span class="kw">struct</span> add_x {</span>
<span id="cb542-3"><a href="#cb542-3" aria-hidden="true"></a>  add_x(<span class="dt">int</span> x) : x(x) {}</span>
<span id="cb542-4"><a href="#cb542-4" aria-hidden="true"></a>  <span class="dt">int</span> <span class="kw">operator</span>()(<span class="dt">int</span> y) <span class="at">const</span> { <span class="cf">return</span> x + y; }</span>
<span id="cb542-5"><a href="#cb542-5" aria-hidden="true"></a></span>
<span id="cb542-6"><a href="#cb542-6" aria-hidden="true"></a><span class="kw">private</span>:</span>
<span id="cb542-7"><a href="#cb542-7" aria-hidden="true"></a>  <span class="dt">int</span> x;</span>
<span id="cb542-8"><a href="#cb542-8" aria-hidden="true"></a>};</span>
<span id="cb542-9"><a href="#cb542-9" aria-hidden="true"></a></span>
<span id="cb542-10"><a href="#cb542-10" aria-hidden="true"></a><span class="co">// Now you can use it like this:</span></span>
<span id="cb542-11"><a href="#cb542-11" aria-hidden="true"></a>add_x add42(<span class="dv">42</span>); <span class="co">// create an instance of the functor class</span></span>
<span id="cb542-12"><a href="#cb542-12" aria-hidden="true"></a><span class="dt">int</span> i = add42(<span class="dv">8</span>); <span class="co">// and &quot;call&quot; it</span></span>
<span id="cb542-13"><a href="#cb542-13" aria-hidden="true"></a><span class="ot">assert</span>(i == <span class="dv">50</span>); <span class="co">// and it added 42 to its argument</span></span>
<span id="cb542-14"><a href="#cb542-14" aria-hidden="true"></a></span>
<span id="cb542-15"><a href="#cb542-15" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; in; <span class="co">// assume this contains a bunch of values)</span></span>
<span id="cb542-16"><a href="#cb542-16" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; out(in.size());</span>
<span id="cb542-17"><a href="#cb542-17" aria-hidden="true"></a><span class="co">// Pass a functor to std::transform, which calls the functor on every element </span></span>
<span id="cb542-18"><a href="#cb542-18" aria-hidden="true"></a><span class="co">// in the input sequence, and stores the result to the output sequence</span></span>
<span id="cb542-19"><a href="#cb542-19" aria-hidden="true"></a><span class="bu">std::</span>transform(in.begin(), in.end(), out.begin(), add_x(<span class="dv">1</span>)); </span>
<span id="cb542-20"><a href="#cb542-20" aria-hidden="true"></a><span class="ot">assert</span>(out[i] == in[i] + <span class="dv">1</span>); <span class="co">// for all i</span></span></code></pre></div>
<p>There are a couple of nice things about functors. One is that unlike regular functions, they can contain state. The above example creates a function which adds 42 to whatever you give it. But that value 42 is not hardcoded, it was specified as a constructor argument when we created our functor instance. I could create another adder, which added 27, just by calling the constructor with a different value. This makes them nicely customizable.</p>
<p>As the last lines show, you often pass functors as arguments to other functions such as std::transform or the other standard library algorithms. You could do the same with a regular function pointer except, as I said above, functors can be “customized” because they contain state, making them more flexible (If I wanted to use a function pointer, I’d have to write a function which added exactly 1 to its argument. The functor is general, and adds whatever you initialized it with), and they are also potentially more efficient. In the above example, the compiler knows exactly which function <code>std::transform</code> should call. It should call <code>add_x::operator()</code>. That means it can inline that function call. And that makes it just as efficient as if I had manually called the function on each value of the vector.</p>
<p>If I had passed a function pointer instead, the compiler couldn’t immediately see which function it points to, so unless it performs some fairly complex global optimizations, it’d have to dereference the pointer at runtime, and then make the call.</p>
</section>
<section id="answer-2-score-118-1" class="level4">
<h4>Answer 2 (score 118)</h4>
<p>Little addition. You can use <a href="http://www.boost.org/doc/libs/1_51_0/doc/html/boost/function.html" rel="noreferrer"><code>boost::function</code></a>, to create functors from functions and methods, like this:</p>
<div class="sourceCode" id="cb543"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb543-1"><a href="#cb543-1" aria-hidden="true"></a><span class="kw">class</span> Foo</span>
<span id="cb543-2"><a href="#cb543-2" aria-hidden="true"></a>{</span>
<span id="cb543-3"><a href="#cb543-3" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb543-4"><a href="#cb543-4" aria-hidden="true"></a>    <span class="dt">void</span> <span class="kw">operator</span> () (<span class="dt">int</span> i) { printf(<span class="st">&quot;Foo </span><span class="sc">%d</span><span class="st">&quot;</span>, i); }</span>
<span id="cb543-5"><a href="#cb543-5" aria-hidden="true"></a>};</span>
<span id="cb543-6"><a href="#cb543-6" aria-hidden="true"></a><span class="dt">void</span> Bar(<span class="dt">int</span> i) { printf(<span class="st">&quot;Bar </span><span class="sc">%d</span><span class="st">&quot;</span>, i); }</span>
<span id="cb543-7"><a href="#cb543-7" aria-hidden="true"></a>Foo foo;</span>
<span id="cb543-8"><a href="#cb543-8" aria-hidden="true"></a><span class="ex">boost::</span>function&lt;<span class="dt">void</span> (<span class="dt">int</span>)&gt; f(foo);<span class="co">//wrap functor</span></span>
<span id="cb543-9"><a href="#cb543-9" aria-hidden="true"></a>f(<span class="dv">1</span>);<span class="co">//prints &quot;Foo 1&quot;</span></span>
<span id="cb543-10"><a href="#cb543-10" aria-hidden="true"></a><span class="ex">boost::</span>function&lt;<span class="dt">void</span> (<span class="dt">int</span>)&gt; b(&amp;Bar);<span class="co">//wrap normal function</span></span>
<span id="cb543-11"><a href="#cb543-11" aria-hidden="true"></a>b(<span class="dv">1</span>);<span class="co">//prints &quot;Bar 1&quot;</span></span></code></pre></div>
<p>and you can use boost::bind to add state to this functor</p>
<div class="sourceCode" id="cb544"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb544-1"><a href="#cb544-1" aria-hidden="true"></a><span class="ex">boost::</span>function&lt;<span class="dt">void</span> ()&gt; f1 = <span class="ex">boost::</span>bind(foo, <span class="dv">2</span>);</span>
<span id="cb544-2"><a href="#cb544-2" aria-hidden="true"></a>f1();<span class="co">//no more argument, function argument stored in f1</span></span>
<span id="cb544-3"><a href="#cb544-3" aria-hidden="true"></a><span class="co">//and this print &quot;Foo 2&quot; (:</span></span>
<span id="cb544-4"><a href="#cb544-4" aria-hidden="true"></a><span class="co">//and normal function</span></span>
<span id="cb544-5"><a href="#cb544-5" aria-hidden="true"></a><span class="ex">boost::</span>function&lt;<span class="dt">void</span> ()&gt; b1 = <span class="ex">boost::</span>bind(&amp;Bar, <span class="dv">2</span>);</span>
<span id="cb544-6"><a href="#cb544-6" aria-hidden="true"></a>b1();<span class="co">// print &quot;Bar 2&quot;</span></span></code></pre></div>
<p>and most useful, with boost::bind and boost::function you can create functor from class method, actually this is a delegate:</p>
<div class="sourceCode" id="cb545"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb545-1"><a href="#cb545-1" aria-hidden="true"></a><span class="kw">class</span> SomeClass</span>
<span id="cb545-2"><a href="#cb545-2" aria-hidden="true"></a>{</span>
<span id="cb545-3"><a href="#cb545-3" aria-hidden="true"></a>    <span class="bu">std::</span>string <span class="va">state_</span>;</span>
<span id="cb545-4"><a href="#cb545-4" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb545-5"><a href="#cb545-5" aria-hidden="true"></a>    SomeClass(<span class="at">const</span> <span class="dt">char</span>* s) : <span class="va">state_</span>(s) {}</span>
<span id="cb545-6"><a href="#cb545-6" aria-hidden="true"></a></span>
<span id="cb545-7"><a href="#cb545-7" aria-hidden="true"></a>    <span class="dt">void</span> method( <span class="bu">std::</span>string param )</span>
<span id="cb545-8"><a href="#cb545-8" aria-hidden="true"></a>    {</span>
<span id="cb545-9"><a href="#cb545-9" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; <span class="va">state_</span> &lt;&lt; param &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb545-10"><a href="#cb545-10" aria-hidden="true"></a>    }</span>
<span id="cb545-11"><a href="#cb545-11" aria-hidden="true"></a>};</span>
<span id="cb545-12"><a href="#cb545-12" aria-hidden="true"></a>SomeClass *inst = <span class="kw">new</span> SomeClass(<span class="st">&quot;Hi, i am &quot;</span>);</span>
<span id="cb545-13"><a href="#cb545-13" aria-hidden="true"></a><span class="ex">boost::</span>function&lt; <span class="dt">void</span> (<span class="bu">std::</span>string) &gt; callback;</span>
<span id="cb545-14"><a href="#cb545-14" aria-hidden="true"></a>callback = <span class="ex">boost::</span>bind(&amp;SomeClass::method, inst, _1);<span class="co">//create delegate</span></span>
<span id="cb545-15"><a href="#cb545-15" aria-hidden="true"></a><span class="co">//_1 is a placeholder it holds plase for parameter</span></span>
<span id="cb545-16"><a href="#cb545-16" aria-hidden="true"></a>callback(<span class="st">&quot;useless&quot;</span>);<span class="co">//prints &quot;Hi, i am useless&quot;</span></span></code></pre></div>
<p>You can create list or vector of functors</p>
<div class="sourceCode" id="cb546"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb546-1"><a href="#cb546-1" aria-hidden="true"></a><span class="bu">std::</span>list&lt; <span class="ex">boost::</span>function&lt;<span class="dt">void</span> (EventArg e)&gt; &gt; events;</span>
<span id="cb546-2"><a href="#cb546-2" aria-hidden="true"></a><span class="co">//add some events</span></span>
<span id="cb546-3"><a href="#cb546-3" aria-hidden="true"></a>....</span>
<span id="cb546-4"><a href="#cb546-4" aria-hidden="true"></a><span class="co">//call them</span></span>
<span id="cb546-5"><a href="#cb546-5" aria-hidden="true"></a><span class="bu">std::</span>for_each(</span>
<span id="cb546-6"><a href="#cb546-6" aria-hidden="true"></a>        events.begin(), events.end(), </span>
<span id="cb546-7"><a href="#cb546-7" aria-hidden="true"></a>        <span class="ex">boost::</span>bind( <span class="ex">boost::</span>apply&lt;<span class="dt">void</span>&gt;(), _1, e));</span></code></pre></div>
<p>There is one problem with all this stuff, compiler error messages is not human readable :)</p>
</section>
<section id="answer-3-score-93" class="level4">
<h4>Answer 3 (score 93)</h4>
<p>
A Functor is a object which acts like a function. Basically, a class which defines <code>operator()</code>.
</p>
<div class="sourceCode" id="cb547"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb547-1"><a href="#cb547-1" aria-hidden="true"></a><span class="kw">class</span> MyFunctor</span>
<span id="cb547-2"><a href="#cb547-2" aria-hidden="true"></a>{</span>
<span id="cb547-3"><a href="#cb547-3" aria-hidden="true"></a>   <span class="kw">public</span>:</span>
<span id="cb547-4"><a href="#cb547-4" aria-hidden="true"></a>     <span class="dt">int</span> <span class="kw">operator</span>()(<span class="dt">int</span> x) { <span class="cf">return</span> x * <span class="dv">2</span>;}</span>
<span id="cb547-5"><a href="#cb547-5" aria-hidden="true"></a>}</span>
<span id="cb547-6"><a href="#cb547-6" aria-hidden="true"></a></span>
<span id="cb547-7"><a href="#cb547-7" aria-hidden="true"></a>MyFunctor doubler;</span>
<span id="cb547-8"><a href="#cb547-8" aria-hidden="true"></a><span class="dt">int</span> x = doubler(<span class="dv">5</span>);</span></code></pre></div>
<p>The real advantage is that a functor can hold state.</p>
<div class="sourceCode" id="cb548"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb548-1"><a href="#cb548-1" aria-hidden="true"></a><span class="kw">class</span> Matcher</span>
<span id="cb548-2"><a href="#cb548-2" aria-hidden="true"></a>{</span>
<span id="cb548-3"><a href="#cb548-3" aria-hidden="true"></a>   <span class="dt">int</span> target;</span>
<span id="cb548-4"><a href="#cb548-4" aria-hidden="true"></a>   <span class="kw">public</span>:</span>
<span id="cb548-5"><a href="#cb548-5" aria-hidden="true"></a>     Matcher(<span class="dt">int</span> m) : target(m) {}</span>
<span id="cb548-6"><a href="#cb548-6" aria-hidden="true"></a>     <span class="dt">bool</span> <span class="kw">operator</span>()(<span class="dt">int</span> x) { <span class="cf">return</span> x == target;}</span>
<span id="cb548-7"><a href="#cb548-7" aria-hidden="true"></a>}</span>
<span id="cb548-8"><a href="#cb548-8" aria-hidden="true"></a></span>
<span id="cb548-9"><a href="#cb548-9" aria-hidden="true"></a>Matcher Is5(<span class="dv">5</span>);</span>
<span id="cb548-10"><a href="#cb548-10" aria-hidden="true"></a></span>
<span id="cb548-11"><a href="#cb548-11" aria-hidden="true"></a><span class="cf">if</span> (Is5(n))    <span class="co">// same as if (n == 5)</span></span>
<span id="cb548-12"><a href="#cb548-12" aria-hidden="true"></a>{ ....}</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="what-is-meant-with-const-at-end-of-function-declaration-score-437523-in-2019" class="level3">
<h3>91: What is meant with “const” at end of function declaration? (score <a href="https://stackoverflow.com/q/3141087.html">437523</a> in 2019)</h3>
<section id="question-88" class="level4">
<h4>Question</h4>
<blockquote>
<p>
<strong>Possible Duplicate:</strong><br> <a href="https://stackoverflow.com/questions/751681/meaning-of-const-last-in-a-c-method-declaration">Meaning of “const” last in a C++ method declaration?</a>
</p>
</blockquote>
<p>I got a book, where there is written something like:</p>
<div class="sourceCode" id="cb549"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb549-1"><a href="#cb549-1" aria-hidden="true"></a><span class="kw">class</span> Foo </span>
<span id="cb549-2"><a href="#cb549-2" aria-hidden="true"></a>{</span>
<span id="cb549-3"><a href="#cb549-3" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb549-4"><a href="#cb549-4" aria-hidden="true"></a>    <span class="dt">int</span> Bar(<span class="dt">int</span> random_arg) <span class="at">const</span></span>
<span id="cb549-5"><a href="#cb549-5" aria-hidden="true"></a>    {</span>
<span id="cb549-6"><a href="#cb549-6" aria-hidden="true"></a>        <span class="co">// code</span></span>
<span id="cb549-7"><a href="#cb549-7" aria-hidden="true"></a>    }</span>
<span id="cb549-8"><a href="#cb549-8" aria-hidden="true"></a>};</span></code></pre></div>
<p>What does it mean?</p>
</section>
<section id="answer-accepted-score-821" class="level4">
<h4>Answer accepted (score 821)</h4>
<p>A “const function”, denoted with the keyword <code>const</code> after a function declaration, makes it a compiler error for this class function to change a member variable of the class. However, reading of a class variables is okay inside of the function, but writing inside of this function will generate a compiler error.</p>
<p>Another way of thinking about such “const function” is by viewing a class function as a normal function taking an implicit <code>this</code> pointer. So a method <code>int Foo::Bar(int random_arg)</code> (without the const at the end) results in a function like <code>int Foo_Bar(Foo* this, int random_arg)</code>, and a call such as <code>Foo f; f.Bar(4)</code> will internally correspond to something like <code>Foo f; Foo_Bar(&amp;amp;f, 4)</code>. Now adding the const at the end (<code>int Foo::Bar(int random_arg) const</code>) can then be understood as a declaration with a const this pointer: <code>int Foo_Bar(const Foo* this, int random_arg)</code>. Since the type of <code>this</code> in such case is const, no modifications of member variables are possible.</p>
<p>It is possible to loosen the “const function” restriction of not allowing the function to write to any variable of a class. To allow some of the variables to be writable even when the function is marked as a “const function”, these class variables are marked with the keyword <code>mutable</code>. Thus, if a class variable is marked as mutable, and a “const function” writes to this variable then the code will compile cleanly and the variable is possible to change. (C++11)</p>
<p>As usual when dealing with the <code>const</code> keyword, changing the location of the const key word in a C++ statement has entirely different meanings. The above usage of <code>const</code> only applies when adding <code>const</code> to the end of the function declaration after the parenthesis.</p>
<p><code>const</code> is a highly overused qualifier in C++: the syntax and ordering is often not straightforward in combination with pointers. Some readings about <code>const</code> correctness and the <code>const</code> keyword:</p>
<p><a href="http://en.wikipedia.org/wiki/Const-correctness" rel="noreferrer">Const correctness</a></p>
<p><a href="http://duramecho.com/ComputerInformation/WhyHowCppConst.html" rel="noreferrer">The C++ ‘const’ Declaration: Why &amp; How</a></p>
</section>
<section id="answer-2-score-42" class="level4">
<h4>Answer 2 (score 42)</h4>
<p>Consider two class-typed variables:</p>
<div class="sourceCode" id="cb550"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb550-1"><a href="#cb550-1" aria-hidden="true"></a><span class="kw">class</span> Boo { ... };</span>
<span id="cb550-2"><a href="#cb550-2" aria-hidden="true"></a></span>
<span id="cb550-3"><a href="#cb550-3" aria-hidden="true"></a>Boo b0;       <span class="co">// mutable object</span></span>
<span id="cb550-4"><a href="#cb550-4" aria-hidden="true"></a><span class="at">const</span> Boo b1; <span class="co">// non-mutable object</span></span></code></pre></div>
<p>Now you are able to call <em>any</em> member function of <code>Boo</code> on <code>b0</code>, but only <code>const</code>-qualified member functions on <code>b1</code>.</p>
</section>
<section id="answer-3-score-12" class="level4">
<h4>Answer 3 (score 12)</h4>
<p><code>Bar</code> is guaranteed not to change the object it is being invoked on. See the <a href="http://www.parashift.com/c++-faq-lite/const-correctness.html" rel="noreferrer">section about const correctness</a> in the C++ FAQ, for example.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-to-convert-int-to-qstring-score-432339-in-2015" class="level3">
<h3>92: How to convert int to QString? (score <a href="https://stackoverflow.com/q/3211771.html">432339</a> in 2015)</h3>
<section id="question-89" class="level4">
<h4>Question</h4>
<p>Is there a <code>QString</code> function which takes an <strong>int</strong> and outputs it as a <code>QString</code>?</p>
</section>
<section id="answer-accepted-score-616" class="level4">
<h4>Answer accepted (score 616)</h4>
<p>Use <a href="http://doc.qt.io/qt-5/qstring.html
#number" rel="noreferrer"><code>QString::number()</code></a>:</p>
<div class="sourceCode" id="cb551"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb551-1"><a href="#cb551-1" aria-hidden="true"></a><span class="dt">int</span> i = <span class="dv">42</span>;</span>
<span id="cb551-2"><a href="#cb551-2" aria-hidden="true"></a><span class="ex">QString</span> s = <span class="ex">QString::</span>number(i);</span></code></pre></div>
</section>
<section id="answer-2-score-116-1" class="level4">
<h4>Answer 2 (score 116)</h4>
<p>
And if you want to put it into string within some text context, forget about <code>+</code> operator. Simply do:
</p>
<div class="sourceCode" id="cb552"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb552-1"><a href="#cb552-1" aria-hidden="true"></a><span class="co">// Qt 5 + C++11</span></span>
<span id="cb552-2"><a href="#cb552-2" aria-hidden="true"></a><span class="kw">auto</span> i = <span class="dv">13</span>;    </span>
<span id="cb552-3"><a href="#cb552-3" aria-hidden="true"></a><span class="kw">auto</span> printable = <span class="ex">QStringLiteral</span>(<span class="st">&quot;My magic number is %1. That&#39;s all!&quot;</span>).arg(i);</span>
<span id="cb552-4"><a href="#cb552-4" aria-hidden="true"></a></span>
<span id="cb552-5"><a href="#cb552-5" aria-hidden="true"></a><span class="co">// Qt 5</span></span>
<span id="cb552-6"><a href="#cb552-6" aria-hidden="true"></a><span class="dt">int</span> i = <span class="dv">13</span>;    </span>
<span id="cb552-7"><a href="#cb552-7" aria-hidden="true"></a><span class="ex">QString</span> printable = <span class="ex">QStringLiteral</span>(<span class="st">&quot;My magic number is %1. That&#39;s all!&quot;</span>).arg(i);</span>
<span id="cb552-8"><a href="#cb552-8" aria-hidden="true"></a></span>
<span id="cb552-9"><a href="#cb552-9" aria-hidden="true"></a><span class="co">// Qt 4</span></span>
<span id="cb552-10"><a href="#cb552-10" aria-hidden="true"></a><span class="dt">int</span> i = <span class="dv">13</span>;    </span>
<span id="cb552-11"><a href="#cb552-11" aria-hidden="true"></a><span class="ex">QString</span> printable = <span class="ex">QString::</span>fromLatin1(<span class="st">&quot;My magic number is %1. That&#39;s all!&quot;</span>).arg(i);</span></code></pre></div>
</section>
<section id="answer-3-score-24-1" class="level4">
<h4>Answer 3 (score 24)</h4>
<p>
Moreover to convert whatever you want, you can use <code>QVariant</code>. For an <code>int</code> to a <code>QString</code> you get:
</p>
<div class="sourceCode" id="cb553"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb553-1"><a href="#cb553-1" aria-hidden="true"></a><span class="ex">QVariant</span>(<span class="dv">3</span>).toString();</span></code></pre></div>
<p>A <code>float</code> to a <code>string</code> or a <code>string</code> to a <code>float</code>:</p>
<div class="sourceCode" id="cb554"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb554-1"><a href="#cb554-1" aria-hidden="true"></a><span class="ex">QVariant</span>(<span class="fl">3.2</span>).toString();</span>
<span id="cb554-2"><a href="#cb554-2" aria-hidden="true"></a><span class="ex">QVariant</span>(<span class="st">&quot;5.2&quot;</span>).toFloat();</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-do-i-add-a-linker-or-compile-flag-in-a-cmake-file-score-430588-in-2019" class="level3">
<h3>93: How do I add a linker or compile flag in a CMake file? (score <a href="https://stackoverflow.com/q/11783932.html">430588</a> in 2019)</h3>
<section id="question-90" class="level4">
<h4>Question</h4>
<p>I am using the <code>arm-linux-androideabi-g++</code> compiler. When I try to compile a simple “Hello, World!” program it compiles fine. When I test it by adding a simple exception handling in that code it works too (after adding <code>-fexceptions</code> .. I guess it is disabled by default).</p>
<p>This is for an Android device, and I only want to use CMake, not <code>ndk-build</code>.</p>
<p>For example - <code>first.cpp</code></p>
<div class="sourceCode" id="cb555"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb555-1"><a href="#cb555-1" aria-hidden="true"></a></span>
<span id="cb555-2"><a href="#cb555-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb555-3"><a href="#cb555-3" aria-hidden="true"></a></span>
<span id="cb555-4"><a href="#cb555-4" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb555-5"><a href="#cb555-5" aria-hidden="true"></a></span>
<span id="cb555-6"><a href="#cb555-6" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb555-7"><a href="#cb555-7" aria-hidden="true"></a>{</span>
<span id="cb555-8"><a href="#cb555-8" aria-hidden="true"></a>   <span class="cf">try</span></span>
<span id="cb555-9"><a href="#cb555-9" aria-hidden="true"></a>   {</span>
<span id="cb555-10"><a href="#cb555-10" aria-hidden="true"></a>   }</span>
<span id="cb555-11"><a href="#cb555-11" aria-hidden="true"></a>   <span class="cf">catch</span> (...)</span>
<span id="cb555-12"><a href="#cb555-12" aria-hidden="true"></a>   {</span>
<span id="cb555-13"><a href="#cb555-13" aria-hidden="true"></a>   }</span>
<span id="cb555-14"><a href="#cb555-14" aria-hidden="true"></a>   <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb555-15"><a href="#cb555-15" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>./arm-linux-androideadi-g++ -o first-test first.cpp -fexceptions</code></p>
<p>It works with no problem…</p>
<p><strong>The problem</strong> … I am trying to compile the file with a CMake file.</p>
<p>I want to add the <code>-fexceptions</code> as a flag. I tried with</p>
<div class="sourceCode" id="cb556"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb556-1"><a href="#cb556-1" aria-hidden="true"></a>set (CMAKE_EXE_LINKER_FLAGS -fexceptions ) <span class="kw">or</span> set (CMAKE_EXE_LINKER_FLAGS <span class="st">&quot;fexceptions&quot;</span> )</span></code></pre></div>
<p>and</p>
<div class="sourceCode" id="cb557"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb557-1"><a href="#cb557-1" aria-hidden="true"></a>set ( CMAKE_C_FLAGS <span class="st">&quot;fexceptions&quot;</span>)</span></code></pre></div>
<p>It still displays an error.</p>
</section>
<section id="answer-accepted-score-222" class="level4">
<h4>Answer accepted (score 222)</h4>
<p>Suppose you want to add those flags (better to declare them in a constant):</p>
<div class="sourceCode" id="cb558"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb558-1"><a href="#cb558-1" aria-hidden="true"></a>SET(GCC_COVERAGE_COMPILE_FLAGS <span class="st">&quot;-fprofile-arcs -ftest-coverage&quot;</span>)</span>
<span id="cb558-2"><a href="#cb558-2" aria-hidden="true"></a>SET(GCC_COVERAGE_LINK_FLAGS    <span class="st">&quot;-lgcov&quot;</span>)</span></code></pre></div>
<p>There are several ways to add them:</p>
<ol>
<li>
<p>
The easiest one (not clean, but easy and convenient, and works only for compile flags, C &amp; C++ at once):
</p>
<div class="sourceCode" id="cb559"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb559-1"><a href="#cb559-1" aria-hidden="true"></a>add_definitions(<span class="er">$</span>{GCC_COVERAGE_COMPILE_FLAGS})</span>
<span id="cb559-2"><a href="#cb559-2" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb559-3"><a href="#cb559-3" aria-hidden="true"></a>&lt;li&gt;&lt;p&gt;Appending to corresponding CMake variables:&lt;/p&gt;</span>
<span id="cb559-4"><a href="#cb559-4" aria-hidden="true"></a></span>
<span id="cb559-5"><a href="#cb559-5" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb559-6"><a href="#cb559-6" aria-hidden="true"></a>SET(CMAKE_CXX_FLAGS  <span class="st">&quot;${CMAKE_CXX_FLAGS} ${GCC_COVERAGE_COMPILE_FLAGS}&quot;</span>)</span>
<span id="cb559-7"><a href="#cb559-7" aria-hidden="true"></a>SET(CMAKE_EXE_LINKER_FLAGS  <span class="st">&quot;${CMAKE_EXE_LINKER_FLAGS} ${GCC_COVERAGE_LINK_FLAGS}&quot;</span>)</span>
<span id="cb559-8"><a href="#cb559-8" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb559-9"><a href="#cb559-9" aria-hidden="true"></a>&lt;li&gt;&lt;p&gt;Using target properties, cf. doc &lt;a href=<span class="st">&quot;http://www.cmake.org/cmake/help/v2.8.8/cmake.html</span></span>
<span id="cb559-10"><a href="#cb559-10" aria-hidden="true"></a><span class="pp">#</span><span class="er">prop_tgt:COMPILE_FLAGS&quot; rel=&quot;noreferrer&quot;&gt;CMake compile flag target property&lt;/a&gt; and need to know the target name.&lt;/p&gt;</span></span>
<span id="cb559-11"><a href="#cb559-11" aria-hidden="true"></a></span>
<span id="cb559-12"><a href="#cb559-12" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb559-13"><a href="#cb559-13" aria-hidden="true"></a>get_target_property(TEMP <span class="er">$</span>{THE_TARGET} COMPILE_FLAGS)</span>
<span id="cb559-14"><a href="#cb559-14" aria-hidden="true"></a><span class="cf">if</span>(TEMP STREQUAL <span class="st">&quot;TEMP-NOTFOUND&quot;</span>)</span>
<span id="cb559-15"><a href="#cb559-15" aria-hidden="true"></a>  SET(TEMP <span class="st">&quot;&quot;</span>)</span>
<span id="cb559-16"><a href="#cb559-16" aria-hidden="true"></a><span class="pp"># </span><span class="er">Set to empty string</span></span>
<span id="cb559-17"><a href="#cb559-17" aria-hidden="true"></a><span class="cf">else</span>()</span>
<span id="cb559-18"><a href="#cb559-18" aria-hidden="true"></a>  SET(TEMP <span class="st">&quot;${TEMP} &quot;</span>)</span>
<span id="cb559-19"><a href="#cb559-19" aria-hidden="true"></a><span class="pp"># </span><span class="er">A space to cleanly separate from existing content</span></span>
<span id="cb559-20"><a href="#cb559-20" aria-hidden="true"></a>endif()</span>
<span id="cb559-21"><a href="#cb559-21" aria-hidden="true"></a></span>
<span id="cb559-22"><a href="#cb559-22" aria-hidden="true"></a><span class="pp"># </span><span class="er">Append our values</span></span>
<span id="cb559-23"><a href="#cb559-23" aria-hidden="true"></a>SET(TEMP <span class="st">&quot;${TEMP}${GCC_COVERAGE_COMPILE_FLAGS}&quot;</span> )</span>
<span id="cb559-24"><a href="#cb559-24" aria-hidden="true"></a>set_target_properties(<span class="er">$</span>{THE_TARGET} PROPERTIES COMPILE_FLAGS <span class="er">$</span>{TEMP} )</span>
<span id="cb559-25"><a href="#cb559-25" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb559-26"><a href="#cb559-26" aria-hidden="true"></a>&lt;/ol&gt;</span>
<span id="cb559-27"><a href="#cb559-27" aria-hidden="true"></a></span>
<span id="cb559-28"><a href="#cb559-28" aria-hidden="true"></a>Right now I use method <span class="fl">2.</span>  </span>
<span id="cb559-29"><a href="#cb559-29" aria-hidden="true"></a></span>
<span id="cb559-30"><a href="#cb559-30" aria-hidden="true"></a></span>
<span id="cb559-31"><a href="#cb559-31" aria-hidden="true"></a><span class="pp">#</span><span class="er">### Answer 2 (score 141)</span></span>
<span id="cb559-32"><a href="#cb559-32" aria-hidden="true"></a>In newer versions of CMake you can set compiler <span class="kw">and</span> linker flags <span class="cf">for</span> a single target with &lt;a href=<span class="st">&quot;http://www.cmake.org/cmake/help/v3.0/command/target_compile_options.html&quot;</span> rel=<span class="st">&quot;noreferrer&quot;</span>&gt;<span class="er">`</span>target_compile_options<span class="er">`</span>&lt;/a&gt; <span class="kw">and</span> &lt;a href=<span class="st">&quot;http://www.cmake.org/cmake/help/v3.0/command/target_link_libraries.html&quot;</span> rel=<span class="st">&quot;noreferrer&quot;</span>&gt;<span class="er">`</span>target_link_libraries<span class="er">`</span>&lt;/a&gt; respectively (yes, the latter sets linker options too):  </span>
<span id="cb559-33"><a href="#cb559-33" aria-hidden="true"></a></span>
<span id="cb559-34"><a href="#cb559-34" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb559-35"><a href="#cb559-35" aria-hidden="true"></a>target_compile_options(first-test PRIVATE -fexceptions)</span></code></pre></div>
<p>The advantage of this method is that you can control propagation of options to other targets that depend on this one via <code>PUBLIC</code> and <code>PRIVATE</code>.</p>
<p>As of CMake 3.13 you can also use <a href="https://cmake.org/cmake/help/git-stage/command/target_link_options.html" rel="noreferrer"><code>target_link_options</code></a> to add linker options which makes the intent more clear.</p>
</section>
<section id="answer-3-score-38-2" class="level4">
<h4>Answer 3 (score 38)</h4>
<p>Try setting the variable <code>CMAKE_CXX_FLAGS</code> instead of <code>CMAKE_C_FLAGS</code>:</p>
<div class="sourceCode" id="cb560"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb560-1"><a href="#cb560-1" aria-hidden="true"></a>set (CMAKE_CXX_FLAGS <span class="st">&quot;-fexceptions&quot;</span>)</span></code></pre></div>
<p>The variable <code>CMAKE_C_FLAGS</code> only affects the C compiler, but you are compiling C++ code.</p>
<p>Adding the flag to <code>CMAKE_EXE_LINKER_FLAGS</code> is redundant.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="can-i-call-a-constructor-from-another-constructor-do-constructor-chaining-in-c-score-428350-in-2017" class="level3">
<h3>94: Can I call a constructor from another constructor (do constructor chaining) in C++? (score <a href="https://stackoverflow.com/q/308276.html">428350</a> in 2017)</h3>
<section id="question-91" class="level4">
<h4>Question</h4>
<p>As a <a href="http://en.wikipedia.org/wiki/C_Sharp_%28programming_language%29" rel="noreferrer">C #</a> developer I’m used to run through constructors:</p>
<div class="sourceCode" id="cb561"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb561-1"><a href="#cb561-1" aria-hidden="true"></a><span class="kw">class</span> Test {</span>
<span id="cb561-2"><a href="#cb561-2" aria-hidden="true"></a>    <span class="kw">public</span> Test() {</span>
<span id="cb561-3"><a href="#cb561-3" aria-hidden="true"></a>        DoSomething();</span>
<span id="cb561-4"><a href="#cb561-4" aria-hidden="true"></a>    }</span>
<span id="cb561-5"><a href="#cb561-5" aria-hidden="true"></a></span>
<span id="cb561-6"><a href="#cb561-6" aria-hidden="true"></a>    <span class="kw">public</span> Test(<span class="dt">int</span> count) : <span class="kw">this</span>() {</span>
<span id="cb561-7"><a href="#cb561-7" aria-hidden="true"></a>        DoSomethingWithCount(count);</span>
<span id="cb561-8"><a href="#cb561-8" aria-hidden="true"></a>    }</span>
<span id="cb561-9"><a href="#cb561-9" aria-hidden="true"></a></span>
<span id="cb561-10"><a href="#cb561-10" aria-hidden="true"></a>    <span class="kw">public</span> Test(<span class="dt">int</span> count, string name) : <span class="kw">this</span>(count) {</span>
<span id="cb561-11"><a href="#cb561-11" aria-hidden="true"></a>        DoSomethingWithName(name);</span>
<span id="cb561-12"><a href="#cb561-12" aria-hidden="true"></a>    }</span>
<span id="cb561-13"><a href="#cb561-13" aria-hidden="true"></a>}</span></code></pre></div>
<p>Is there a way to do this in C++?</p>
<p>I tried calling the Class name and using the ‘this’ keyword, but both fails.</p>
</section>
<section id="answer-accepted-score-1161" class="level4">
<h4>Answer accepted (score 1161)</h4>
<p><strong>C++11: Yes!</strong></p>
<p>C++11 and onwards has this same feature (called <a href="https://secure.wikimedia.org/wikipedia/en/wiki/C++11
#Object_construction_improvement" rel="noreferrer">delegating constructors</a>).</p>
<p>The syntax is slightly different from C #:</p>
<div class="sourceCode" id="cb562"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb562-1"><a href="#cb562-1" aria-hidden="true"></a><span class="kw">class</span> Foo {</span>
<span id="cb562-2"><a href="#cb562-2" aria-hidden="true"></a><span class="kw">public</span>: </span>
<span id="cb562-3"><a href="#cb562-3" aria-hidden="true"></a>  Foo(<span class="dt">char</span> x, <span class="dt">int</span> y) {}</span>
<span id="cb562-4"><a href="#cb562-4" aria-hidden="true"></a>  Foo(<span class="dt">int</span> y) : Foo(<span class="ch">&#39;a&#39;</span>, y) {}</span>
<span id="cb562-5"><a href="#cb562-5" aria-hidden="true"></a>};</span></code></pre></div>
<p><strong>C++03: No</strong></p>
<p>Unfortunately, there’s no way to do this in C++03, but there are two ways of simulating this:</p>
<ol>
<li>
<p>
You can combine two (or more) constructors via default parameters:
</p>
<div class="sourceCode" id="cb563"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb563-1"><a href="#cb563-1" aria-hidden="true"></a><span class="kw">class</span> Foo {</span>
<span id="cb563-2"><a href="#cb563-2" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb563-3"><a href="#cb563-3" aria-hidden="true"></a>  Foo(<span class="dt">char</span> x, <span class="dt">int</span> y=<span class="dv">0</span>);  <span class="co">// combines two constructors (char) and (char, int)</span></span>
<span id="cb563-4"><a href="#cb563-4" aria-hidden="true"></a>  <span class="co">// ...</span></span>
<span id="cb563-5"><a href="#cb563-5" aria-hidden="true"></a>};</span>
<span id="cb563-6"><a href="#cb563-6" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb563-7"><a href="#cb563-7" aria-hidden="true"></a>&lt;li&gt;&lt;p&gt;Use an init method to share common code:&lt;/p&gt;</span>
<span id="cb563-8"><a href="#cb563-8" aria-hidden="true"></a></span>
<span id="cb563-9"><a href="#cb563-9" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb563-10"><a href="#cb563-10" aria-hidden="true"></a><span class="kw">class</span> Foo {</span>
<span id="cb563-11"><a href="#cb563-11" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb563-12"><a href="#cb563-12" aria-hidden="true"></a>  Foo(<span class="dt">char</span> x);</span>
<span id="cb563-13"><a href="#cb563-13" aria-hidden="true"></a>  Foo(<span class="dt">char</span> x, <span class="dt">int</span> y);</span>
<span id="cb563-14"><a href="#cb563-14" aria-hidden="true"></a>  <span class="co">// ...</span></span>
<span id="cb563-15"><a href="#cb563-15" aria-hidden="true"></a><span class="kw">private</span>:</span>
<span id="cb563-16"><a href="#cb563-16" aria-hidden="true"></a>  <span class="dt">void</span> init(<span class="dt">char</span> x, <span class="dt">int</span> y);</span>
<span id="cb563-17"><a href="#cb563-17" aria-hidden="true"></a>};</span>
<span id="cb563-18"><a href="#cb563-18" aria-hidden="true"></a></span>
<span id="cb563-19"><a href="#cb563-19" aria-hidden="true"></a>Foo::Foo(<span class="dt">char</span> x)</span>
<span id="cb563-20"><a href="#cb563-20" aria-hidden="true"></a>{</span>
<span id="cb563-21"><a href="#cb563-21" aria-hidden="true"></a>  init(x, <span class="dt">int</span>(x) + <span class="dv">7</span>);</span>
<span id="cb563-22"><a href="#cb563-22" aria-hidden="true"></a>  <span class="co">// ...</span></span>
<span id="cb563-23"><a href="#cb563-23" aria-hidden="true"></a>}</span>
<span id="cb563-24"><a href="#cb563-24" aria-hidden="true"></a></span>
<span id="cb563-25"><a href="#cb563-25" aria-hidden="true"></a>Foo::Foo(<span class="dt">char</span> x, <span class="dt">int</span> y)</span>
<span id="cb563-26"><a href="#cb563-26" aria-hidden="true"></a>{</span>
<span id="cb563-27"><a href="#cb563-27" aria-hidden="true"></a>  init(x, y);</span>
<span id="cb563-28"><a href="#cb563-28" aria-hidden="true"></a>  <span class="co">// ...</span></span>
<span id="cb563-29"><a href="#cb563-29" aria-hidden="true"></a>}</span>
<span id="cb563-30"><a href="#cb563-30" aria-hidden="true"></a></span>
<span id="cb563-31"><a href="#cb563-31" aria-hidden="true"></a><span class="dt">void</span> Foo::init(<span class="dt">char</span> x, <span class="dt">int</span> y)</span>
<span id="cb563-32"><a href="#cb563-32" aria-hidden="true"></a>{</span>
<span id="cb563-33"><a href="#cb563-33" aria-hidden="true"></a>  <span class="co">// ...</span></span>
<span id="cb563-34"><a href="#cb563-34" aria-hidden="true"></a>}</span>
<span id="cb563-35"><a href="#cb563-35" aria-hidden="true"></a><span class="er">```</span>&lt;/li&gt;</span>
<span id="cb563-36"><a href="#cb563-36" aria-hidden="true"></a>&lt;/ol&gt;</span>
<span id="cb563-37"><a href="#cb563-37" aria-hidden="true"></a></span>
<span id="cb563-38"><a href="#cb563-38" aria-hidden="true"></a>See &lt;a href=<span class="st">&quot;https://isocpp.org/wiki/faq/ctors</span></span>
<span id="cb563-39"><a href="#cb563-39" aria-hidden="true"></a><span class="pp">#</span><span class="er">init-methods&quot; rel=&quot;noreferrer&quot;&gt;the C++FAQ entry&lt;/a&gt; for reference.  </span></span>
<span id="cb563-40"><a href="#cb563-40" aria-hidden="true"></a></span>
<span id="cb563-41"><a href="#cb563-41" aria-hidden="true"></a></span>
<span id="cb563-42"><a href="#cb563-42" aria-hidden="true"></a><span class="pp">#</span><span class="er">### Answer 2 (score 108)</span></span>
<span id="cb563-43"><a href="#cb563-43" aria-hidden="true"></a>No, you can<span class="ch">&#39;t</span><span class="er"> call one constructor from another in C++03 (called a delegating constructor).  </span></span>
<span id="cb563-44"><a href="#cb563-44" aria-hidden="true"></a></span>
<span id="cb563-45"><a href="#cb563-45" aria-hidden="true"></a>&lt;p&gt;This changed in C++<span class="dv">11</span> (aka C++<span class="er">0x</span>), which added support <span class="cf">for</span> the following syntax:&lt;br&gt;</span>
<span id="cb563-46"><a href="#cb563-46" aria-hidden="true"></a>(example taken from &lt;a href=<span class="st">&quot;http://en.wikipedia.org/wiki/C%2B%2B11</span></span>
<span id="cb563-47"><a href="#cb563-47" aria-hidden="true"></a><span class="pp">#</span><span class="er">Object_construction_improvement&quot; rel=&quot;noreferrer&quot;&gt;Wikipedia&lt;/a&gt;)&lt;/p&gt;</span></span>
<span id="cb563-48"><a href="#cb563-48" aria-hidden="true"></a></span>
<span id="cb563-49"><a href="#cb563-49" aria-hidden="true"></a><span class="er">```</span>c++</span>
<span id="cb563-50"><a href="#cb563-50" aria-hidden="true"></a><span class="kw">class</span> SomeType</span>
<span id="cb563-51"><a href="#cb563-51" aria-hidden="true"></a>{</span>
<span id="cb563-52"><a href="#cb563-52" aria-hidden="true"></a>  <span class="dt">int</span> number;</span>
<span id="cb563-53"><a href="#cb563-53" aria-hidden="true"></a></span>
<span id="cb563-54"><a href="#cb563-54" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb563-55"><a href="#cb563-55" aria-hidden="true"></a>  SomeType(<span class="dt">int</span> newNumber) : number(newNumber) {}</span>
<span id="cb563-56"><a href="#cb563-56" aria-hidden="true"></a>  SomeType() : SomeType(<span class="dv">42</span>) {}</span>
<span id="cb563-57"><a href="#cb563-57" aria-hidden="true"></a>};</span></code></pre></div>
</section>
<section id="answer-3-score-40-1" class="level4">
<h4>Answer 3 (score 40)</h4>
<p>I believe you can call a constructor from a constructor. It will compile and run. I recently saw someone do this and it ran on both Windows and Linux.</p>
<p>It just doesn’t do what you want. The inner constructor will construct a temporary local object which gets deleted once the outer constructor returns. They would have to be different constructors as well or you would create a recursive call.</p>
<p>Ref: <a href="https://isocpp.org/wiki/faq/ctors
#init-methods" rel="noreferrer">https://isocpp.org/wiki/faq/ctors#init-methods</a></p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="c-structure-initialization-score-426595-in-2017" class="level3">
<h3>95: C++ Structure Initialization (score <a href="https://stackoverflow.com/q/11516657.html">426595</a> in 2017)</h3>
<section id="question-92" class="level4">
<h4>Question</h4>
<p>Is it possible to initialize structs in C++ as indicated below</p>
<div class="sourceCode" id="cb564"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb564-1"><a href="#cb564-1" aria-hidden="true"></a><span class="kw">struct</span> address {</span>
<span id="cb564-2"><a href="#cb564-2" aria-hidden="true"></a>    <span class="dt">int</span> street_no;</span>
<span id="cb564-3"><a href="#cb564-3" aria-hidden="true"></a>    <span class="dt">char</span> *street_name;</span>
<span id="cb564-4"><a href="#cb564-4" aria-hidden="true"></a>    <span class="dt">char</span> *city;</span>
<span id="cb564-5"><a href="#cb564-5" aria-hidden="true"></a>    <span class="dt">char</span> *prov;</span>
<span id="cb564-6"><a href="#cb564-6" aria-hidden="true"></a>    <span class="dt">char</span> *postal_code;</span>
<span id="cb564-7"><a href="#cb564-7" aria-hidden="true"></a>};</span>
<span id="cb564-8"><a href="#cb564-8" aria-hidden="true"></a>address temp_address =</span>
<span id="cb564-9"><a href="#cb564-9" aria-hidden="true"></a>    { .city = <span class="st">&quot;Hamilton&quot;</span>, .prov = <span class="st">&quot;Ontario&quot;</span> };</span></code></pre></div>
<p>The links <a href="http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=/com.ibm.xlcpp8a.doc/language/ref/strin.htm" rel="noreferrer">here</a> and <a href="https://stackoverflow.com/questions/5790534/static-structure-initialization-with-tags-in-c">here</a> mention that it is possible to use this style only in C. If so why is this not possible in C++? Is there any underlying technical reason why it is not implemented in C++, or is it bad practice to use this style. I like using this way of initializing because my struct is big and this style gives me clear readability of what value is assigned to which member.</p>
<p>Please share with me if there are other ways through which we can achieve the same readability.</p>
<p>I have referred the following links before posting this question</p>
<ol>
<li>
<a href="http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=/com.ibm.xlcpp8a.doc/language/ref/strin.htm" rel="noreferrer">C/C++ for AIX</a>
</li>
<li>
<a href="https://stackoverflow.com/questions/7700878/c-structure-initialization-with-variable">C Structure Initialization with Variable</a>
</li>
<li>
<a href="https://stackoverflow.com/questions/5790534/static-structure-initialization-with-tags-in-c">Static structure initialization with tags in C++</a>
</li>
<li>
<a href="https://stackoverflow.com/questions/9557464/c11-proper-structure-initialization">C++11 Proper Structure Initialization</a>
</li>
</ol>
</section>
<section id="answer-accepted-score-150" class="level4">
<h4>Answer accepted (score 150)</h4>
<p>If you want to make it clear what each initializer value is, just split it up on multiple lines, with a comment on each:</p>
<div class="sourceCode" id="cb565"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb565-1"><a href="#cb565-1" aria-hidden="true"></a>address temp_addres = {</span>
<span id="cb565-2"><a href="#cb565-2" aria-hidden="true"></a>  <span class="dv">0</span>,  <span class="co">// street_no</span></span>
<span id="cb565-3"><a href="#cb565-3" aria-hidden="true"></a>  <span class="kw">nullptr</span>,  <span class="co">// street_name</span></span>
<span id="cb565-4"><a href="#cb565-4" aria-hidden="true"></a>  <span class="st">&quot;Hamilton&quot;</span>,  <span class="co">// city</span></span>
<span id="cb565-5"><a href="#cb565-5" aria-hidden="true"></a>  <span class="st">&quot;Ontario&quot;</span>,  <span class="co">// prov</span></span>
<span id="cb565-6"><a href="#cb565-6" aria-hidden="true"></a>  <span class="kw">nullptr</span>,  <span class="co">// postal_code</span></span>
<span id="cb565-7"><a href="#cb565-7" aria-hidden="true"></a>};</span></code></pre></div>
</section>
<section id="answer-2-score-94" class="level4">
<h4>Answer 2 (score 94)</h4>
<p>After <a href="https://stackoverflow.com/questions/5790534/static-structure-initialization-with-tags-in-c">my question</a> resulted in no satisfying result (because C++ doesn’t implement tag-based init for structures), I took the trick I found here: <a href="https://stackoverflow.com/questions/1069621/are-members-of-a-c-struct-initialized-to-0-by-default">Are members of a C++ struct initialized to 0 by default?</a></p>
<p>For you it would amount to do that:</p>
<div class="sourceCode" id="cb566"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb566-1"><a href="#cb566-1" aria-hidden="true"></a>address temp_address = {}; <span class="co">// will zero all fields in C++</span></span>
<span id="cb566-2"><a href="#cb566-2" aria-hidden="true"></a>temp_address.city = <span class="st">&quot;Hamilton&quot;</span>;</span>
<span id="cb566-3"><a href="#cb566-3" aria-hidden="true"></a>temp_address.prov = <span class="st">&quot;Ontario&quot;</span>;</span></code></pre></div>
<p>This is certainly the closest to what you wanted originally (zero all the fields except those you want to initialize).</p>
</section>
<section id="answer-3-score-15" class="level4">
<h4>Answer 3 (score 15)</h4>
<p>As others have mentioned this is designated initializer.</p>
<p>This feature is part of <a href="https://en.wikipedia.org/wiki/C%2B%2B20" rel="noreferrer">C++20</a></p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-can-i-loop-through-a-c-map-of-maps-score-424125-in-2019" class="level3">
<h3>96: How can I loop through a C++ map of maps? (score <a href="https://stackoverflow.com/q/4844886.html">424125</a> in 2019)</h3>
<section id="question-93" class="level4">
<h4>Question</h4>
<p>How can I loop through a <code>std::map</code> in C++? My map is defined as:</p>
<div class="sourceCode" id="cb567"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb567-1"><a href="#cb567-1" aria-hidden="true"></a><span class="bu">std::</span>map&lt; <span class="bu">std::</span>string, <span class="bu">std::</span>map&lt;<span class="bu">std::</span>string, <span class="bu">std::</span>string&gt; &gt;</span></code></pre></div>
<p>For example, the above container holds data like this:</p>
<div class="sourceCode" id="cb568"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb568-1"><a href="#cb568-1" aria-hidden="true"></a>m[<span class="st">&quot;name1&quot;</span>][<span class="st">&quot;value1&quot;</span>] = <span class="st">&quot;data1&quot;</span>;</span>
<span id="cb568-2"><a href="#cb568-2" aria-hidden="true"></a>m[<span class="st">&quot;name1&quot;</span>][<span class="st">&quot;value2&quot;</span>] = <span class="st">&quot;data2&quot;</span>;</span>
<span id="cb568-3"><a href="#cb568-3" aria-hidden="true"></a>m[<span class="st">&quot;name2&quot;</span>][<span class="st">&quot;value1&quot;</span>] = <span class="st">&quot;data1&quot;</span>;</span>
<span id="cb568-4"><a href="#cb568-4" aria-hidden="true"></a>m[<span class="st">&quot;name2&quot;</span>][<span class="st">&quot;value2&quot;</span>] = <span class="st">&quot;data2&quot;</span>;</span>
<span id="cb568-5"><a href="#cb568-5" aria-hidden="true"></a>m[<span class="st">&quot;name3&quot;</span>][<span class="st">&quot;value1&quot;</span>] = <span class="st">&quot;data1&quot;</span>;</span>
<span id="cb568-6"><a href="#cb568-6" aria-hidden="true"></a>m[<span class="st">&quot;name3&quot;</span>][<span class="st">&quot;value2&quot;</span>] = <span class="st">&quot;data2&quot;</span>;</span></code></pre></div>
<p>How can I loop through this map and access the various values?</p>
</section>
<section id="answer-accepted-score-555" class="level4">
<h4>Answer accepted (score 555)</h4>
<p>Old question but the remaining answers are outdated as of C++11 - you can use a <a href="http://en.cppreference.com/w/cpp/language/range-for" rel="noreferrer">ranged based for loop</a> and simply do:</p>
<div class="sourceCode" id="cb569"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb569-1"><a href="#cb569-1" aria-hidden="true"></a><span class="bu">std::</span>map&lt;<span class="bu">std::</span>string, <span class="bu">std::</span>map&lt;<span class="bu">std::</span>string, <span class="bu">std::</span>string&gt;&gt; mymap;</span>
<span id="cb569-2"><a href="#cb569-2" aria-hidden="true"></a></span>
<span id="cb569-3"><a href="#cb569-3" aria-hidden="true"></a><span class="cf">for</span>(<span class="kw">auto</span> <span class="at">const</span> &amp;ent1 : mymap) {</span>
<span id="cb569-4"><a href="#cb569-4" aria-hidden="true"></a>  <span class="co">// ent1.first is the first key</span></span>
<span id="cb569-5"><a href="#cb569-5" aria-hidden="true"></a>  <span class="cf">for</span>(<span class="kw">auto</span> <span class="at">const</span> &amp;ent2 : ent1.second) {</span>
<span id="cb569-6"><a href="#cb569-6" aria-hidden="true"></a>    <span class="co">// ent2.first is the second key</span></span>
<span id="cb569-7"><a href="#cb569-7" aria-hidden="true"></a>    <span class="co">// ent2.second is the data</span></span>
<span id="cb569-8"><a href="#cb569-8" aria-hidden="true"></a>  }</span>
<span id="cb569-9"><a href="#cb569-9" aria-hidden="true"></a>}</span></code></pre></div>
<p>this should be much cleaner than the earlier versions, and avoids unnecessary copies.</p>
<p>Some favour replacing the comments with explicit definitions of reference variables (which get optimised away if unused):</p>
<div class="sourceCode" id="cb570"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb570-1"><a href="#cb570-1" aria-hidden="true"></a><span class="cf">for</span>(<span class="kw">auto</span> <span class="at">const</span> &amp;ent1 : mymap) {</span>
<span id="cb570-2"><a href="#cb570-2" aria-hidden="true"></a>  <span class="kw">auto</span> <span class="at">const</span> &amp;outer_key = ent1.first;</span>
<span id="cb570-3"><a href="#cb570-3" aria-hidden="true"></a>  <span class="kw">auto</span> <span class="at">const</span> &amp;inner_map = ent1.second;</span>
<span id="cb570-4"><a href="#cb570-4" aria-hidden="true"></a>  <span class="cf">for</span>(<span class="kw">auto</span> <span class="at">const</span> &amp;ent2 : inner_map) {</span>
<span id="cb570-5"><a href="#cb570-5" aria-hidden="true"></a>    <span class="kw">auto</span> <span class="at">const</span> &amp;inner_key   = ent2.first;</span>
<span id="cb570-6"><a href="#cb570-6" aria-hidden="true"></a>    <span class="kw">auto</span> <span class="at">const</span> &amp;inner_value = ent2.second;</span>
<span id="cb570-7"><a href="#cb570-7" aria-hidden="true"></a>  }</span>
<span id="cb570-8"><a href="#cb570-8" aria-hidden="true"></a>}</span></code></pre></div>
</section>
<section id="answer-2-score-307" class="level4">
<h4>Answer 2 (score 307)</h4>
<p>You can use an iterator.</p>
<div class="sourceCode" id="cb571"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb571-1"><a href="#cb571-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="bu">std::</span>map&lt;<span class="bu">std::</span>string, <span class="bu">std::</span>map&lt;<span class="bu">std::</span>string, <span class="bu">std::</span>string&gt;&gt;::iterator <span class="dt">it_type</span>;</span>
<span id="cb571-2"><a href="#cb571-2" aria-hidden="true"></a><span class="cf">for</span>(<span class="dt">it_type</span> iterator = m.begin(); iterator != m.end(); iterator++) {</span>
<span id="cb571-3"><a href="#cb571-3" aria-hidden="true"></a>    <span class="co">// iterator-&gt;first = key</span></span>
<span id="cb571-4"><a href="#cb571-4" aria-hidden="true"></a>    <span class="co">// iterator-&gt;second = value</span></span>
<span id="cb571-5"><a href="#cb571-5" aria-hidden="true"></a>    <span class="co">// Repeat if you also want to iterate through the second map.</span></span>
<span id="cb571-6"><a href="#cb571-6" aria-hidden="true"></a>}</span></code></pre></div>
</section>
<section id="answer-3-score-59" class="level4">
<h4>Answer 3 (score 59)</h4>
<div class="sourceCode" id="cb572"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb572-1"><a href="#cb572-1" aria-hidden="true"></a><span class="cf">for</span>(<span class="bu">std::</span>map&lt;<span class="bu">std::</span>string, <span class="bu">std::</span>map&lt;<span class="bu">std::</span>string, <span class="bu">std::</span>string&gt; &gt;::iterator outer_iter=map.begin(); outer_iter!=map.end(); ++outer_iter) {</span>
<span id="cb572-2"><a href="#cb572-2" aria-hidden="true"></a>    <span class="cf">for</span>(<span class="bu">std::</span>map&lt;<span class="bu">std::</span>string, <span class="bu">std::</span>string&gt;::iterator inner_iter=outer_iter-&gt;second.begin(); inner_iter!=outer_iter-&gt;second.end(); ++inner_iter) {</span>
<span id="cb572-3"><a href="#cb572-3" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; inner_iter-&gt;second &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb572-4"><a href="#cb572-4" aria-hidden="true"></a>    }</span>
<span id="cb572-5"><a href="#cb572-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>or nicer in C++0x:</p>
<div class="sourceCode" id="cb573"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb573-1"><a href="#cb573-1" aria-hidden="true"></a><span class="cf">for</span>(<span class="kw">auto</span> outer_iter=map.begin(); outer_iter!=map.end(); ++outer_iter) {</span>
<span id="cb573-2"><a href="#cb573-2" aria-hidden="true"></a>    <span class="cf">for</span>(<span class="kw">auto</span> inner_iter=outer_iter-&gt;second.begin(); inner_iter!=outer_iter-&gt;second.end(); ++inner_iter) {</span>
<span id="cb573-3"><a href="#cb573-3" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; inner_iter-&gt;second &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb573-4"><a href="#cb573-4" aria-hidden="true"></a>    }</span>
<span id="cb573-5"><a href="#cb573-5" aria-hidden="true"></a>}</span></code></pre></div>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="what-is-the-difference-between-g-and-gcc-score-422142-in-2018" class="level3">
<h3>97: What is the difference between g++ and gcc? (score <a href="https://stackoverflow.com/q/172587.html">422142</a> in 2018)</h3>
<section id="question-94" class="level4">
<h4>Question</h4>
<p>What is the difference between g++ and gcc? Which ones should be used for general c++ development?</p>
</section>
<section id="answer-accepted-score-673" class="level4">
<h4>Answer accepted (score 673)</h4>
<p><code>gcc</code> and <code>g++</code> are compiler-drivers of the GNU Compiler <em>Collection</em> (which was once upon a time just the GNU <em>C Compiler</em>).</p>
<p>Even though they automatically determine which backends (<code>cc1</code> <code>cc1plus</code> …) to call depending on the file-type, unless overridden with <code>-x language</code>, they have some differences.</p>
<p>The probably most important difference in their defaults is which libraries they link against automatically.</p>
<p>According to GCC’s online documentation <a href="https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html" rel="noreferrer">link options</a> and <a href="https://gcc.gnu.org/onlinedocs/gcc/Invoking-G_002b_002b.html" rel="noreferrer">how g++ is invoked</a>, <code>g++</code> is equivalent to <code>gcc -xc++ -lstdc++ -shared-libgcc</code> (the 1st is a compiler option, the 2nd two are linker options). This can be checked by running both with the <code>-v</code> option (it displays the backend toolchain commands being run).</p>
</section>
<section id="answer-2-score-413" class="level4">
<h4>Answer 2 (score 413)</h4>
<p>GCC: GNU Compiler Collection<br></p>
<ul>
<li>
Referrers to all the different languages that are supported by the GNU compiler.
</li>
</ul>
<p>
gcc: GNU C      Compiler<br> g++: GNU C++ Compiler<br>
</p>
<p>The main differences:</p>
<ol>
<li>
gcc will compile: <em>.c/</em>.cpp files as C and C++ respectively.
</li>
<li>
g++ will compile: <em>.c/</em>.cpp files but they will all be treated as C++ files.
</li>
<li>
Also if you use g++ to link the object files it automatically links in the std C++ libraries (gcc does not do this).
</li>
<li>
gcc compiling C files has fewer predefined macros.
</li>
<li>
gcc compiling <em>.cpp and g++ compiling </em>.c/*.cpp files has a few extra macros.
</li>
</ol>
<p>Extra Macros when compiling *.cpp files:</p>
<div class="sourceCode" id="cb574"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb574-1"><a href="#cb574-1" aria-hidden="true"></a></span>
<span id="cb574-2"><a href="#cb574-2" aria-hidden="true"></a><span class="pp">#define </span><span class="ot">__GXX_WEAK__</span><span class="pp"> 1</span></span>
<span id="cb574-3"><a href="#cb574-3" aria-hidden="true"></a></span>
<span id="cb574-4"><a href="#cb574-4" aria-hidden="true"></a><span class="pp">#define </span><span class="ot">__cplusplus</span><span class="pp"> 1</span></span>
<span id="cb574-5"><a href="#cb574-5" aria-hidden="true"></a></span>
<span id="cb574-6"><a href="#cb574-6" aria-hidden="true"></a><span class="pp">#define </span><span class="ot">__DEPRECATED</span><span class="pp"> 1</span></span>
<span id="cb574-7"><a href="#cb574-7" aria-hidden="true"></a></span>
<span id="cb574-8"><a href="#cb574-8" aria-hidden="true"></a><span class="pp">#define </span><span class="ot">__GNUG__</span><span class="pp"> 4</span></span>
<span id="cb574-9"><a href="#cb574-9" aria-hidden="true"></a></span>
<span id="cb574-10"><a href="#cb574-10" aria-hidden="true"></a><span class="pp">#define </span><span class="ot">__EXCEPTIONS</span><span class="pp"> 1</span></span>
<span id="cb574-11"><a href="#cb574-11" aria-hidden="true"></a></span>
<span id="cb574-12"><a href="#cb574-12" aria-hidden="true"></a><span class="pp">#define __private_extern__ </span><span class="at">extern</span></span></code></pre></div>
</section>
<section id="answer-3-score-76" class="level4">
<h4>Answer 3 (score 76)</h4>
<p>For c++ you should use g++.</p>
<p>It’s the same compiler (e.g. the GNU compiler collection). GCC or G++ just choose a different front-end with different default options.</p>
<p>In a nutshell: if you use g++ the frontend will tell the linker that you may want to link with the C++ standard libraries. The gcc frontend won’t do that (also it could link with them if you pass the right command line options).</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-do-you-make-a-http-request-with-c-score-412466-in-2015" class="level3">
<h3>98: How do you make a HTTP request with C++? (score <a href="https://stackoverflow.com/q/1011339.html">412466</a> in 2015)</h3>
<section id="question-95" class="level4">
<h4>Question</h4>
<p>Is there any way to easily make a HTTP request with C++? Specifically, I want to download the contents of a page (an API) and check the contents to see if it contains a 1 or a 0. Is it also possible to download the contents into a string?</p>
</section>
<section id="answer-accepted-score-228" class="level4">
<h4>Answer accepted (score 228)</h4>
<p>I had the same problem. <a href="http://curl.haxx.se/libcurl/" rel="noreferrer">libcurl</a> is really complete. There is a C++ wrapper <a href="http://www.curlpp.org/" rel="noreferrer">curlpp</a> that might interest you as you ask for a C++ library. <a href="http://www.webdav.org/neon/" rel="noreferrer">neon</a> is another interesting C library that also support <a href="https://fr.wikipedia.org/wiki/WebDAV" rel="noreferrer">WebDAV</a>.</p>
<p>
curlpp seems natural if you use C++. There are many examples provided in the source distribution. To get the content of an URL you do something like that (extracted from examples) :
</p>
<div class="sourceCode" id="cb575"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb575-1"><a href="#cb575-1" aria-hidden="true"></a><span class="co">// Edit : rewritten for cURLpp 0.7.3</span></span>
<span id="cb575-2"><a href="#cb575-2" aria-hidden="true"></a><span class="co">// Note : namespace changed, was cURLpp in 0.7.2 ...</span></span>
<span id="cb575-3"><a href="#cb575-3" aria-hidden="true"></a></span>
<span id="cb575-4"><a href="#cb575-4" aria-hidden="true"></a></span>
<span id="cb575-5"><a href="#cb575-5" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;curlpp/cURLpp.hpp&gt;</span></span>
<span id="cb575-6"><a href="#cb575-6" aria-hidden="true"></a></span>
<span id="cb575-7"><a href="#cb575-7" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;curlpp/Options.hpp&gt;</span></span>
<span id="cb575-8"><a href="#cb575-8" aria-hidden="true"></a></span>
<span id="cb575-9"><a href="#cb575-9" aria-hidden="true"></a><span class="co">// RAII cleanup</span></span>
<span id="cb575-10"><a href="#cb575-10" aria-hidden="true"></a></span>
<span id="cb575-11"><a href="#cb575-11" aria-hidden="true"></a>curlpp::Cleanup myCleanup;</span>
<span id="cb575-12"><a href="#cb575-12" aria-hidden="true"></a></span>
<span id="cb575-13"><a href="#cb575-13" aria-hidden="true"></a><span class="co">// Send request and get a result.</span></span>
<span id="cb575-14"><a href="#cb575-14" aria-hidden="true"></a><span class="co">// Here I use a shortcut to get it in a string stream ...</span></span>
<span id="cb575-15"><a href="#cb575-15" aria-hidden="true"></a></span>
<span id="cb575-16"><a href="#cb575-16" aria-hidden="true"></a><span class="bu">std::</span>ostringstream os;</span>
<span id="cb575-17"><a href="#cb575-17" aria-hidden="true"></a>os &lt;&lt; curlpp::options::Url(<span class="bu">std::</span>string(<span class="st">&quot;http://www.wikipedia.org&quot;</span>));</span>
<span id="cb575-18"><a href="#cb575-18" aria-hidden="true"></a></span>
<span id="cb575-19"><a href="#cb575-19" aria-hidden="true"></a>string asAskedInQuestion = os.str();</span></code></pre></div>
<p>See the <code>examples</code> directory in <a href="https://github.com/jpbarrette/curlpp" rel="noreferrer">curlpp source distribution</a>, there is a lot of more complex cases, as well as a <a href="https://github.com/jpbarrette/curlpp/blob/master/examples/example22.cpp" rel="noreferrer">simple complete minimal one</a> using curlpp.</p>
<p>my 2 cents …</p>
</section>
<section id="answer-2-score-112" class="level4">
<h4>Answer 2 (score 112)</h4>
<p>Windows code:</p>
<div class="sourceCode" id="cb576"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb576-1"><a href="#cb576-1" aria-hidden="true"></a></span>
<span id="cb576-2"><a href="#cb576-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb576-3"><a href="#cb576-3" aria-hidden="true"></a></span>
<span id="cb576-4"><a href="#cb576-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;winsock2.h&gt;</span></span>
<span id="cb576-5"><a href="#cb576-5" aria-hidden="true"></a></span>
<span id="cb576-6"><a href="#cb576-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;windows.h&gt;</span></span>
<span id="cb576-7"><a href="#cb576-7" aria-hidden="true"></a></span>
<span id="cb576-8"><a href="#cb576-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb576-9"><a href="#cb576-9" aria-hidden="true"></a></span>
<span id="cb576-10"><a href="#cb576-10" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb576-11"><a href="#cb576-11" aria-hidden="true"></a></span>
<span id="cb576-12"><a href="#cb576-12" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;locale&gt;</span></span>
<span id="cb576-13"><a href="#cb576-13" aria-hidden="true"></a></span>
<span id="cb576-14"><a href="#cb576-14" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sstream&gt;</span></span>
<span id="cb576-15"><a href="#cb576-15" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb576-16"><a href="#cb576-16" aria-hidden="true"></a></span>
<span id="cb576-17"><a href="#cb576-17" aria-hidden="true"></a><span class="pp">#pragma comment(lib,&quot;ws2_32.lib&quot;)</span></span>
<span id="cb576-18"><a href="#cb576-18" aria-hidden="true"></a></span>
<span id="cb576-19"><a href="#cb576-19" aria-hidden="true"></a></span>
<span id="cb576-20"><a href="#cb576-20" aria-hidden="true"></a></span>
<span id="cb576-21"><a href="#cb576-21" aria-hidden="true"></a></span>
<span id="cb576-22"><a href="#cb576-22" aria-hidden="true"></a><span class="dt">int</span> main( <span class="dt">void</span> ){</span>
<span id="cb576-23"><a href="#cb576-23" aria-hidden="true"></a></span>
<span id="cb576-24"><a href="#cb576-24" aria-hidden="true"></a>WSADATA wsaData;</span>
<span id="cb576-25"><a href="#cb576-25" aria-hidden="true"></a>SOCKET Socket;</span>
<span id="cb576-26"><a href="#cb576-26" aria-hidden="true"></a>SOCKADDR_IN SockAddr;</span>
<span id="cb576-27"><a href="#cb576-27" aria-hidden="true"></a><span class="dt">int</span> lineCount=<span class="dv">0</span>;</span>
<span id="cb576-28"><a href="#cb576-28" aria-hidden="true"></a><span class="dt">int</span> rowCount=<span class="dv">0</span>;</span>
<span id="cb576-29"><a href="#cb576-29" aria-hidden="true"></a><span class="kw">struct</span> hostent *host;</span>
<span id="cb576-30"><a href="#cb576-30" aria-hidden="true"></a>locale local;</span>
<span id="cb576-31"><a href="#cb576-31" aria-hidden="true"></a><span class="dt">char</span> buffer[<span class="dv">10000</span>];</span>
<span id="cb576-32"><a href="#cb576-32" aria-hidden="true"></a><span class="dt">int</span> i = <span class="dv">0</span> ;</span>
<span id="cb576-33"><a href="#cb576-33" aria-hidden="true"></a><span class="dt">int</span> nDataLength;</span>
<span id="cb576-34"><a href="#cb576-34" aria-hidden="true"></a>string website_HTML;</span>
<span id="cb576-35"><a href="#cb576-35" aria-hidden="true"></a></span>
<span id="cb576-36"><a href="#cb576-36" aria-hidden="true"></a><span class="co">// website url</span></span>
<span id="cb576-37"><a href="#cb576-37" aria-hidden="true"></a>string url = <span class="st">&quot;www.google.com&quot;</span>;</span>
<span id="cb576-38"><a href="#cb576-38" aria-hidden="true"></a></span>
<span id="cb576-39"><a href="#cb576-39" aria-hidden="true"></a><span class="co">//HTTP GET</span></span>
<span id="cb576-40"><a href="#cb576-40" aria-hidden="true"></a>string get_http = <span class="st">&quot;GET / HTTP/1.1</span><span class="sc">\r\n</span><span class="st">Host: &quot;</span> + url + <span class="st">&quot;</span><span class="sc">\r\n</span><span class="st">Connection: close</span><span class="sc">\r\n\r\n</span><span class="st">&quot;</span>;</span>
<span id="cb576-41"><a href="#cb576-41" aria-hidden="true"></a></span>
<span id="cb576-42"><a href="#cb576-42" aria-hidden="true"></a></span>
<span id="cb576-43"><a href="#cb576-43" aria-hidden="true"></a>    <span class="cf">if</span> (WSAStartup(MAKEWORD(<span class="dv">2</span>,<span class="dv">2</span>), &amp;wsaData) != <span class="dv">0</span>){</span>
<span id="cb576-44"><a href="#cb576-44" aria-hidden="true"></a>        cout &lt;&lt; <span class="st">&quot;WSAStartup failed.</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb576-45"><a href="#cb576-45" aria-hidden="true"></a>        system(<span class="st">&quot;pause&quot;</span>);</span>
<span id="cb576-46"><a href="#cb576-46" aria-hidden="true"></a>        <span class="co">//return 1;</span></span>
<span id="cb576-47"><a href="#cb576-47" aria-hidden="true"></a>    }</span>
<span id="cb576-48"><a href="#cb576-48" aria-hidden="true"></a></span>
<span id="cb576-49"><a href="#cb576-49" aria-hidden="true"></a>    Socket=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);</span>
<span id="cb576-50"><a href="#cb576-50" aria-hidden="true"></a>    host = gethostbyname(url.c_str());</span>
<span id="cb576-51"><a href="#cb576-51" aria-hidden="true"></a></span>
<span id="cb576-52"><a href="#cb576-52" aria-hidden="true"></a>    SockAddr.sin_port=htons(<span class="dv">80</span>);</span>
<span id="cb576-53"><a href="#cb576-53" aria-hidden="true"></a>    SockAddr.sin_family=AF_INET;</span>
<span id="cb576-54"><a href="#cb576-54" aria-hidden="true"></a>    SockAddr.sin_addr.<span class="va">s_addr</span> = *((<span class="dt">unsigned</span> <span class="dt">long</span>*)host-&gt;h_addr);</span>
<span id="cb576-55"><a href="#cb576-55" aria-hidden="true"></a></span>
<span id="cb576-56"><a href="#cb576-56" aria-hidden="true"></a>    <span class="cf">if</span>(<span class="fu">connect</span>(Socket,(SOCKADDR*)(&amp;SockAddr),<span class="kw">sizeof</span>(SockAddr)) != <span class="dv">0</span>){</span>
<span id="cb576-57"><a href="#cb576-57" aria-hidden="true"></a>        cout &lt;&lt; <span class="st">&quot;Could not connect&quot;</span>;</span>
<span id="cb576-58"><a href="#cb576-58" aria-hidden="true"></a>        system(<span class="st">&quot;pause&quot;</span>);</span>
<span id="cb576-59"><a href="#cb576-59" aria-hidden="true"></a>        <span class="co">//return 1;</span></span>
<span id="cb576-60"><a href="#cb576-60" aria-hidden="true"></a>    }</span>
<span id="cb576-61"><a href="#cb576-61" aria-hidden="true"></a></span>
<span id="cb576-62"><a href="#cb576-62" aria-hidden="true"></a>    <span class="co">// send GET / HTTP</span></span>
<span id="cb576-63"><a href="#cb576-63" aria-hidden="true"></a>    send(Socket,get_http.c_str(), strlen(get_http.c_str()),<span class="dv">0</span> );</span>
<span id="cb576-64"><a href="#cb576-64" aria-hidden="true"></a></span>
<span id="cb576-65"><a href="#cb576-65" aria-hidden="true"></a>    <span class="co">// recieve html</span></span>
<span id="cb576-66"><a href="#cb576-66" aria-hidden="true"></a>    <span class="cf">while</span> ((nDataLength = recv(Socket,buffer,<span class="dv">10000</span>,<span class="dv">0</span>)) &gt; <span class="dv">0</span>){        </span>
<span id="cb576-67"><a href="#cb576-67" aria-hidden="true"></a>        <span class="dt">int</span> i = <span class="dv">0</span>;</span>
<span id="cb576-68"><a href="#cb576-68" aria-hidden="true"></a>        <span class="cf">while</span> (buffer[i] &gt;= <span class="dv">32</span> || buffer[i] == <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span> || buffer[i] == <span class="ch">&#39;</span><span class="sc">\r</span><span class="ch">&#39;</span>){</span>
<span id="cb576-69"><a href="#cb576-69" aria-hidden="true"></a></span>
<span id="cb576-70"><a href="#cb576-70" aria-hidden="true"></a>            website_HTML+=buffer[i];</span>
<span id="cb576-71"><a href="#cb576-71" aria-hidden="true"></a>            i += <span class="dv">1</span>;</span>
<span id="cb576-72"><a href="#cb576-72" aria-hidden="true"></a>        }               </span>
<span id="cb576-73"><a href="#cb576-73" aria-hidden="true"></a>    }</span>
<span id="cb576-74"><a href="#cb576-74" aria-hidden="true"></a></span>
<span id="cb576-75"><a href="#cb576-75" aria-hidden="true"></a>    closesocket(Socket);</span>
<span id="cb576-76"><a href="#cb576-76" aria-hidden="true"></a>    WSACleanup();</span>
<span id="cb576-77"><a href="#cb576-77" aria-hidden="true"></a></span>
<span id="cb576-78"><a href="#cb576-78" aria-hidden="true"></a>    <span class="co">// Display HTML source </span></span>
<span id="cb576-79"><a href="#cb576-79" aria-hidden="true"></a>    cout&lt;&lt;website_HTML;</span>
<span id="cb576-80"><a href="#cb576-80" aria-hidden="true"></a></span>
<span id="cb576-81"><a href="#cb576-81" aria-hidden="true"></a>    <span class="co">// pause</span></span>
<span id="cb576-82"><a href="#cb576-82" aria-hidden="true"></a>    cout&lt;&lt;<span class="st">&quot;</span><span class="sc">\n\n</span><span class="st">Press ANY key to close.</span><span class="sc">\n\n</span><span class="st">&quot;</span>;</span>
<span id="cb576-83"><a href="#cb576-83" aria-hidden="true"></a>    cin.ignore(); cin.get(); </span>
<span id="cb576-84"><a href="#cb576-84" aria-hidden="true"></a></span>
<span id="cb576-85"><a href="#cb576-85" aria-hidden="true"></a></span>
<span id="cb576-86"><a href="#cb576-86" aria-hidden="true"></a> <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb576-87"><a href="#cb576-87" aria-hidden="true"></a>}</span></code></pre></div>
<p>Here is a much better implementation:</p>
<div class="sourceCode" id="cb577"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb577-1"><a href="#cb577-1" aria-hidden="true"></a></span>
<span id="cb577-2"><a href="#cb577-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;windows.h&gt;</span></span>
<span id="cb577-3"><a href="#cb577-3" aria-hidden="true"></a></span>
<span id="cb577-4"><a href="#cb577-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb577-5"><a href="#cb577-5" aria-hidden="true"></a></span>
<span id="cb577-6"><a href="#cb577-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb577-7"><a href="#cb577-7" aria-hidden="true"></a></span>
<span id="cb577-8"><a href="#cb577-8" aria-hidden="true"></a><span class="kw">using</span> <span class="bu">std::</span>string;</span>
<span id="cb577-9"><a href="#cb577-9" aria-hidden="true"></a></span>
<span id="cb577-10"><a href="#cb577-10" aria-hidden="true"></a></span>
<span id="cb577-11"><a href="#cb577-11" aria-hidden="true"></a><span class="pp">#pragma comment(lib,&quot;ws2_32.lib&quot;)</span></span>
<span id="cb577-12"><a href="#cb577-12" aria-hidden="true"></a></span>
<span id="cb577-13"><a href="#cb577-13" aria-hidden="true"></a></span>
<span id="cb577-14"><a href="#cb577-14" aria-hidden="true"></a>HINSTANCE hInst;</span>
<span id="cb577-15"><a href="#cb577-15" aria-hidden="true"></a>WSADATA wsaData;</span>
<span id="cb577-16"><a href="#cb577-16" aria-hidden="true"></a><span class="dt">void</span> mParseUrl(<span class="dt">char</span> *mUrl, string &amp;serverName, string &amp;filepath, string &amp;filename);</span>
<span id="cb577-17"><a href="#cb577-17" aria-hidden="true"></a>SOCKET connectToServer(<span class="dt">char</span> *szServerName, WORD portNum);</span>
<span id="cb577-18"><a href="#cb577-18" aria-hidden="true"></a><span class="dt">int</span> getHeaderLength(<span class="dt">char</span> *content);</span>
<span id="cb577-19"><a href="#cb577-19" aria-hidden="true"></a><span class="dt">char</span> *readUrl2(<span class="dt">char</span> *szUrl, <span class="dt">long</span> &amp;bytesReturnedOut, <span class="dt">char</span> **headerOut);</span>
<span id="cb577-20"><a href="#cb577-20" aria-hidden="true"></a></span>
<span id="cb577-21"><a href="#cb577-21" aria-hidden="true"></a></span>
<span id="cb577-22"><a href="#cb577-22" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb577-23"><a href="#cb577-23" aria-hidden="true"></a>{</span>
<span id="cb577-24"><a href="#cb577-24" aria-hidden="true"></a>    <span class="at">const</span> <span class="dt">int</span> bufLen = <span class="dv">1024</span>;</span>
<span id="cb577-25"><a href="#cb577-25" aria-hidden="true"></a>    <span class="dt">char</span> *szUrl = <span class="st">&quot;http://stackoverflow.com&quot;</span>;</span>
<span id="cb577-26"><a href="#cb577-26" aria-hidden="true"></a>    <span class="dt">long</span> fileSize;</span>
<span id="cb577-27"><a href="#cb577-27" aria-hidden="true"></a>    <span class="dt">char</span> *memBuffer, *headerBuffer;</span>
<span id="cb577-28"><a href="#cb577-28" aria-hidden="true"></a>    <span class="dt">FILE</span> *fp;</span>
<span id="cb577-29"><a href="#cb577-29" aria-hidden="true"></a></span>
<span id="cb577-30"><a href="#cb577-30" aria-hidden="true"></a>    memBuffer = headerBuffer = NULL;</span>
<span id="cb577-31"><a href="#cb577-31" aria-hidden="true"></a></span>
<span id="cb577-32"><a href="#cb577-32" aria-hidden="true"></a>    <span class="cf">if</span> ( WSAStartup(<span class="bn">0x101</span>, &amp;wsaData) != <span class="dv">0</span>)</span>
<span id="cb577-33"><a href="#cb577-33" aria-hidden="true"></a>        <span class="cf">return</span> -<span class="dv">1</span>;</span>
<span id="cb577-34"><a href="#cb577-34" aria-hidden="true"></a></span>
<span id="cb577-35"><a href="#cb577-35" aria-hidden="true"></a></span>
<span id="cb577-36"><a href="#cb577-36" aria-hidden="true"></a>    memBuffer = readUrl2(szUrl, fileSize, &amp;headerBuffer);</span>
<span id="cb577-37"><a href="#cb577-37" aria-hidden="true"></a>    printf(<span class="st">&quot;returned from readUrl</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb577-38"><a href="#cb577-38" aria-hidden="true"></a>    printf(<span class="st">&quot;data returned:</span><span class="sc">\n%s</span><span class="st">&quot;</span>, memBuffer);</span>
<span id="cb577-39"><a href="#cb577-39" aria-hidden="true"></a>    <span class="cf">if</span> (fileSize != <span class="dv">0</span>)</span>
<span id="cb577-40"><a href="#cb577-40" aria-hidden="true"></a>    {</span>
<span id="cb577-41"><a href="#cb577-41" aria-hidden="true"></a>        printf(<span class="st">&quot;Got some data</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb577-42"><a href="#cb577-42" aria-hidden="true"></a>        fp = fopen(<span class="st">&quot;downloaded.file&quot;</span>, <span class="st">&quot;wb&quot;</span>);</span>
<span id="cb577-43"><a href="#cb577-43" aria-hidden="true"></a>        fwrite(memBuffer, <span class="dv">1</span>, fileSize, fp);</span>
<span id="cb577-44"><a href="#cb577-44" aria-hidden="true"></a>        fclose(fp);</span>
<span id="cb577-45"><a href="#cb577-45" aria-hidden="true"></a>         <span class="kw">delete</span>(memBuffer);</span>
<span id="cb577-46"><a href="#cb577-46" aria-hidden="true"></a>        <span class="kw">delete</span>(headerBuffer);</span>
<span id="cb577-47"><a href="#cb577-47" aria-hidden="true"></a>    }</span>
<span id="cb577-48"><a href="#cb577-48" aria-hidden="true"></a></span>
<span id="cb577-49"><a href="#cb577-49" aria-hidden="true"></a>    WSACleanup();</span>
<span id="cb577-50"><a href="#cb577-50" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb577-51"><a href="#cb577-51" aria-hidden="true"></a>}</span>
<span id="cb577-52"><a href="#cb577-52" aria-hidden="true"></a></span>
<span id="cb577-53"><a href="#cb577-53" aria-hidden="true"></a></span>
<span id="cb577-54"><a href="#cb577-54" aria-hidden="true"></a><span class="dt">void</span> mParseUrl(<span class="dt">char</span> *mUrl, string &amp;serverName, string &amp;filepath, string &amp;filename)</span>
<span id="cb577-55"><a href="#cb577-55" aria-hidden="true"></a>{</span>
<span id="cb577-56"><a href="#cb577-56" aria-hidden="true"></a>    string::<span class="dt">size_type</span> n;</span>
<span id="cb577-57"><a href="#cb577-57" aria-hidden="true"></a>    string url = mUrl;</span>
<span id="cb577-58"><a href="#cb577-58" aria-hidden="true"></a></span>
<span id="cb577-59"><a href="#cb577-59" aria-hidden="true"></a>    <span class="cf">if</span> (url.substr(<span class="dv">0</span>,<span class="dv">7</span>) == <span class="st">&quot;http://&quot;</span>)</span>
<span id="cb577-60"><a href="#cb577-60" aria-hidden="true"></a>        url.erase(<span class="dv">0</span>,<span class="dv">7</span>);</span>
<span id="cb577-61"><a href="#cb577-61" aria-hidden="true"></a></span>
<span id="cb577-62"><a href="#cb577-62" aria-hidden="true"></a>    <span class="cf">if</span> (url.substr(<span class="dv">0</span>,<span class="dv">8</span>) == <span class="st">&quot;https://&quot;</span>)</span>
<span id="cb577-63"><a href="#cb577-63" aria-hidden="true"></a>        url.erase(<span class="dv">0</span>,<span class="dv">8</span>);</span>
<span id="cb577-64"><a href="#cb577-64" aria-hidden="true"></a></span>
<span id="cb577-65"><a href="#cb577-65" aria-hidden="true"></a>    n = url.find(<span class="ch">&#39;/&#39;</span>);</span>
<span id="cb577-66"><a href="#cb577-66" aria-hidden="true"></a>    <span class="cf">if</span> (n != string::npos)</span>
<span id="cb577-67"><a href="#cb577-67" aria-hidden="true"></a>    {</span>
<span id="cb577-68"><a href="#cb577-68" aria-hidden="true"></a>        serverName = url.substr(<span class="dv">0</span>,n);</span>
<span id="cb577-69"><a href="#cb577-69" aria-hidden="true"></a>        filepath = url.substr(n);</span>
<span id="cb577-70"><a href="#cb577-70" aria-hidden="true"></a>        n = filepath.rfind(<span class="ch">&#39;/&#39;</span>);</span>
<span id="cb577-71"><a href="#cb577-71" aria-hidden="true"></a>        filename = filepath.substr(n+<span class="dv">1</span>);</span>
<span id="cb577-72"><a href="#cb577-72" aria-hidden="true"></a>    }</span>
<span id="cb577-73"><a href="#cb577-73" aria-hidden="true"></a></span>
<span id="cb577-74"><a href="#cb577-74" aria-hidden="true"></a>    <span class="cf">else</span></span>
<span id="cb577-75"><a href="#cb577-75" aria-hidden="true"></a>    {</span>
<span id="cb577-76"><a href="#cb577-76" aria-hidden="true"></a>        serverName = url;</span>
<span id="cb577-77"><a href="#cb577-77" aria-hidden="true"></a>        filepath = <span class="st">&quot;/&quot;</span>;</span>
<span id="cb577-78"><a href="#cb577-78" aria-hidden="true"></a>        filename = <span class="st">&quot;&quot;</span>;</span>
<span id="cb577-79"><a href="#cb577-79" aria-hidden="true"></a>    }</span>
<span id="cb577-80"><a href="#cb577-80" aria-hidden="true"></a>}</span>
<span id="cb577-81"><a href="#cb577-81" aria-hidden="true"></a></span>
<span id="cb577-82"><a href="#cb577-82" aria-hidden="true"></a>SOCKET connectToServer(<span class="dt">char</span> *szServerName, WORD portNum)</span>
<span id="cb577-83"><a href="#cb577-83" aria-hidden="true"></a>{</span>
<span id="cb577-84"><a href="#cb577-84" aria-hidden="true"></a>    <span class="kw">struct</span> hostent *hp;</span>
<span id="cb577-85"><a href="#cb577-85" aria-hidden="true"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> addr;</span>
<span id="cb577-86"><a href="#cb577-86" aria-hidden="true"></a>    <span class="kw">struct</span> sockaddr_in server;</span>
<span id="cb577-87"><a href="#cb577-87" aria-hidden="true"></a>    SOCKET conn;</span>
<span id="cb577-88"><a href="#cb577-88" aria-hidden="true"></a></span>
<span id="cb577-89"><a href="#cb577-89" aria-hidden="true"></a>    conn = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span>
<span id="cb577-90"><a href="#cb577-90" aria-hidden="true"></a>    <span class="cf">if</span> (conn == INVALID_SOCKET)</span>
<span id="cb577-91"><a href="#cb577-91" aria-hidden="true"></a>        <span class="cf">return</span> NULL;</span>
<span id="cb577-92"><a href="#cb577-92" aria-hidden="true"></a></span>
<span id="cb577-93"><a href="#cb577-93" aria-hidden="true"></a>    <span class="cf">if</span>(inet_addr(szServerName)==INADDR_NONE)</span>
<span id="cb577-94"><a href="#cb577-94" aria-hidden="true"></a>    {</span>
<span id="cb577-95"><a href="#cb577-95" aria-hidden="true"></a>        hp=gethostbyname(szServerName);</span>
<span id="cb577-96"><a href="#cb577-96" aria-hidden="true"></a>    }</span>
<span id="cb577-97"><a href="#cb577-97" aria-hidden="true"></a>    <span class="cf">else</span></span>
<span id="cb577-98"><a href="#cb577-98" aria-hidden="true"></a>    {</span>
<span id="cb577-99"><a href="#cb577-99" aria-hidden="true"></a>        addr=inet_addr(szServerName);</span>
<span id="cb577-100"><a href="#cb577-100" aria-hidden="true"></a>        hp=gethostbyaddr((<span class="dt">char</span>*)&amp;addr,<span class="kw">sizeof</span>(addr),AF_INET);</span>
<span id="cb577-101"><a href="#cb577-101" aria-hidden="true"></a>    }</span>
<span id="cb577-102"><a href="#cb577-102" aria-hidden="true"></a></span>
<span id="cb577-103"><a href="#cb577-103" aria-hidden="true"></a>    <span class="cf">if</span>(hp==NULL)</span>
<span id="cb577-104"><a href="#cb577-104" aria-hidden="true"></a>    {</span>
<span id="cb577-105"><a href="#cb577-105" aria-hidden="true"></a>        closesocket(conn);</span>
<span id="cb577-106"><a href="#cb577-106" aria-hidden="true"></a>        <span class="cf">return</span> NULL;</span>
<span id="cb577-107"><a href="#cb577-107" aria-hidden="true"></a>    }</span>
<span id="cb577-108"><a href="#cb577-108" aria-hidden="true"></a></span>
<span id="cb577-109"><a href="#cb577-109" aria-hidden="true"></a>    server.sin_addr.<span class="va">s_addr</span>=*((<span class="dt">unsigned</span> <span class="dt">long</span>*)hp-&gt;h_addr);</span>
<span id="cb577-110"><a href="#cb577-110" aria-hidden="true"></a>    server.sin_family=AF_INET;</span>
<span id="cb577-111"><a href="#cb577-111" aria-hidden="true"></a>    server.sin_port=htons(portNum);</span>
<span id="cb577-112"><a href="#cb577-112" aria-hidden="true"></a>    <span class="cf">if</span>(<span class="fu">connect</span>(conn,(<span class="kw">struct</span> sockaddr*)&amp;server,<span class="kw">sizeof</span>(server)))</span>
<span id="cb577-113"><a href="#cb577-113" aria-hidden="true"></a>    {</span>
<span id="cb577-114"><a href="#cb577-114" aria-hidden="true"></a>        closesocket(conn);</span>
<span id="cb577-115"><a href="#cb577-115" aria-hidden="true"></a>        <span class="cf">return</span> NULL;</span>
<span id="cb577-116"><a href="#cb577-116" aria-hidden="true"></a>    }</span>
<span id="cb577-117"><a href="#cb577-117" aria-hidden="true"></a>    <span class="cf">return</span> conn;</span>
<span id="cb577-118"><a href="#cb577-118" aria-hidden="true"></a>}</span>
<span id="cb577-119"><a href="#cb577-119" aria-hidden="true"></a></span>
<span id="cb577-120"><a href="#cb577-120" aria-hidden="true"></a><span class="dt">int</span> getHeaderLength(<span class="dt">char</span> *content)</span>
<span id="cb577-121"><a href="#cb577-121" aria-hidden="true"></a>{</span>
<span id="cb577-122"><a href="#cb577-122" aria-hidden="true"></a>    <span class="at">const</span> <span class="dt">char</span> *srchStr1 = <span class="st">&quot;</span><span class="sc">\r\n\r\n</span><span class="st">&quot;</span>, *srchStr2 = <span class="st">&quot;</span><span class="sc">\n\r\n\r</span><span class="st">&quot;</span>;</span>
<span id="cb577-123"><a href="#cb577-123" aria-hidden="true"></a>    <span class="dt">char</span> *findPos;</span>
<span id="cb577-124"><a href="#cb577-124" aria-hidden="true"></a>    <span class="dt">int</span> ofset = -<span class="dv">1</span>;</span>
<span id="cb577-125"><a href="#cb577-125" aria-hidden="true"></a></span>
<span id="cb577-126"><a href="#cb577-126" aria-hidden="true"></a>    findPos = strstr(content, srchStr1);</span>
<span id="cb577-127"><a href="#cb577-127" aria-hidden="true"></a>    <span class="cf">if</span> (findPos != NULL)</span>
<span id="cb577-128"><a href="#cb577-128" aria-hidden="true"></a>    {</span>
<span id="cb577-129"><a href="#cb577-129" aria-hidden="true"></a>        ofset = findPos - content;</span>
<span id="cb577-130"><a href="#cb577-130" aria-hidden="true"></a>        ofset += strlen(srchStr1);</span>
<span id="cb577-131"><a href="#cb577-131" aria-hidden="true"></a>    }</span>
<span id="cb577-132"><a href="#cb577-132" aria-hidden="true"></a></span>
<span id="cb577-133"><a href="#cb577-133" aria-hidden="true"></a>    <span class="cf">else</span></span>
<span id="cb577-134"><a href="#cb577-134" aria-hidden="true"></a>    {</span>
<span id="cb577-135"><a href="#cb577-135" aria-hidden="true"></a>        findPos = strstr(content, srchStr2);</span>
<span id="cb577-136"><a href="#cb577-136" aria-hidden="true"></a>        <span class="cf">if</span> (findPos != NULL)</span>
<span id="cb577-137"><a href="#cb577-137" aria-hidden="true"></a>        {</span>
<span id="cb577-138"><a href="#cb577-138" aria-hidden="true"></a>            ofset = findPos - content;</span>
<span id="cb577-139"><a href="#cb577-139" aria-hidden="true"></a>            ofset += strlen(srchStr2);</span>
<span id="cb577-140"><a href="#cb577-140" aria-hidden="true"></a>        }</span>
<span id="cb577-141"><a href="#cb577-141" aria-hidden="true"></a>    }</span>
<span id="cb577-142"><a href="#cb577-142" aria-hidden="true"></a>    <span class="cf">return</span> ofset;</span>
<span id="cb577-143"><a href="#cb577-143" aria-hidden="true"></a>}</span>
<span id="cb577-144"><a href="#cb577-144" aria-hidden="true"></a></span>
<span id="cb577-145"><a href="#cb577-145" aria-hidden="true"></a><span class="dt">char</span> *readUrl2(<span class="dt">char</span> *szUrl, <span class="dt">long</span> &amp;bytesReturnedOut, <span class="dt">char</span> **headerOut)</span>
<span id="cb577-146"><a href="#cb577-146" aria-hidden="true"></a>{</span>
<span id="cb577-147"><a href="#cb577-147" aria-hidden="true"></a>    <span class="at">const</span> <span class="dt">int</span> bufSize = <span class="dv">512</span>;</span>
<span id="cb577-148"><a href="#cb577-148" aria-hidden="true"></a>    <span class="dt">char</span> readBuffer[bufSize], sendBuffer[bufSize], tmpBuffer[bufSize];</span>
<span id="cb577-149"><a href="#cb577-149" aria-hidden="true"></a>    <span class="dt">char</span> *tmpResult=NULL, *result;</span>
<span id="cb577-150"><a href="#cb577-150" aria-hidden="true"></a>    SOCKET conn;</span>
<span id="cb577-151"><a href="#cb577-151" aria-hidden="true"></a>    string server, filepath, filename;</span>
<span id="cb577-152"><a href="#cb577-152" aria-hidden="true"></a>    <span class="dt">long</span> totalBytesRead, thisReadSize, headerLen;</span>
<span id="cb577-153"><a href="#cb577-153" aria-hidden="true"></a></span>
<span id="cb577-154"><a href="#cb577-154" aria-hidden="true"></a>    mParseUrl(szUrl, server, filepath, filename);</span>
<span id="cb577-155"><a href="#cb577-155" aria-hidden="true"></a></span>
<span id="cb577-156"><a href="#cb577-156" aria-hidden="true"></a>    <span class="co">///////////// step 1, connect //////////////////////</span></span>
<span id="cb577-157"><a href="#cb577-157" aria-hidden="true"></a>    conn = connectToServer((<span class="dt">char</span>*)server.c_str(), <span class="dv">80</span>);</span>
<span id="cb577-158"><a href="#cb577-158" aria-hidden="true"></a></span>
<span id="cb577-159"><a href="#cb577-159" aria-hidden="true"></a>    <span class="co">///////////// step 2, send GET request /////////////</span></span>
<span id="cb577-160"><a href="#cb577-160" aria-hidden="true"></a>    sprintf(tmpBuffer, <span class="st">&quot;GET </span><span class="sc">%s</span><span class="st"> HTTP/1.0&quot;</span>, filepath.c_str());</span>
<span id="cb577-161"><a href="#cb577-161" aria-hidden="true"></a>    strcpy(sendBuffer, tmpBuffer);</span>
<span id="cb577-162"><a href="#cb577-162" aria-hidden="true"></a>    strcat(sendBuffer, <span class="st">&quot;</span><span class="sc">\r\n</span><span class="st">&quot;</span>);</span>
<span id="cb577-163"><a href="#cb577-163" aria-hidden="true"></a>    sprintf(tmpBuffer, <span class="st">&quot;Host: </span><span class="sc">%s</span><span class="st">&quot;</span>, server.c_str());</span>
<span id="cb577-164"><a href="#cb577-164" aria-hidden="true"></a>    strcat(sendBuffer, tmpBuffer);</span>
<span id="cb577-165"><a href="#cb577-165" aria-hidden="true"></a>    strcat(sendBuffer, <span class="st">&quot;</span><span class="sc">\r\n</span><span class="st">&quot;</span>);</span>
<span id="cb577-166"><a href="#cb577-166" aria-hidden="true"></a>    strcat(sendBuffer, <span class="st">&quot;</span><span class="sc">\r\n</span><span class="st">&quot;</span>);</span>
<span id="cb577-167"><a href="#cb577-167" aria-hidden="true"></a>    send(conn, sendBuffer, strlen(sendBuffer), <span class="dv">0</span>);</span>
<span id="cb577-168"><a href="#cb577-168" aria-hidden="true"></a></span>
<span id="cb577-169"><a href="#cb577-169" aria-hidden="true"></a><span class="co">//    SetWindowText(edit3Hwnd, sendBuffer);</span></span>
<span id="cb577-170"><a href="#cb577-170" aria-hidden="true"></a>    printf(<span class="st">&quot;Buffer being sent:</span><span class="sc">\n%s</span><span class="st">&quot;</span>, sendBuffer);</span>
<span id="cb577-171"><a href="#cb577-171" aria-hidden="true"></a></span>
<span id="cb577-172"><a href="#cb577-172" aria-hidden="true"></a>    <span class="co">///////////// step 3 - get received bytes ////////////////</span></span>
<span id="cb577-173"><a href="#cb577-173" aria-hidden="true"></a>    <span class="co">// Receive until the peer closes the connection</span></span>
<span id="cb577-174"><a href="#cb577-174" aria-hidden="true"></a>    totalBytesRead = <span class="dv">0</span>;</span>
<span id="cb577-175"><a href="#cb577-175" aria-hidden="true"></a>    <span class="cf">while</span>(<span class="dv">1</span>)</span>
<span id="cb577-176"><a href="#cb577-176" aria-hidden="true"></a>    {</span>
<span id="cb577-177"><a href="#cb577-177" aria-hidden="true"></a>        memset(readBuffer, <span class="dv">0</span>, bufSize);</span>
<span id="cb577-178"><a href="#cb577-178" aria-hidden="true"></a>        thisReadSize = recv (conn, readBuffer, bufSize, <span class="dv">0</span>);</span>
<span id="cb577-179"><a href="#cb577-179" aria-hidden="true"></a></span>
<span id="cb577-180"><a href="#cb577-180" aria-hidden="true"></a>        <span class="cf">if</span> ( thisReadSize &lt;= <span class="dv">0</span> )</span>
<span id="cb577-181"><a href="#cb577-181" aria-hidden="true"></a>            <span class="cf">break</span>;</span>
<span id="cb577-182"><a href="#cb577-182" aria-hidden="true"></a></span>
<span id="cb577-183"><a href="#cb577-183" aria-hidden="true"></a>        tmpResult = (<span class="dt">char</span>*)realloc(tmpResult, thisReadSize+totalBytesRead);</span>
<span id="cb577-184"><a href="#cb577-184" aria-hidden="true"></a></span>
<span id="cb577-185"><a href="#cb577-185" aria-hidden="true"></a>        memcpy(tmpResult+totalBytesRead, readBuffer, thisReadSize);</span>
<span id="cb577-186"><a href="#cb577-186" aria-hidden="true"></a>        totalBytesRead += thisReadSize;</span>
<span id="cb577-187"><a href="#cb577-187" aria-hidden="true"></a>    }</span>
<span id="cb577-188"><a href="#cb577-188" aria-hidden="true"></a></span>
<span id="cb577-189"><a href="#cb577-189" aria-hidden="true"></a>    headerLen = getHeaderLength(tmpResult);</span>
<span id="cb577-190"><a href="#cb577-190" aria-hidden="true"></a>    <span class="dt">long</span> contenLen = totalBytesRead-headerLen;</span>
<span id="cb577-191"><a href="#cb577-191" aria-hidden="true"></a>    result = <span class="kw">new</span> <span class="dt">char</span>[contenLen+<span class="dv">1</span>];</span>
<span id="cb577-192"><a href="#cb577-192" aria-hidden="true"></a>    memcpy(result, tmpResult+headerLen, contenLen);</span>
<span id="cb577-193"><a href="#cb577-193" aria-hidden="true"></a>    result[contenLen] = <span class="bn">0x0</span>;</span>
<span id="cb577-194"><a href="#cb577-194" aria-hidden="true"></a>    <span class="dt">char</span> *myTmp;</span>
<span id="cb577-195"><a href="#cb577-195" aria-hidden="true"></a></span>
<span id="cb577-196"><a href="#cb577-196" aria-hidden="true"></a>    myTmp = <span class="kw">new</span> <span class="dt">char</span>[headerLen+<span class="dv">1</span>];</span>
<span id="cb577-197"><a href="#cb577-197" aria-hidden="true"></a>    strncpy(myTmp, tmpResult, headerLen);</span>
<span id="cb577-198"><a href="#cb577-198" aria-hidden="true"></a>    myTmp[headerLen] = NULL;</span>
<span id="cb577-199"><a href="#cb577-199" aria-hidden="true"></a>    <span class="kw">delete</span>(tmpResult);</span>
<span id="cb577-200"><a href="#cb577-200" aria-hidden="true"></a>    *headerOut = myTmp;</span>
<span id="cb577-201"><a href="#cb577-201" aria-hidden="true"></a></span>
<span id="cb577-202"><a href="#cb577-202" aria-hidden="true"></a>    bytesReturnedOut = contenLen;</span>
<span id="cb577-203"><a href="#cb577-203" aria-hidden="true"></a>    closesocket(conn);</span>
<span id="cb577-204"><a href="#cb577-204" aria-hidden="true"></a>    <span class="cf">return</span>(result);</span>
<span id="cb577-205"><a href="#cb577-205" aria-hidden="true"></a>}</span></code></pre></div>
</section>
<section id="answer-3-score-38-3" class="level4">
<h4>Answer 3 (score 38)</h4>
<p>On Linux, I tried cpp-netlib, libcurl, curlpp, urdl, boost::asio and considered Qt (but turned it down based on the license). All of these were either incomplete for this use, had sloppy interfaces, had poor documentation, were unmaintained or didn’t support https.</p>
<p>Then, at the suggestion of <a href="https://stackoverflow.com/a/1012577/278976">https://stackoverflow.com/a/1012577/278976</a>, I tried POCO. Wow, I wish I had seen this years ago. Here’s an example of making an HTTP GET request:</p>
<p><a href="http://xjia.heroku.com/2011/09/10/learning-poco-get-with-http/" rel="noreferrer">http://xjia.heroku.com/2011/09/10/learning-poco-get-with-http/</a></p>
<p>POCO is free, open source (boost license). And no, I don’t have any affiliation with the company; I just really like their interfaces. Great job guys (and gals).</p>
<p><a href="http://pocoproject.org/download/index.html" rel="noreferrer">http://pocoproject.org/download/index.html</a></p>
<p>Hope this helps someone… it took me three days to try all of these libraries out.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-do-you-create-a-static-class-in-c-score-412436-in-2018" class="level3">
<h3>99: How do you create a static class in C++? (score <a href="https://stackoverflow.com/q/9321.html">412436</a> in 2018)</h3>
<section id="question-96" class="level4">
<h4>Question</h4>
<p>How do you create a static class in C++? I should be able to do something like:</p>
<div class="sourceCode" id="cb578"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb578-1"><a href="#cb578-1" aria-hidden="true"></a>cout &lt;&lt; <span class="st">&quot;bit 5 is &quot;</span> &lt;&lt; BitParser::getBitAt(buffer, <span class="dv">5</span>) &lt;&lt; endl;</span></code></pre></div>
<p>Assuming I created the <code>BitParser</code> class. What would the <code>BitParser</code> class definition look like?</p>
</section>
<section id="answer-accepted-score-255" class="level4">
<h4>Answer accepted (score 255)</h4>
<p>If you’re looking for a way of applying the “static” keyword to a class, like you can in C # for example, then you won’t be able to without using Managed C++.</p>
<p>But the looks of your sample, you just need to create a public static method on your BitParser object. Like so:</p>
<p><strong>BitParser.h</strong></p>
<div class="sourceCode" id="cb579"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb579-1"><a href="#cb579-1" aria-hidden="true"></a><span class="kw">class</span> BitParser</span>
<span id="cb579-2"><a href="#cb579-2" aria-hidden="true"></a>{</span>
<span id="cb579-3"><a href="#cb579-3" aria-hidden="true"></a> <span class="kw">public</span>:</span>
<span id="cb579-4"><a href="#cb579-4" aria-hidden="true"></a>  <span class="at">static</span> <span class="dt">bool</span> getBitAt(<span class="dt">int</span> buffer, <span class="dt">int</span> bitIndex);</span>
<span id="cb579-5"><a href="#cb579-5" aria-hidden="true"></a></span>
<span id="cb579-6"><a href="#cb579-6" aria-hidden="true"></a>  <span class="co">// ...lots of great stuff</span></span>
<span id="cb579-7"><a href="#cb579-7" aria-hidden="true"></a></span>
<span id="cb579-8"><a href="#cb579-8" aria-hidden="true"></a> <span class="kw">private</span>:</span>
<span id="cb579-9"><a href="#cb579-9" aria-hidden="true"></a>  <span class="co">// Disallow creating an instance of this object</span></span>
<span id="cb579-10"><a href="#cb579-10" aria-hidden="true"></a>  BitParser() {}</span>
<span id="cb579-11"><a href="#cb579-11" aria-hidden="true"></a>};</span></code></pre></div>
<p><strong>BitParser.cpp</strong></p>
<div class="sourceCode" id="cb580"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb580-1"><a href="#cb580-1" aria-hidden="true"></a><span class="dt">bool</span> BitParser::getBitAt(<span class="dt">int</span> buffer, <span class="dt">int</span> bitIndex)</span>
<span id="cb580-2"><a href="#cb580-2" aria-hidden="true"></a>{</span>
<span id="cb580-3"><a href="#cb580-3" aria-hidden="true"></a>  <span class="dt">bool</span> isBitSet = <span class="kw">false</span>;</span>
<span id="cb580-4"><a href="#cb580-4" aria-hidden="true"></a>  <span class="co">// .. determine if bit is set</span></span>
<span id="cb580-5"><a href="#cb580-5" aria-hidden="true"></a>  <span class="cf">return</span> isBitSet;</span>
<span id="cb580-6"><a href="#cb580-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>You can use this code to call the method in the same way as your example code.</p>
<p>Hope that helps! Cheers.</p>
</section>
<section id="answer-2-score-237" class="level4">
<h4>Answer 2 (score 237)</h4>
<p>Consider <a href="https://stackoverflow.com/questions/9321/how-do-you-create-a-static-class-in-c/9348
#9348">Matt Price’s solution</a>.</p>
<ol>
<li>
In C++, a “static class” has no meaning. The nearest thing is a class with only static methods and members.
</li>
<li>
Using static methods will only limit you.
</li>
</ol>
<p>What you want is, expressed in C++ semantics, to put your function (for it <strong>is</strong> a function) in a namespace.</p>
<h5>
Edit 2011-11-11
</h2>
<p>There is no “static class” in C++. The nearest concept would be a class with only static methods. For example:</p>
<div class="sourceCode" id="cb581"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb581-1"><a href="#cb581-1" aria-hidden="true"></a><span class="co">// header</span></span>
<span id="cb581-2"><a href="#cb581-2" aria-hidden="true"></a><span class="kw">class</span> MyClass</span>
<span id="cb581-3"><a href="#cb581-3" aria-hidden="true"></a>{</span>
<span id="cb581-4"><a href="#cb581-4" aria-hidden="true"></a>   <span class="kw">public</span> :</span>
<span id="cb581-5"><a href="#cb581-5" aria-hidden="true"></a>      <span class="at">static</span> <span class="dt">void</span> myMethod() ;</span>
<span id="cb581-6"><a href="#cb581-6" aria-hidden="true"></a>} ;</span>
<span id="cb581-7"><a href="#cb581-7" aria-hidden="true"></a></span>
<span id="cb581-8"><a href="#cb581-8" aria-hidden="true"></a><span class="co">// source</span></span>
<span id="cb581-9"><a href="#cb581-9" aria-hidden="true"></a><span class="dt">void</span> MyClass::myMethod()</span>
<span id="cb581-10"><a href="#cb581-10" aria-hidden="true"></a>{</span>
<span id="cb581-11"><a href="#cb581-11" aria-hidden="true"></a>   <span class="co">// etc.</span></span>
<span id="cb581-12"><a href="#cb581-12" aria-hidden="true"></a>}</span></code></pre></div>
<p>But you must remember that “static classes” are hacks in the Java-like kind of languages (e.g. C #) that are unable to have non-member functions, so they have instead to move them inside classes as static methods.</p>
<p>In C++, what you really want is a non-member function that you’ll declare in a namespace:</p>
<div class="sourceCode" id="cb582"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb582-1"><a href="#cb582-1" aria-hidden="true"></a><span class="co">// header</span></span>
<span id="cb582-2"><a href="#cb582-2" aria-hidden="true"></a><span class="kw">namespace</span> MyNamespace</span>
<span id="cb582-3"><a href="#cb582-3" aria-hidden="true"></a>{</span>
<span id="cb582-4"><a href="#cb582-4" aria-hidden="true"></a>   <span class="dt">void</span> myMethod() ;</span>
<span id="cb582-5"><a href="#cb582-5" aria-hidden="true"></a>}</span>
<span id="cb582-6"><a href="#cb582-6" aria-hidden="true"></a></span>
<span id="cb582-7"><a href="#cb582-7" aria-hidden="true"></a><span class="co">// source</span></span>
<span id="cb582-8"><a href="#cb582-8" aria-hidden="true"></a><span class="kw">namespace</span> MyNamespace</span>
<span id="cb582-9"><a href="#cb582-9" aria-hidden="true"></a>{</span>
<span id="cb582-10"><a href="#cb582-10" aria-hidden="true"></a>   <span class="dt">void</span> myMethod()</span>
<span id="cb582-11"><a href="#cb582-11" aria-hidden="true"></a>   {</span>
<span id="cb582-12"><a href="#cb582-12" aria-hidden="true"></a>      <span class="co">// etc.</span></span>
<span id="cb582-13"><a href="#cb582-13" aria-hidden="true"></a>   }</span>
<span id="cb582-14"><a href="#cb582-14" aria-hidden="true"></a>}</span></code></pre></div>
<h5>
Why is that?
</h3>
<p>In C++, the namespace is more powerful than classes for the “Java static method” pattern, because:</p>
<ul>
<li>
static methods have access to the classes private symbols
</li>
<li>
private static methods are still visible (if inaccessible) to everyone, which breaches somewhat the encapsulation
</li>
<li>
static methods cannot be forward-declared
</li>
<li>
static methods cannot be overloaded by the class user without modifying the library header
</li>
<li>
there is nothing that can be done by a static method that can’t be done better than a (possibly friend) non-member function in the same namespace
</li>
<li>
namespaces have their own semantics (they can be combined, they can be anonymous, etc.)
</li>
<li>
etc.
</li>
</ul>
<p>Conclusion: Do not copy/paste that Java/C #’s pattern in C++. In Java/C#, the pattern is mandatory. But in C++, it is bad style.</p>
<h5>
Edit 2010-06-10
</h2>
<p>There was an argument in favor to the static method because sometimes, one needs to use a static private member variable.</p>
<p>I disagree somewhat, as show below:</p>
<h5>
The “Static private member” solution
</h3>
<div class="sourceCode" id="cb583"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb583-1"><a href="#cb583-1" aria-hidden="true"></a><span class="co">// HPP</span></span>
<span id="cb583-2"><a href="#cb583-2" aria-hidden="true"></a></span>
<span id="cb583-3"><a href="#cb583-3" aria-hidden="true"></a><span class="kw">class</span> Foo</span>
<span id="cb583-4"><a href="#cb583-4" aria-hidden="true"></a>{</span>
<span id="cb583-5"><a href="#cb583-5" aria-hidden="true"></a>   <span class="kw">public</span> :</span>
<span id="cb583-6"><a href="#cb583-6" aria-hidden="true"></a>      <span class="dt">void</span> barA() ;</span>
<span id="cb583-7"><a href="#cb583-7" aria-hidden="true"></a>   <span class="kw">private</span> :</span>
<span id="cb583-8"><a href="#cb583-8" aria-hidden="true"></a>      <span class="dt">void</span> barB() ;</span>
<span id="cb583-9"><a href="#cb583-9" aria-hidden="true"></a>      <span class="at">static</span> <span class="bu">std::</span>string myGlobal ;</span>
<span id="cb583-10"><a href="#cb583-10" aria-hidden="true"></a>} ;</span></code></pre></div>
<p>First, myGlobal is called myGlobal because it is still a global private variable. A look at the CPP source will clarify that:</p>
<div class="sourceCode" id="cb584"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb584-1"><a href="#cb584-1" aria-hidden="true"></a><span class="co">// CPP</span></span>
<span id="cb584-2"><a href="#cb584-2" aria-hidden="true"></a><span class="bu">std::</span>string Foo::myGlobal ; <span class="co">// You MUST declare it in a CPP</span></span>
<span id="cb584-3"><a href="#cb584-3" aria-hidden="true"></a></span>
<span id="cb584-4"><a href="#cb584-4" aria-hidden="true"></a><span class="dt">void</span> Foo::barA()</span>
<span id="cb584-5"><a href="#cb584-5" aria-hidden="true"></a>{</span>
<span id="cb584-6"><a href="#cb584-6" aria-hidden="true"></a>   <span class="co">// I can access Foo::myGlobal</span></span>
<span id="cb584-7"><a href="#cb584-7" aria-hidden="true"></a>}</span>
<span id="cb584-8"><a href="#cb584-8" aria-hidden="true"></a></span>
<span id="cb584-9"><a href="#cb584-9" aria-hidden="true"></a><span class="dt">void</span> Foo::barB()</span>
<span id="cb584-10"><a href="#cb584-10" aria-hidden="true"></a>{</span>
<span id="cb584-11"><a href="#cb584-11" aria-hidden="true"></a>   <span class="co">// I can access Foo::myGlobal, too</span></span>
<span id="cb584-12"><a href="#cb584-12" aria-hidden="true"></a>}</span>
<span id="cb584-13"><a href="#cb584-13" aria-hidden="true"></a></span>
<span id="cb584-14"><a href="#cb584-14" aria-hidden="true"></a><span class="dt">void</span> barC()</span>
<span id="cb584-15"><a href="#cb584-15" aria-hidden="true"></a>{</span>
<span id="cb584-16"><a href="#cb584-16" aria-hidden="true"></a>   <span class="co">// I CAN&#39;T access Foo::myGlobal !!!</span></span>
<span id="cb584-17"><a href="#cb584-17" aria-hidden="true"></a>}</span></code></pre></div>
<p>At first sight, the fact the free function barC can’t access Foo::myGlobal seems a good thing from an encapsulation viewpoint… It’s cool because someone looking at the HPP won’t be able (unless resorting to sabotage) to access Foo::myGlobal.</p>
<p>But if you look at it closely, you’ll find that it is a colossal mistake: Not only your private variable must still be declared in the HPP (and so, visible to all the world, despite being private), but you must declare in the same HPP all (as in ALL) functions that will be authorized to access it !!!</p>
<p>So <b>using a private static member is like walking outside in the nude with the list of your lovers tattooed on your skin : No one is authorized to touch, but everyone is able to peek at. And the bonus: Everyone can have the names of those authorized to play with your privies.</b></p>
<p>
<code>private</code> indeed… :-D
</p>
<h5>
The “Anonymous namespaces” solution
</h3>
<p>Anonymous namespaces will have the advantage of making things private really private.</p>
<p>First, the HPP header</p>
<div class="sourceCode" id="cb585"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb585-1"><a href="#cb585-1" aria-hidden="true"></a><span class="co">// HPP</span></span>
<span id="cb585-2"><a href="#cb585-2" aria-hidden="true"></a></span>
<span id="cb585-3"><a href="#cb585-3" aria-hidden="true"></a><span class="kw">namespace</span> Foo</span>
<span id="cb585-4"><a href="#cb585-4" aria-hidden="true"></a>{</span>
<span id="cb585-5"><a href="#cb585-5" aria-hidden="true"></a>   <span class="dt">void</span> barA() ;</span>
<span id="cb585-6"><a href="#cb585-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>Just to be sure you remarked: There is no useless declaration of barB nor myGlobal. Which means that no one reading the header knows what’s hidden behind barA.</p>
<p>Then, the CPP:</p>
<div class="sourceCode" id="cb586"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb586-1"><a href="#cb586-1" aria-hidden="true"></a><span class="co">// CPP</span></span>
<span id="cb586-2"><a href="#cb586-2" aria-hidden="true"></a><span class="kw">namespace</span> Foo</span>
<span id="cb586-3"><a href="#cb586-3" aria-hidden="true"></a>{</span>
<span id="cb586-4"><a href="#cb586-4" aria-hidden="true"></a>   <span class="kw">namespace</span></span>
<span id="cb586-5"><a href="#cb586-5" aria-hidden="true"></a>   {</span>
<span id="cb586-6"><a href="#cb586-6" aria-hidden="true"></a>      <span class="bu">std::</span>string myGlobal ;</span>
<span id="cb586-7"><a href="#cb586-7" aria-hidden="true"></a></span>
<span id="cb586-8"><a href="#cb586-8" aria-hidden="true"></a>      <span class="dt">void</span> Foo::barB()</span>
<span id="cb586-9"><a href="#cb586-9" aria-hidden="true"></a>      {</span>
<span id="cb586-10"><a href="#cb586-10" aria-hidden="true"></a>         <span class="co">// I can access Foo::myGlobal</span></span>
<span id="cb586-11"><a href="#cb586-11" aria-hidden="true"></a>      }</span>
<span id="cb586-12"><a href="#cb586-12" aria-hidden="true"></a>   }</span>
<span id="cb586-13"><a href="#cb586-13" aria-hidden="true"></a></span>
<span id="cb586-14"><a href="#cb586-14" aria-hidden="true"></a>   <span class="dt">void</span> barA()</span>
<span id="cb586-15"><a href="#cb586-15" aria-hidden="true"></a>   {</span>
<span id="cb586-16"><a href="#cb586-16" aria-hidden="true"></a>      <span class="co">// I can access myGlobal, too</span></span>
<span id="cb586-17"><a href="#cb586-17" aria-hidden="true"></a>   }</span>
<span id="cb586-18"><a href="#cb586-18" aria-hidden="true"></a>}</span>
<span id="cb586-19"><a href="#cb586-19" aria-hidden="true"></a></span>
<span id="cb586-20"><a href="#cb586-20" aria-hidden="true"></a><span class="dt">void</span> barC()</span>
<span id="cb586-21"><a href="#cb586-21" aria-hidden="true"></a>{</span>
<span id="cb586-22"><a href="#cb586-22" aria-hidden="true"></a>   <span class="co">// I STILL CAN&#39;T access myGlobal !!!</span></span>
<span id="cb586-23"><a href="#cb586-23" aria-hidden="true"></a>}</span></code></pre></div>
<p>As you can see, like the so-called “static class” declaration, fooA and fooB are still able to access myGlobal. But no one else can. And no one else outside this CPP knows fooB and myGlobal even exist!</p>
<p><b>Unlike the “static class” walking on the nude with her address book tattooed on her skin the “anonymous” namespace is fully clothed</b>, which seems quite better encapsulated AFAIK.</p>
<h5>
Does it really matter?
</h3>
<p>Unless the users of your code are saboteurs (I’ll let you, as an exercise, find how one can access to the private part of a public class using a dirty behaviour-undefined hack…), what’s <code>private</code> is <code>private</code>, even if it is visible in the <code>private</code> section of a class declared in a header.</p>
<p>Still, if you need to add another “private function” with access to the private member, you still must declare it to all the world by modifying the header, which is a paradox as far as I am concerned: <b>If I change the implementation of my code (the CPP part), then the interface (the HPP part) should NOT change.</b> Quoting Leonidas : “<b>This is ENCAPSULATION!</b>”</p>
<h5>
Edit 2014-09-20
</h2>
<p>When are classes static methods are actually better than namespaces with non-member functions?</p>
<p>When you need to group together functions and feed that group to a template:</p>
<div class="sourceCode" id="cb587"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb587-1"><a href="#cb587-1" aria-hidden="true"></a><span class="kw">namespace</span> alpha</span>
<span id="cb587-2"><a href="#cb587-2" aria-hidden="true"></a>{</span>
<span id="cb587-3"><a href="#cb587-3" aria-hidden="true"></a>   <span class="dt">void</span> foo() ;</span>
<span id="cb587-4"><a href="#cb587-4" aria-hidden="true"></a>   <span class="dt">void</span> bar() ;</span>
<span id="cb587-5"><a href="#cb587-5" aria-hidden="true"></a>}</span>
<span id="cb587-6"><a href="#cb587-6" aria-hidden="true"></a></span>
<span id="cb587-7"><a href="#cb587-7" aria-hidden="true"></a><span class="kw">struct</span> Beta</span>
<span id="cb587-8"><a href="#cb587-8" aria-hidden="true"></a>{</span>
<span id="cb587-9"><a href="#cb587-9" aria-hidden="true"></a>   <span class="at">static</span> <span class="dt">void</span> foo() ;</span>
<span id="cb587-10"><a href="#cb587-10" aria-hidden="true"></a>   <span class="at">static</span> <span class="dt">void</span> bar() ;</span>
<span id="cb587-11"><a href="#cb587-11" aria-hidden="true"></a>};</span>
<span id="cb587-12"><a href="#cb587-12" aria-hidden="true"></a></span>
<span id="cb587-13"><a href="#cb587-13" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb587-14"><a href="#cb587-14" aria-hidden="true"></a><span class="kw">struct</span> Gamma</span>
<span id="cb587-15"><a href="#cb587-15" aria-hidden="true"></a>{</span>
<span id="cb587-16"><a href="#cb587-16" aria-hidden="true"></a>   <span class="dt">void</span> foobar()</span>
<span id="cb587-17"><a href="#cb587-17" aria-hidden="true"></a>   {</span>
<span id="cb587-18"><a href="#cb587-18" aria-hidden="true"></a>      T::foo() ;</span>
<span id="cb587-19"><a href="#cb587-19" aria-hidden="true"></a>      T::bar() ;</span>
<span id="cb587-20"><a href="#cb587-20" aria-hidden="true"></a>   }</span>
<span id="cb587-21"><a href="#cb587-21" aria-hidden="true"></a>};</span>
<span id="cb587-22"><a href="#cb587-22" aria-hidden="true"></a></span>
<span id="cb587-23"><a href="#cb587-23" aria-hidden="true"></a>Gamma&lt;alpha&gt; ga ; <span class="co">// compilation error</span></span>
<span id="cb587-24"><a href="#cb587-24" aria-hidden="true"></a>Gamma&lt;Beta&gt; gb ;  <span class="co">// ok</span></span>
<span id="cb587-25"><a href="#cb587-25" aria-hidden="true"></a>gb.foobar() ;     <span class="co">// ok !!!</span></span></code></pre></div>
<p>Because, if a class can be a template parameter, a namespaces cannot.</p>
</section>
<section id="answer-3-score-62-2" class="level4">
<h4>Answer 3 (score 62)</h4>
<p>You can also create a free function in a namespace:</p>
<p>In BitParser.h</p>
<div class="sourceCode" id="cb588"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb588-1"><a href="#cb588-1" aria-hidden="true"></a><span class="kw">namespace</span> BitParser</span>
<span id="cb588-2"><a href="#cb588-2" aria-hidden="true"></a>{</span>
<span id="cb588-3"><a href="#cb588-3" aria-hidden="true"></a>    <span class="dt">bool</span> getBitAt(<span class="dt">int</span> buffer, <span class="dt">int</span> bitIndex);</span>
<span id="cb588-4"><a href="#cb588-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>In BitParser.cpp</p>
<div class="sourceCode" id="cb589"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb589-1"><a href="#cb589-1" aria-hidden="true"></a><span class="kw">namespace</span> BitParser</span>
<span id="cb589-2"><a href="#cb589-2" aria-hidden="true"></a>{</span>
<span id="cb589-3"><a href="#cb589-3" aria-hidden="true"></a>    <span class="dt">bool</span> getBitAt(<span class="dt">int</span> buffer, <span class="dt">int</span> bitIndex)</span>
<span id="cb589-4"><a href="#cb589-4" aria-hidden="true"></a>    {</span>
<span id="cb589-5"><a href="#cb589-5" aria-hidden="true"></a>        <span class="co">//get the bit :)</span></span>
<span id="cb589-6"><a href="#cb589-6" aria-hidden="true"></a>    }</span>
<span id="cb589-7"><a href="#cb589-7" aria-hidden="true"></a>}</span></code></pre></div>
<p>In general this would be the preferred way to write the code. When there’s no need for an object don’t use a class.</p>
<p></b> </em> </i> </small> </strong> </sub> </sup></p>
</section>
</section>
<section id="how-to-make-a-simple-c-makefile-score-411599-in-2015" class="level3">
<h3>100: How to make a SIMPLE C++ Makefile? (score <a href="https://stackoverflow.com/q/2481269.html">411599</a> in 2015)</h3>
<section id="question-97" class="level4">
<h4>Question</h4>
<p>We are required to use a Makefile to pull everything together for our project but our professor never showed us how to.</p>
<p>
I only have ONE file, <code>a3driver.cpp</code>. The driver imports a class from a location <code>"/user/cse232/Examples/example32.sequence.cpp"</code>.
</p>
<p>That’s it, everything else is contained with the <code>.cpp</code>.</p>
<p>How would I go about making a simple Makefile that creates an executable called <code>a3a.exe</code>?</p>
</section>
<section id="answer-accepted-score-524" class="level4">
<h4>Answer accepted (score 524)</h4>
<p>Copied from a wiki post I wrote for physics grad students.</p>
<p>Since this is for unix the executables have no extensions.</p>
<p>One thing to note is that <code>root-config</code> is a utility which provides the right compilation and linking flags; and the right libraries for building applications against root. That’s just a detail related to the original audience for this document.</p>
<h5>
Make Me Baby
</h2>
<p><strong>or You Never Forget The First Time You Got Made</strong></p>
<p>A introductory discussion of make, and how to write a simple makefile</p>
<p><strong>What is Make? And Why Should I Care?</strong></p>
<p>The tool called make is a build dependency manager. That is, it takes care of knowing what commands need to be executed in what order to take your software project from a collection of source files, object files, libraries, headers, etc. etc.—some of which may have changed recently—and turning them into a correct up-to-date version of the program.</p>
<p>Actually you can use make for other things too, but I’m not going to talk about that.</p>
<p><strong>A Trivial Makefile</strong></p>
<p>Suppose that you have a directory containing: <code>tool</code> <code>tool.cc</code> <code>tool.o</code> <code>support.cc</code> <code>support.hh</code>, and <code>support.o</code> which depend on <code>root</code> and are supposed to be compiled into a program called <code>tool</code>, and suppose that you’ve been hacking on the source files (which means the existing <code>tool</code> is now out of date) and want to compile the program.</p>
<p>To do this yourself you could</p>
<ol type="1">
<li>check if either <code>support.cc</code> or <code>support.hh</code> is newer than <code>support.o</code>, and if so run a command like</li>
</ol>
<div class="sourceCode" id="cb590"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb590-1"><a href="#cb590-1" aria-hidden="true"></a>g++ -g -c -pthread -I/sw/include/root support.cc</span></code></pre></div>
<ol start="2" type="1">
<li>check if either <code>support.hh</code> or <code>tool.cc</code> are newer than <code>tool.o</code>, and if so run a command like</li>
</ol>
<div class="sourceCode" id="cb591"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb591-1"><a href="#cb591-1" aria-hidden="true"></a>g++ -g  -c -pthread -I/sw/include/root tool.cc</span></code></pre></div>
<ol start="3" type="1">
<li>check if <code>tool.o</code> is newer than <code>tool</code>, and if so run a command like</li>
</ol>
<div class="sourceCode" id="cb592"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb592-1"><a href="#cb592-1" aria-hidden="true"></a>g++ -g tool.o support.o -L/sw/lib/root -lCore -lCint -lRIO -lNet -lHist -lGraf -lGraf3d -lGpad -lTree -lRint \</span>
<span id="cb592-2"><a href="#cb592-2" aria-hidden="true"></a>  -lPostscript -lMatrix -lPhysics -lMathCore -lThread -lz -L/sw/lib -lfreetype -lz -Wl,-framework,CoreServices \</span>
<span id="cb592-3"><a href="#cb592-3" aria-hidden="true"></a>  -Wl,-framework,ApplicationServices -pthread -Wl,-rpath,/sw/lib/root -lm -ldl</span></code></pre></div>
<p>Phew! What a hassle! There is a lot to remember and several chances to make mistakes. (BTW– The particulars of the command lines exhibited here depend on our software environment. These ones work on my computer.)</p>
<p>Of course, you could just run all three commands every time. That would work, but doesn’t scale well to a substantial piece of software (like DOGS which takes more than 15 minutes to compile from the ground up on my MacBook).</p>
<p>Instead you could write a file called <code>makefile</code> like this:</p>
<div class="sourceCode" id="cb593"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb593-1"><a href="#cb593-1" aria-hidden="true"></a>tool: tool.o support.o</span>
<span id="cb593-2"><a href="#cb593-2" aria-hidden="true"></a>    g++ -g -o tool tool.o support.o -L/sw/lib/root -lCore -lCint -lRIO -lNet -lHist -lGraf -lGraf3d -lGpad -lTree -lRint \</span>
<span id="cb593-3"><a href="#cb593-3" aria-hidden="true"></a>        -lPostscript -lMatrix -lPhysics -lMathCore -lThread -lz -L/sw/lib -lfreetype -lz -Wl,-framework,CoreServices \</span>
<span id="cb593-4"><a href="#cb593-4" aria-hidden="true"></a>        -Wl,-framework,ApplicationServices -pthread -Wl,-rpath,/sw/lib/root -lm -ldl</span>
<span id="cb593-5"><a href="#cb593-5" aria-hidden="true"></a></span>
<span id="cb593-6"><a href="#cb593-6" aria-hidden="true"></a>tool.o: tool.cc support.hh</span>
<span id="cb593-7"><a href="#cb593-7" aria-hidden="true"></a>    g++ -g  -c -pthread -I/sw/include/root tool.cc</span>
<span id="cb593-8"><a href="#cb593-8" aria-hidden="true"></a></span>
<span id="cb593-9"><a href="#cb593-9" aria-hidden="true"></a>support.o: support.hh support.cc</span>
<span id="cb593-10"><a href="#cb593-10" aria-hidden="true"></a>    g++ -g -c -pthread -I/sw/include/root support.cc</span></code></pre></div>
<p>and just type <code>make</code> at the command line. which will perform the three steps shown above automatically.</p>
<p>The un-indented lines here have the form <em>“target: dependencies”</em> and tell make that the associated commands (indented lines) should be run if any of the dependencies are newer than the target. That is the dependency lines describe the logic of what needs to be rebuilt to accommodate changes in various files. If <code>support.cc</code> changes that means that <code>support.o</code> must be rebuilt, but <code>tool.o</code> can be left alone. When <code>support.o</code> changes <code>tool</code> must be rebuilt.</p>
<p>The commands associated with each dependency line are set off with a tab (see below) should modify the target (or at least touch it to update the modification time).</p>
<h5>
Variables, Built In Rules, and Other Goodies
</h2>
<p>At this point, our makefile is simply remembering the work that needs doing, but we still had to figure out and type each and every needed command in its entirety. It does not have to be that way: make is a powerful language with variables, text manipulation functions, and a whole slew of built-in rules which can make this much easier for us.</p>
<p><strong>Make Variables</strong></p>
<p>The syntax for accessing a make variable is <code>$(VAR)</code>.</p>
<p>
The syntax for assigning to a make variable is: <code>VAR = A text value of some kind</code> (or <code>VAR := A different text value but ignore this for the moment</code>).
</p>
<p>You can use variables in rules like this improved version of our makefile:</p>
<div class="sourceCode" id="cb594"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb594-1"><a href="#cb594-1" aria-hidden="true"></a>CPPFLAGS=-g -pthread -I/sw/include/root </span>
<span id="cb594-2"><a href="#cb594-2" aria-hidden="true"></a>LDFLAGS=-g</span>
<span id="cb594-3"><a href="#cb594-3" aria-hidden="true"></a>LDLIBS=-L/sw/lib/root -lCore -lCint -lRIO -lNet -lHist -lGraf -lGraf3d -lGpad -lTree -lRint \</span>
<span id="cb594-4"><a href="#cb594-4" aria-hidden="true"></a>       -lPostscript -lMatrix -lPhysics -lMathCore -lThread -lz -L/sw/lib -lfreetype -lz \</span>
<span id="cb594-5"><a href="#cb594-5" aria-hidden="true"></a>       -Wl,-framework,CoreServices -Wl,-framework,ApplicationServices -pthread -Wl,-rpath,/sw/lib/root \</span>
<span id="cb594-6"><a href="#cb594-6" aria-hidden="true"></a>       -lm -ldl</span>
<span id="cb594-7"><a href="#cb594-7" aria-hidden="true"></a></span>
<span id="cb594-8"><a href="#cb594-8" aria-hidden="true"></a>tool: tool.o support.o</span>
<span id="cb594-9"><a href="#cb594-9" aria-hidden="true"></a>    g++ <span class="er">$</span>(LDFLAGS) -o tool tool.o support.o <span class="er">$</span>(LDLIBS) </span>
<span id="cb594-10"><a href="#cb594-10" aria-hidden="true"></a></span>
<span id="cb594-11"><a href="#cb594-11" aria-hidden="true"></a>tool.o: tool.cc support.hh</span>
<span id="cb594-12"><a href="#cb594-12" aria-hidden="true"></a>    g++ <span class="er">$</span>(CPPFLAGS) -c tool.cc</span>
<span id="cb594-13"><a href="#cb594-13" aria-hidden="true"></a></span>
<span id="cb594-14"><a href="#cb594-14" aria-hidden="true"></a>support.o: support.hh support.cc</span>
<span id="cb594-15"><a href="#cb594-15" aria-hidden="true"></a>    g++ <span class="er">$</span>(CPPFLAGS) -c support.cc</span></code></pre></div>
<p>which is a little more readable, but still requires a lot of typing</p>
<p><strong>Make Functions</strong></p>
<p>GNU make supports a variety of functions for accessing information from the filesystem or other commands on the system. In this case we are interested in <code>$(shell ...)</code> which expands to the output of the argument(s), and <code>$(subst opat,npat,text)</code> which replaces all instances of <code>opat</code> with <code>npat</code> in text.</p>
<p>Taking advantage of this gives us:</p>
<div class="sourceCode" id="cb595"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb595-1"><a href="#cb595-1" aria-hidden="true"></a>CPPFLAGS=-g <span class="er">$</span>(shell root-config --cflags)</span>
<span id="cb595-2"><a href="#cb595-2" aria-hidden="true"></a>LDFLAGS=-g <span class="er">$</span>(shell root-config --ldflags)</span>
<span id="cb595-3"><a href="#cb595-3" aria-hidden="true"></a>LDLIBS=<span class="er">$</span>(shell root-config --libs)</span>
<span id="cb595-4"><a href="#cb595-4" aria-hidden="true"></a></span>
<span id="cb595-5"><a href="#cb595-5" aria-hidden="true"></a>SRCS=tool.cc support.cc</span>
<span id="cb595-6"><a href="#cb595-6" aria-hidden="true"></a>OBJS=<span class="er">$</span>(subst .cc,.o,<span class="er">$</span>(SRCS))</span>
<span id="cb595-7"><a href="#cb595-7" aria-hidden="true"></a></span>
<span id="cb595-8"><a href="#cb595-8" aria-hidden="true"></a>tool: <span class="er">$</span>(OBJS)</span>
<span id="cb595-9"><a href="#cb595-9" aria-hidden="true"></a>    g++ <span class="er">$</span>(LDFLAGS) -o tool <span class="er">$</span>(OBJS) <span class="er">$</span>(LDLIBS) </span>
<span id="cb595-10"><a href="#cb595-10" aria-hidden="true"></a></span>
<span id="cb595-11"><a href="#cb595-11" aria-hidden="true"></a>tool.o: tool.cc support.hh</span>
<span id="cb595-12"><a href="#cb595-12" aria-hidden="true"></a>    g++ <span class="er">$</span>(CPPFLAGS) -c tool.cc</span>
<span id="cb595-13"><a href="#cb595-13" aria-hidden="true"></a></span>
<span id="cb595-14"><a href="#cb595-14" aria-hidden="true"></a>support.o: support.hh support.cc</span>
<span id="cb595-15"><a href="#cb595-15" aria-hidden="true"></a>    g++ <span class="er">$</span>(CPPFLAGS) -c support.cc</span></code></pre></div>
<p>which is easier to type and much more readable.</p>
<p>Notice that</p>
<ol>
<li>
We are still stating explicitly the dependencies for each object file and the final executable
</li>
<li>
We’ve had to explicitly type the compilation rule for both source files
</li>
</ol>
<p><strong>Implicit and Pattern Rules</strong></p>
<p>We would generally expect that all c++ source files should be treated the same way, and make provides three ways to state this</p>
<ol>
<li>
suffix rules (considered obsolete in GNU make, but kept for backwards compatibility)
</li>
<li>
implicit rules
</li>
<li>
pattern rules
</li>
</ol>
<p>Implicit rules are built in, and a few will be discussed below. Pattern rules are specified in a form like</p>
<div class="sourceCode" id="cb596"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb596-1"><a href="#cb596-1" aria-hidden="true"></a>%.o: %.c </span>
<span id="cb596-2"><a href="#cb596-2" aria-hidden="true"></a>    <span class="er">$</span>(CC) <span class="er">$</span>(CFLAGS) <span class="er">$</span>(CPPFLAGS) -c <span class="er">$</span>&lt;</span></code></pre></div>
<p>which means that object files are generated from c source files by running the command shown, where the “automatic” variable <code>$&amp;lt;</code> expands to the name of the first dependency.</p>
<p><strong>Built-in Rules</strong></p>
<p>Make has a whole host of built in rules that mean that very often, a project can be compile by a very simple makefile, indeed.</p>
<p>The GNU make built in rule for c source files is the one exhibited above. Similarly we create object files from c++ source files with a rule like <code>$(CXX) -c $(CPPFLAGS) $(CFLAGS)</code></p>
<p>Single object files are linked using <code>$(LD) $(LDFLAGS) n.o $(LOADLIBES) $(LDLIBS)</code>, but this won’t work in our case, because we want to link multiple object files.</p>
<p><strong>Variables Used By Built-in Rules</strong></p>
<p>The built in rules use a set of standard variables that allow you to specify local environment information (like where to find the ROOT include files) without re-writing all the rules. The ones most likely to be interesting to us are:</p>
<ul>
<li>
<code>CC</code> – the c compiler to use
</li>
<li>
<code>CXX</code> – the c++ compiler to use
</li>
<li>
<code>LD</code> – the linker to use
</li>
<li>
<code>CFLAGS</code> – compilation flag for c source files
</li>
<li>
<code>CXXFLAGS</code> – compilation flags for c++ source files
</li>
<li>
<code>CPPFLAGS</code> – flags for the c-preprocessor (typically include file paths and symbols defined on the command line), used by c and c++
</li>
<li>
<code>LDFLAGS</code> – linker flags
</li>
<li>
<code>LDLIBS</code> – libraries to link
</li>
</ul>
<p><strong>A Basic Makefile</strong></p>
<p>By taking advantage of the built in rules we can simplify our makefile to:</p>
<div class="sourceCode" id="cb597"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb597-1"><a href="#cb597-1" aria-hidden="true"></a>CC=gcc</span>
<span id="cb597-2"><a href="#cb597-2" aria-hidden="true"></a>CXX=g++</span>
<span id="cb597-3"><a href="#cb597-3" aria-hidden="true"></a>RM=rm -f</span>
<span id="cb597-4"><a href="#cb597-4" aria-hidden="true"></a>CPPFLAGS=-g <span class="er">$</span>(shell root-config --cflags)</span>
<span id="cb597-5"><a href="#cb597-5" aria-hidden="true"></a>LDFLAGS=-g <span class="er">$</span>(shell root-config --ldflags)</span>
<span id="cb597-6"><a href="#cb597-6" aria-hidden="true"></a>LDLIBS=<span class="er">$</span>(shell root-config --libs)</span>
<span id="cb597-7"><a href="#cb597-7" aria-hidden="true"></a></span>
<span id="cb597-8"><a href="#cb597-8" aria-hidden="true"></a>SRCS=tool.cc support.cc</span>
<span id="cb597-9"><a href="#cb597-9" aria-hidden="true"></a>OBJS=<span class="er">$</span>(subst .cc,.o,<span class="er">$</span>(SRCS))</span>
<span id="cb597-10"><a href="#cb597-10" aria-hidden="true"></a></span>
<span id="cb597-11"><a href="#cb597-11" aria-hidden="true"></a>all: tool</span>
<span id="cb597-12"><a href="#cb597-12" aria-hidden="true"></a></span>
<span id="cb597-13"><a href="#cb597-13" aria-hidden="true"></a>tool: <span class="er">$</span>(OBJS)</span>
<span id="cb597-14"><a href="#cb597-14" aria-hidden="true"></a>    <span class="er">$</span>(CXX) <span class="er">$</span>(LDFLAGS) -o tool <span class="er">$</span>(OBJS) <span class="er">$</span>(LDLIBS) </span>
<span id="cb597-15"><a href="#cb597-15" aria-hidden="true"></a></span>
<span id="cb597-16"><a href="#cb597-16" aria-hidden="true"></a>tool.o: tool.cc support.hh</span>
<span id="cb597-17"><a href="#cb597-17" aria-hidden="true"></a></span>
<span id="cb597-18"><a href="#cb597-18" aria-hidden="true"></a>support.o: support.hh support.cc</span>
<span id="cb597-19"><a href="#cb597-19" aria-hidden="true"></a></span>
<span id="cb597-20"><a href="#cb597-20" aria-hidden="true"></a>clean:</span>
<span id="cb597-21"><a href="#cb597-21" aria-hidden="true"></a>    <span class="er">$</span>(RM) <span class="er">$</span>(OBJS)</span>
<span id="cb597-22"><a href="#cb597-22" aria-hidden="true"></a></span>
<span id="cb597-23"><a href="#cb597-23" aria-hidden="true"></a>distclean: clean</span>
<span id="cb597-24"><a href="#cb597-24" aria-hidden="true"></a>    <span class="er">$</span>(RM) tool</span></code></pre></div>
<p>We have also added several standard targets that perform special actions (like cleaning up the source directory).</p>
<p>Note that when make is invoked without an argument, it uses the first target found in the file (in this case all), but you can also name the target to get which is what makes <code>make clean</code> remove the object files in this case.</p>
<p>We still have all the dependencies hard-coded.</p>
<p><strong>Some Mysterious Improvements</strong></p>
<div class="sourceCode" id="cb598"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb598-1"><a href="#cb598-1" aria-hidden="true"></a>CC=gcc</span>
<span id="cb598-2"><a href="#cb598-2" aria-hidden="true"></a>CXX=g++</span>
<span id="cb598-3"><a href="#cb598-3" aria-hidden="true"></a>RM=rm -f</span>
<span id="cb598-4"><a href="#cb598-4" aria-hidden="true"></a>CPPFLAGS=-g <span class="er">$</span>(shell root-config --cflags)</span>
<span id="cb598-5"><a href="#cb598-5" aria-hidden="true"></a>LDFLAGS=-g <span class="er">$</span>(shell root-config --ldflags)</span>
<span id="cb598-6"><a href="#cb598-6" aria-hidden="true"></a>LDLIBS=<span class="er">$</span>(shell root-config --libs)</span>
<span id="cb598-7"><a href="#cb598-7" aria-hidden="true"></a></span>
<span id="cb598-8"><a href="#cb598-8" aria-hidden="true"></a>SRCS=tool.cc support.cc</span>
<span id="cb598-9"><a href="#cb598-9" aria-hidden="true"></a>OBJS=<span class="er">$</span>(subst .cc,.o,<span class="er">$</span>(SRCS))</span>
<span id="cb598-10"><a href="#cb598-10" aria-hidden="true"></a></span>
<span id="cb598-11"><a href="#cb598-11" aria-hidden="true"></a>all: tool</span>
<span id="cb598-12"><a href="#cb598-12" aria-hidden="true"></a></span>
<span id="cb598-13"><a href="#cb598-13" aria-hidden="true"></a>tool: <span class="er">$</span>(OBJS)</span>
<span id="cb598-14"><a href="#cb598-14" aria-hidden="true"></a>    <span class="er">$</span>(CXX) <span class="er">$</span>(LDFLAGS) -o tool <span class="er">$</span>(OBJS) <span class="er">$</span>(LDLIBS) </span>
<span id="cb598-15"><a href="#cb598-15" aria-hidden="true"></a></span>
<span id="cb598-16"><a href="#cb598-16" aria-hidden="true"></a>depend: .depend</span>
<span id="cb598-17"><a href="#cb598-17" aria-hidden="true"></a></span>
<span id="cb598-18"><a href="#cb598-18" aria-hidden="true"></a>.depend: <span class="er">$</span>(SRCS)</span>
<span id="cb598-19"><a href="#cb598-19" aria-hidden="true"></a>    <span class="er">$</span>(RM) ./.depend</span>
<span id="cb598-20"><a href="#cb598-20" aria-hidden="true"></a>    <span class="er">$</span>(CXX) <span class="er">$</span>(CPPFLAGS) -MM <span class="er">$</span>^&gt;&gt;./.depend;</span>
<span id="cb598-21"><a href="#cb598-21" aria-hidden="true"></a></span>
<span id="cb598-22"><a href="#cb598-22" aria-hidden="true"></a>clean:</span>
<span id="cb598-23"><a href="#cb598-23" aria-hidden="true"></a>    <span class="er">$</span>(RM) <span class="er">$</span>(OBJS)</span>
<span id="cb598-24"><a href="#cb598-24" aria-hidden="true"></a></span>
<span id="cb598-25"><a href="#cb598-25" aria-hidden="true"></a>distclean: clean</span>
<span id="cb598-26"><a href="#cb598-26" aria-hidden="true"></a>    <span class="er">$</span>(RM) *~ .depend</span>
<span id="cb598-27"><a href="#cb598-27" aria-hidden="true"></a></span>
<span id="cb598-28"><a href="#cb598-28" aria-hidden="true"></a>include .depend</span></code></pre></div>
<p>Notice that</p>
<ol>
<li>
There are no longer any dependency lines for the source files!?!
</li>
<li>
There is some strange magic related to .depend and depend
</li>
<li>
If you do <code>make</code> then <code>ls -A</code> you see a file named <code>.depend</code> which contains things that look like make dependency lines
</li>
</ol>
<p><strong>Other Reading</strong></p>
<ul>
<li>
<a href="http://www.gnu.org/software/make/manual/make.html" rel="noreferrer">GNU make manual</a>
</li>
<li>
<a href="http://miller.emu.id.au/pmiller/books/rmch/" rel="noreferrer">Recursive Make Considered Harmful</a> on a common way of writing makefiles that is less than optimal, and how to avoid it.
</li>
</ul>
<p><strong>Know Bugs and Historical Notes</strong></p>
<p>The input language for make is whitespace sensitive. In particular <em>the action lines following dependencies must start with a tab</em>. But a series of spaces can look the same (and indeed there are editors that will silently convert tabs to spaces or vice versa), which results in a make file that looks right and still doesn’t work. This was identified as a bug early on but (<a href="http://www.catb.org/esr/writings/taoup/html/ch15s04.html" rel="noreferrer">the story goes</a>) was not fixed because there were already 10 users.</p>
</section>
<section id="answer-2-score-52-1" class="level4">
<h4>Answer 2 (score 52)</h4>
<p>I’ve always thought this was easier to learn with a detailed example, so here’s how I think of makefiles. For each section you have one line that’s not indented and it shows the name of the section followed by dependencies. The dependencies can be either other sections (which will be run before the current section) or files (which if updated will cause the current section to be run again next time you run <code>make</code>).</p>
<p>Here’s a quick example (keep in mind that I’m using 4 spaces where I should be using a tab, Stack Overflow won’t let me use tabs):</p>
<div class="sourceCode" id="cb599"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb599-1"><a href="#cb599-1" aria-hidden="true"></a>a3driver: a3driver.o</span>
<span id="cb599-2"><a href="#cb599-2" aria-hidden="true"></a>    g++ -o a3driver a3driver.o</span>
<span id="cb599-3"><a href="#cb599-3" aria-hidden="true"></a></span>
<span id="cb599-4"><a href="#cb599-4" aria-hidden="true"></a>a3driver.o: a3driver.cpp</span>
<span id="cb599-5"><a href="#cb599-5" aria-hidden="true"></a>    g++ -c a3driver.cpp</span></code></pre></div>
<p>When you type <code>make</code>, it will choose the first section (a3driver). a3driver depends on a3driver.o, so it will go to that section. a3driver.o depends on a3driver.cpp, so it will only run if a3driver.cpp has changed since it was last run. Assuming it has (or has never been run), it will compile a3driver.cpp to a .o file, then go back to a3driver and compile the final executable.</p>
<p>Since there’s only one file, it could even be reduced to:</p>
<div class="sourceCode" id="cb600"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb600-1"><a href="#cb600-1" aria-hidden="true"></a>a3driver: a3driver.cpp</span>
<span id="cb600-2"><a href="#cb600-2" aria-hidden="true"></a>    g++ -o a3driver a3driver.cpp</span></code></pre></div>
<p>The reason I showed the first example is that it shows the power of makefiles. If you need to compile another file, you can just add another section. Here’s an example with a secondFile.cpp (which loads in a header named secondFile.h):</p>
<div class="sourceCode" id="cb601"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb601-1"><a href="#cb601-1" aria-hidden="true"></a>a3driver: a3driver.o secondFile.o</span>
<span id="cb601-2"><a href="#cb601-2" aria-hidden="true"></a>    g++ -o a3driver a3driver.o secondFile.o</span>
<span id="cb601-3"><a href="#cb601-3" aria-hidden="true"></a></span>
<span id="cb601-4"><a href="#cb601-4" aria-hidden="true"></a>a3driver.o: a3driver.cpp</span>
<span id="cb601-5"><a href="#cb601-5" aria-hidden="true"></a>    g++ -c a3driver.cpp</span>
<span id="cb601-6"><a href="#cb601-6" aria-hidden="true"></a></span>
<span id="cb601-7"><a href="#cb601-7" aria-hidden="true"></a>secondFile.o: secondFile.cpp secondFile.h</span>
<span id="cb601-8"><a href="#cb601-8" aria-hidden="true"></a>    g++ -c secondFile.cpp</span></code></pre></div>
<p>This way if you change something in secondFile.cpp or secondFile.h and recompile, it will only recompile secondFile.cpp (not a3driver.cpp). Or alternately, if you change something in a3driver.cpp, it won’t recompile secondFile.cpp.</p>
<p>Let me know if you have any questions about it.</p>
<p>It’s also traditional to include a section named “all” and a section named “clean”. “all” will usually build all of the executables, and “clean” will remove “build artifacts” like .o files and the executables:</p>
<div class="sourceCode" id="cb602"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb602-1"><a href="#cb602-1" aria-hidden="true"></a>all: a3driver ;</span>
<span id="cb602-2"><a href="#cb602-2" aria-hidden="true"></a></span>
<span id="cb602-3"><a href="#cb602-3" aria-hidden="true"></a>clean:</span>
<span id="cb602-4"><a href="#cb602-4" aria-hidden="true"></a></span>
<span id="cb602-5"><a href="#cb602-5" aria-hidden="true"></a><span class="pp"># </span><span class="er">-f so this will succeed even if the files don&#39;t exist</span></span>
<span id="cb602-6"><a href="#cb602-6" aria-hidden="true"></a>    rm -f a3driver a3driver.o</span></code></pre></div>
<p>EDIT: I didn’t notice you’re on Windows. I think the only difference is changing the <code>-o a3driver</code> to <code>-o a3driver.exe</code>.</p>
</section>
<section id="answer-3-score-35-2" class="level4">
<h4>Answer 3 (score 35)</h4>
<p>Why does everyone like to list out source files? A simple find command can take care of that easily.</p>
<p>Here’s an example of a dirt simple C++ Makefile. Just drop it in a directory containing <code>.C</code> files and then type <code>make</code>…</p>
<div class="sourceCode" id="cb603"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb603-1"><a href="#cb603-1" aria-hidden="true"></a>appname := myapp</span>
<span id="cb603-2"><a href="#cb603-2" aria-hidden="true"></a></span>
<span id="cb603-3"><a href="#cb603-3" aria-hidden="true"></a>CXX := clang++</span>
<span id="cb603-4"><a href="#cb603-4" aria-hidden="true"></a>CXXFLAGS := -std=c++<span class="dv">11</span></span>
<span id="cb603-5"><a href="#cb603-5" aria-hidden="true"></a></span>
<span id="cb603-6"><a href="#cb603-6" aria-hidden="true"></a>srcfiles := <span class="er">$</span>(shell find . -name <span class="st">&quot;*.C&quot;</span>)</span>
<span id="cb603-7"><a href="#cb603-7" aria-hidden="true"></a>objects  := <span class="er">$</span>(patsubst %.C, %.o, <span class="er">$</span>(srcfiles))</span>
<span id="cb603-8"><a href="#cb603-8" aria-hidden="true"></a></span>
<span id="cb603-9"><a href="#cb603-9" aria-hidden="true"></a>all: <span class="er">$</span>(appname)</span>
<span id="cb603-10"><a href="#cb603-10" aria-hidden="true"></a></span>
<span id="cb603-11"><a href="#cb603-11" aria-hidden="true"></a><span class="er">$</span>(appname): <span class="er">$</span>(objects)</span>
<span id="cb603-12"><a href="#cb603-12" aria-hidden="true"></a>    <span class="er">$</span>(CXX) <span class="er">$</span>(CXXFLAGS) <span class="er">$</span>(LDFLAGS) -o <span class="er">$</span>(appname) <span class="er">$</span>(objects) <span class="er">$</span>(LDLIBS)</span>
<span id="cb603-13"><a href="#cb603-13" aria-hidden="true"></a></span>
<span id="cb603-14"><a href="#cb603-14" aria-hidden="true"></a>depend: .depend</span>
<span id="cb603-15"><a href="#cb603-15" aria-hidden="true"></a></span>
<span id="cb603-16"><a href="#cb603-16" aria-hidden="true"></a>.depend: <span class="er">$</span>(srcfiles)</span>
<span id="cb603-17"><a href="#cb603-17" aria-hidden="true"></a>    rm -f ./.depend</span>
<span id="cb603-18"><a href="#cb603-18" aria-hidden="true"></a>    <span class="er">$</span>(CXX) <span class="er">$</span>(CXXFLAGS) -MM <span class="er">$</span>^&gt;&gt;./.depend;</span>
<span id="cb603-19"><a href="#cb603-19" aria-hidden="true"></a></span>
<span id="cb603-20"><a href="#cb603-20" aria-hidden="true"></a>clean:</span>
<span id="cb603-21"><a href="#cb603-21" aria-hidden="true"></a>    rm -f <span class="er">$</span>(objects)</span>
<span id="cb603-22"><a href="#cb603-22" aria-hidden="true"></a></span>
<span id="cb603-23"><a href="#cb603-23" aria-hidden="true"></a>dist-clean: clean</span>
<span id="cb603-24"><a href="#cb603-24" aria-hidden="true"></a>    rm -f *~ .depend</span>
<span id="cb603-25"><a href="#cb603-25" aria-hidden="true"></a></span>
<span id="cb603-26"><a href="#cb603-26" aria-hidden="true"></a>include .depend</span></code></pre></div>
</section>
</section>
</section>
</body>
</html>
